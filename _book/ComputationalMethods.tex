% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Computational Methods in der politischen Kommunikationsforschung},
  pdfauthor={Julian Unkel},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Computational Methods in der politischen Kommunikationsforschung}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Methodische Vertiefung: Computational Methods mit R und RStudio}
\author{Julian Unkel}
\date{}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Beispiel}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Übungsaufgabe}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Lösung }
\let\BeginKnitrBlock\begin \let\EndKnitrBlock\end
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{einfuxfchrung}{%
\chapter*{Einführung}\label{einfuxfchrung}}
\addcontentsline{toc}{chapter}{Einführung}

Zuletzt aktualisiert: 2020-04-16 15:23:26.
Dies ist ein \emph{Work-in-Progress} und wird laufend aktualisiert.

\hypertarget{seminarinformationen}{%
\section*{Seminarinformationen}\label{seminarinformationen}}
\addcontentsline{toc}{section}{Seminarinformationen}

\begin{itemize}
\tightlist
\item
  Dozent: Julian Unkel, \href{mailto:unkel@ifkw.lmu.de}{\nolinkurl{unkel@ifkw.lmu.de}}
\item
  Zeit und Ort: Donnerstags, 12-14 Uhr, \sout{Oe 057} (bis auf weiteres findet das Seminar rein digital statt)
\item
  Moodle: \url{https://moodle.lmu.de/course/view.php?id=8250}
\item
  Zoom: \url{https://lmu-munich.zoom.us/j/6679571494}
\end{itemize}

\hypertarget{ablauf-des-kurses}{%
\section*{Ablauf des Kurses}\label{ablauf-des-kurses}}
\addcontentsline{toc}{section}{Ablauf des Kurses}

Aufgrund der aktuellen Situation wird dieses Seminar in einen Online-Kurs überführt. Alle Seminarinhalte werden in Textform aufbereitet und nach und nach diesem Online-Kurs hinzugefügt. Auf Basis des Kurses sollen die Seminarinhalte selbstständig und mit weitestgehend eigenem Lerntempo erarbeitet werden.

In jedem Kapitel werden hierzu zunächst die wesentlichen Konzepte und Inhalte erläutert. Jedes Kapitel schließt mit einigen Übungsaufgaben, die über Moodle abgegeben werden können. Deadlines für die Übungsaufgaben werden ebenfalls über Moodle kommuniziert, Lösungen im Anschluss an die Deadlines im Kurs hinzugefügt.

Jeden Donnerstag zum regulären Seminartermin findet von 12-14 Uhr eine Online-Sprechstunde via Zoom statt. Hier können Fragen zu den Seminarinhalten, Übungsaufgaben etc. gestellt und diskutiert werden.

In Moodle stehen zudem zwei Foren zur Verfügung, in dem Sie 1) allgemeine Fragen zu R und RStudio sowie 2) spezifische Fragen / alternative Lösungen zu den Übungsaufgaben (vor-)stellen und diskutieren können. Scheuen Sie sich bitte nicht, auch selbst auf Fragen und Probleme von Kommiliton*innen einzugehen.

Neben den regulären Übungsaufgaben werden Sie bisweilen auch optionale, besonders knifflige Aufgaben vorfinden, die ich in der Sprache meiner Ahnen als \emph{Käpseles-Aufgaben} kennzeichnen werde. Diese sind nicht verpflichtend, können Ihnen aber als Gradmesser dienen, ob Sie die jeweiligen Inhalte auch eigenständig und in leicht abgewandelter Form anwenden können.

\hypertarget{motivation-und-ziele-des-seminars}{%
\section*{Motivation und Ziele des Seminars}\label{motivation-und-ziele-des-seminars}}
\addcontentsline{toc}{section}{Motivation und Ziele des Seminars}

Das Ziel des Kurses ist es, methodische Kenntnisse zur Anwendung computationaler Methoden zu vermitteln. Hierzu werden wir uns zunächst allgemein mit der Datenbearbeitung und -analyse mit der statistischen Programmiersprache R auseinandersetzen. Es folgen dann spezifischere Verfahren der computationalen Datenerhebung und -analyse.

Dabei stehen insbesondere folgende Inhalte im Vordergrund:

\begin{itemize}
\tightlist
\item
  Einführung in \emph{R} und die Arbeit mit \emph{RStudio}
\item
  Datenmanagement in \emph{R}
\item
  Computationale Datenerhebung mit \emph{R}
\item
  Datenvisualisierung mit \emph{R}
\item
  Automatisierte Inhaltsanalyse mit \emph{R}
\end{itemize}

Zudem wird darauf eingegangen, wie mittels R und RStudio Kommunikationsforschung transparent, nachvollziehbar und reproduzierbar gestaltet werden kann.

Es werden keine Vorkenntnisse in R vorausgesetzt; die Inhalte der Veranstaltung \emph{15424 Datenanalyse} werden als bekannt vorausgesetzt.

Bevor es jedoch ans Eingemachte geht, ein paar Worte zur Motivation hinter diesem Seminar: Warum lohnt es sich überhaupt, eine Programmiersprache für die quantitativ-wissenschaftliche Arbeit zu lernen? Und warum ausgerechnet R?

\hypertarget{warum-also-eine-programmiersprache-fuxfcr-datenanalyse-lernen}{%
\subsection*{Warum also eine Programmiersprache für Datenanalyse lernen?}\label{warum-also-eine-programmiersprache-fuxfcr-datenanalyse-lernen}}
\addcontentsline{toc}{subsection}{Warum also eine Programmiersprache für Datenanalyse lernen?}

Wenn Sie bisher Daten statistisch ausgewertet haben, etwa im Rahmen von Forschungsseminaren oder der Bachelorarbeit, wird das in der Regel mit einem Programm mit grafischer Oberfläche erfolgt sein, etwa mit \emph{Microsoft Excel} oder mit \emph{IBM SPSS}. Diese Programme haben viele Vorteile: sie sind meist auf spezifische Funktionen zugeschnitten, in ihrer Aufmachung an typische Computersoftware angepasst und entsprechend intuitiv zu bedienen - ein paar Klicks, und schon gibt SPSS eine Regressionstabelle mit allen relevanten Informationen aus. Für die meisten Anwendungsfälle im KW-Studium bieten genannten Programme leicht zu erlernende und umzusetzende Lösungen an. Programmiersprachen haben hingegen eine zweifellos höhere Einstiegshürde, deren Bewältigung für viele Anwendungsfälle in der Kommunikationswissenschaft auf den ersten Blick keinen größeren Nutzen verspricht.

Vielleicht ist im Studium aber auch schon eine Situation aufgetreten, in der SPSS keine Hilfe bot. Eine Effektstärke für einen Mittelwertvergleich? Die bietet SPSS zwar in Form von \(\eta^2_p\) für die ANOVA an, nicht jedoch Cohen's \(d\) für den t-Test. Sie haben zusammen mit Komillitoninnen eine Inhaltsanalyse geplant und möchten vorab einen Intercoderreliabilitätstest durchführen? SPSS kennt weder die Reliabilität nach Holsti noch Krippendorff's \(\alpha\). Und auch wenn SPSS Grafiken ausgeben kann, so hat es doch einen Grund, warum man diese selten in wissenschaftlichen Veröffentlichungen (und hoffentlich auch in studentischen Arbeiten) findet.

Benötigt man also eine Funktion, die in der gewählten Softwarelösung nicht vorhanden ist, so muss man auf eine andere ausweichen. Programmiersprachen bieten hier deutlich mehr Flexibilität - ist die gewünschte Funktion nicht vorhanden, so schreibt man sie eben selbst (bzw. hat dies in aller Regel schon jemand anderes, der ebenfalls vor diesem Problem stand, für Sie getan). Dies gilt natürlich umso mehr, je weniger standardisiert die zu analysierenden Daten und gewählten Analyseverfahren sind. Beschäftigen wir uns beispielsweise mit Onlinetexten oder digitalen Spurendaten, dann liegen diese oftmals nicht in vorstrukturierter Form vor, müssen erst über Schnittstellen abgerufen, automatisiert heruntergeladen und/oder für die weitere Nutzung aufbereitet werden. Computationale Analyseverfahren wie beispielsweise Verfahren zur automatisierten Inhaltsanalyse werden beständig weiterentwickelt und angepasst. Die Flexibilität, die skriptbasierte Datenanalyse bietet, ist daher einer der Hauptgründe, warum nicht nur in der Wissenschaft, sondern auch in anderen professionellen Kontexten, etwa der Markt- und Medienforschung, wo Lösungen für vielseitige datenanalytische Fragen gesucht werden, die Bedeutung von Programmiersprachen zur Datenanalyse zunimmt.

Zugleich ist der Einstieg in das Programmieren deutlich einfacher geworden. Für viele Programmiersprachen stehen sogenannte Integrierte Entwicklungsumgebungen (IDEs) zur Verfügung, die mittels grafischer Benutzeroberflächen, intuitiver Bedienung und Hilfswerkzeugen (z. B. der automatischen Vervollständigung von Funktionsnamen) den Umgang mit Programmiersprachen deutlich erleichtern und komfortabler gestalten.

Ein weiterer entscheidender Vorteil der \emph{programmatischen} \footnote{d.~h. skript- bzw. codebasiert; im Englischen wird \emph{programmatically} verwendet, um auszudrücken, dass etwas `durch Code' und nicht durch Klicken von Knöpfen in einem Computerprogramm erfolgt ist, im Deutschen ist diese Wortbedeutung außerhalb von Informatikkreisen (noch) kaum geläufig; siehe auch \href{https://german.stackexchange.com/questions/5675/welches-wort-anstelle-von-programmatisch}{diese Diskussion} zur Wortbedeutung.} Datenanalyse ist, dass Skripte und Code alle Analyseschritte nachvollziehbar, transparent und reproduzierbar gestalten (entsprechend wurden Sie in der Datenanalyse-Ausbildung vermutlich auch dazu angehalten, in SPSS stets die Syntax zu nutzen). Einmal durchgeführte Arbeiten können somit jederzeit und problemlos von anderen und auch Ihnen selbst wiederholt und angepasst werden.

Schließlich können auch karrieretechnische Überlegungen eine Rolle spielen. Viele Unternehmen setzen für datenanalytische Tätigkeiten die Kenntnis einer einschlägigen Programmiersprache inzwischen zwingend voraus. Und natürlich spiegelt sich das auch im Gehalt wider: das Vergleichsportal \emph{PayScale} gibt beispielweise für \emph{Data Analysts}, die die \href{https://www.payscale.com/research/US/Job=Data_Analyst/Salary/beb644bc/R}{statistische Programmiersprache R} beherrschen, ein um rund 5.000 US-Dollar höheres Jahresdurchschnittsgehalt an als für diejenigen Data Analysts, die mit \href{https://www.payscale.com/research/US/Job=Data_Analyst/Salary/cc748401/SPSS}{SPSS} arbeiten.

\hypertarget{warum-r-lernen}{%
\subsection*{\texorpdfstring{Warum \emph{R} lernen?}{Warum R lernen?}}\label{warum-r-lernen}}
\addcontentsline{toc}{subsection}{Warum \emph{R} lernen?}

Bisher wurde allgemein von Programmiersprachen gesprochen. In der Datenanalyse-Praxis sind viele unterschiedliche Programmiersprachen gängig, z. B. \emph{Python}, \emph{R}, \emph{SQL} und \emph{Julia}. Wir werden in den kommenden zwei Semestern mit R arbeiten. Dies hat einige Gründe:

\begin{itemize}
\tightlist
\item
  R ist eine speziell auf statistische und datenanalytische Anwendungen ausgelegte Programmiersprache (auch wenn die Anwendungsbereiche inzwischen darüber hinausgehen). Das bedeutet, dass viele gängige statistische Verfahren bereits in der Basis-Version vorhanden sind und ohne weitere Anpassungen genutzt werden können.
\item
  In der \emph{Scientific Community} ist R inzwischen sehr weit verbreitet und wird durch diese kontinuierlich weiterentwickelt. Das bedeutet auch, dass neue Verfahren, sowohl zur Datenerhebung als auch zur Datenanalyse, meist sehr schnell auch in R verfügbar sind.
\item
  Zugleich gibt es durch die weite Verbreitung auch vielzählige Hilfsangebote. In Communities wie \href{https://stackoverflow.com/}{Stack Overflow} und durch googeln werden Sie für nahezu jedes Problem, das sich Ihnen bei der Arbeit mit R stellt, schnell eine Lösung finden.
\item
  R ist komplett kostenlos und für jedes Betriebssystem verfügbar.
\item
  Mit \emph{RStudio} steht eine ebenfalls kostenfreie IDE zur Verfügung, die die ehemals hohen Einstiegshürden erheblich senkt.
\item
  R und RStudio decken durch Erweiterungen nahezu alle Schritte ab, die für die wissenschaftliche Arbeit erforderlich sind. Das reicht vom Datenabruf aus Befragungssoftware sowie der Datenerhebung durch Programmierschnittstellen oder Web Scraping über die Datenbearbeitung, -bereinigung und -analyse bis hin zur Erstellung von Manuskripten und publikationsfähigen Grafiken. Auch dieser Kurs ist komplett in RStudio erstellt.
\end{itemize}

Auch wenn sich R in einigen Aspekten von den oben genannten Programmiersprachen unterscheidet, so sind viele der Konzepte, die wir in den kommenden zwei Semestern lernen werden, auch in anderen Programmiersprachen gleich oder zumindest ähnlich umgesetzt. Ihnen wird es in Zukunft also auch leichter fallen, sich bei Bedarf in andere Programmiersprachen einzuarbeiten.

\hypertarget{hinweise-zur-nutzung-des-online-kurses}{%
\section*{Hinweise zur Nutzung des Online-Kurses}\label{hinweise-zur-nutzung-des-online-kurses}}
\addcontentsline{toc}{section}{Hinweise zur Nutzung des Online-Kurses}

\begin{itemize}
\tightlist
\item
  In der Onlineversion können Sie mit den Cursortasten \texttt{←} und \texttt{→} durch die Seiten des Kurses blättern.
\item
  In der oberen Leiste finden Sie einen Download-Knopf, mit dem Sie sich die aktuelle Version des Kurses als \emph{PDF} oder \emph{EPUB} (für E-Reader) herunterladen können. Bitte achten Sie in diesem Fall darauf, regelmäßig die aktuellste und somit vollständigste Version herunterzuladen. Oben auf dieser Seite ist angegeben, wann der Kurs zuletzt aktualisiert wurde.
\item
  Früher oder später wird etwas in Ihrem Code nicht so funktionieren, wie Sie sich das vorstellen oder wünschen. Hier greift die \href{https://twitter.com/math_rachel/status/764931533383749632}{15-Minuten-Regel}: Versuchen Sie zunächst, 15 Minuten lang das Problem selbst zu lösen - in dem Sie das Problem in kleinere Schritte zerlegen, den Code nach Tippfehlern durchsuchen, nochmals Hilfsdokumente konsultieren etc. Sind Sie nach 15 Minuten noch nicht weitergekommen, fragen Sie um Hilfe - z. B. in unseren Moodle-Foren.
\item
  Der Witz, wonach Programmieren zu 70\% aus Googeln bestehe, hat einen wahren Kern. Es ist nicht verwerflich, im Internet nach Hilfestellungen und Lösungen zu suchen und Code-Schnipsel von anderen zu verwenden - ganz im Gegenteil, gezieltes Suchen stellt einen wesentlichen Teil der Problemlösekompetenz dar. Auch wenn es jedoch verlockend und einfach erscheinen mag, Code von \href{https://stackoverflow.com/}{StackOverflow} und vergleichbaren Portalen zu kopieren, sollten Sie immer versuchen, den Code und damit die Lösung auch nachvollziehen zu können.
\end{itemize}

\begin{figure}
\centering
\includegraphics{img/horst/r_first_then.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

Beginnen wir mit der \protect\hyperlink{firststeps}{Installation von R und RStudio sowie ersten Schritten}.

\hypertarget{part-eine-kurze-einfuxfchrung-in-r}{%
\part{Eine kurze Einführung in R}\label{part-eine-kurze-einfuxfchrung-in-r}}

\hypertarget{firststeps}{%
\chapter{Installation und erste Schritte}\label{firststeps}}

In diesem Kapitel installieren wir die notwendige Software und machen uns mit der Benutzeroberfläche von RStudio vertraut.

\hypertarget{rinstallieren}{%
\section{R installieren}\label{rinstallieren}}

Zunächst benötigen wir natürlich R. Die aktuellste Version erhalten wir immer über \href{https://cran.r-project.org/}{CRAN} (\emph{C}omprehensive \emph{R} \emph{A}rchive \emph{N}etwork).

Unter ``Download and Install R'' wählen wir zunächst unser Betriebssystem. Im Falle von Windows wählen wir zusätzlich auf der folgenden Seite noch ``base'' (die Basisversion) aus. Es sollte dann ein Download-Link für die aktuellste Version erscheinen (3.6.3, Stand 9. April 2020). Der Installationsprozess selbst läuft wie bei anderer Software auch ab.

Neben einem \emph{Interpreter}, einem Programm, das Code (in diesem Fall also Code, der in R geschrieben wurde) für unseren Computer in ausführbare Befehle übersetzt, umfasst die Installation von R auch schon eine (sehr) rudimentäre grafische Benutzeroberfläche, die aber nur wenig komfortabel und nutzerfreundlich ist. Als nächstes installieren wir daher noch RStudio.

\hypertarget{rstudioinstallieren}{%
\section{RStudio installieren}\label{rstudioinstallieren}}

RStudio ist eine grafische Benutzeroberfläche für R, die die Arbeit mit der Programmiersprache deutlich erleichert. Auch RStudio ist für Privatanwender komplett kostenfrei nutzbar. Die aktuellste Version kann über \url{https://rstudio.com/products/rstudio/download/\#download} heruntergeladen werden.

Für den Rest des Kurses arbeiten wir immer mit RStudio (und nicht direkt mit der Oberfläche von R). Öffnen wir also zum ersten Mal RStudio.

\hypertarget{oberflaeche}{%
\section{Die Benutzeroberfläche von RStudio}\label{oberflaeche}}

\begin{figure}
\centering
\includegraphics{img/1/rstudio.png}
\caption{Die Benutzeroberfläche von RStudio}
\end{figure}

Nach dem Starten von RStudio sollte sich das Programm Ihnen wie oben präsentieren - mit einer Dreiteilung in drei abgetrennte Bereiche. Wir beginnen mit dem großen, aktuell noch weitestgehend leeren Bereich auf der linken Seite, der Konsole.

\hypertarget{konsole}{%
\subsection{Konsole}\label{konsole}}

Die Konsole ist zugleich das Eingabe- und das Ausgabefenster von R bzw. RStudio. Befehle, die wir hier eingeben, werden durch Druck auf die \texttt{Eingabe}/\texttt{Enter}-Taste direkt ausgeführt. Die Konsole signalisiert uns, dass sie bereit ist, einen Befehl zu empfangen, durch ein vorangestelltes \texttt{\textgreater{}}. Wir können dies mit simplen Berechnungen ausprobieren:

(Zur Darstellung in diesem Kurs: die erste hellgraue Box umfasst hier und im Folgenden jeweils die Befehle, die wir eingeben - in diesem Fall also den Befehl \texttt{1\ +\ 2}. Die zweite hellgraue Box enthält dann immer die Ausgabe in der Konsole, gekennzeichnet durch zwei vorangestellte Rautensymbole \texttt{\#\#}.)

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Die Konsole spuckt also direkt das Ergebnis aus -- in diesem Fall \texttt{3} -- und wartet auf den nächsten Befehl, wieder zu erkennen am \texttt{\textgreater{}}. Die \texttt{{[}1{]}} links neben dem Ergebnis gibt an, dass es sich hierbei um den ersten (und einzigen) Ausgabewert handelt. Wir werden aber noch zahlreiche Befehle kennenlernen, bei denen mehr als nur ein Wert ausgegeben wird.

Mit den Cursortasten \texttt{↑} und \texttt{↓} können wir in der Konsole durch bisher eingegebene Befehle schalten. Ein Druck auf \texttt{↑} sollte also den ersten und bisher einzigen Befehl - \texttt{1\ +\ 2} - anzeigen.

Ist ein Befehl noch nicht vollständig, signalisiert uns dies die Konsole durch ein vorangestelltes \texttt{+}. Wir können dies ausprobieren, in dem wir beispielsweise eine unvollständigen Additionsbefehl eingeben: \texttt{3\ +}. Die Konsole wartet nun auf den restlichen Befehl - in diesem Fall können wir eine weitere Zahl eingeben und den Befehl abschließen. Alternativ können wir den unvollständigen Befehl durch Druck der \texttt{ESC}-Taste abbrechen.

In der Praxis passiert dies vor allem, wenn in einem längeren Befehl eine Klammer \texttt{)} oder Anführungszeichen \texttt{"} fehlt. Sollte die Konsole also einmal die Arbeit verweigern, liegt das oft daran, dass noch ein unvollständiger Befehl vorhanden ist.

Prinzipiell könnten wir alle Arbeitsschritte über die Konsole ausführen. Das ist in der Praxis aber wenig sinnvoll, da wir im Normalfall längere und mehrere Befehle hintereinander ausführen und diese auch festhalten möchten. Wir arbeiten daher mit Skript-Dateien.

\hypertarget{r-skripte}{%
\subsection{R-Skripte}\label{r-skripte}}

Um eine neue Skriptdatei zu erstellen, klicken wir entweder links oben auf das Symbol mit der leeren Seite und dem grünen Plus und anschließend auf R-Script, auf \emph{File - New File - R-Script} oder drücken die Tastenkombination \texttt{Strg/Cmd\ +\ Shift\ +\ N}. Es sollte sich im links-oberen Bildschirmviertel eine leere Skriptdatei öffnen und unser RStudio-Fenster somit in ein viergeteiltes Layout übergehen:

\includegraphics{img/1/rstudio_script.png}
Hier können wir nun alle Befehle der Reihen der Reihe nach schreiben und gesammelt abspeichern. Einzelne Befehlszeilen lassen sich über die Tastenkombination \texttt{Strg/Cmd\ +\ Eingabe/Enter} ausführen. Das Ergebnis des Befehls erscheint dann in der Konsole. Wir können auch mehrere Zeilen auf einmal markieren und gemeinsam über dieselbe Tastenkombination ausführen. Schreiben wir z. B. mehrere Rechenoperationen hintereinander, so erscheinen deren Ergebnisse in der Ausführungsreihenfolge in der Konsole:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{3}
\DecValTok{12} \OperatorTok{*}\StringTok{ }\DecValTok{25}
\DecValTok{17} \OperatorTok{/}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 300
## [1] 4.25
\end{verbatim}

Längere Skriptdateien werden schnell unübersichtlich. Wir können aber an jeder Stelle Kommentare einfügen, indem wir eine Raute \texttt{\#} voran stellen - alles was in dieser Zeile \emph{hinter} dem Symbol steht, wird von R beim Ausführen ignoriert, wir können also sowohl ganze Zeilen \emph{auskommentieren} als auch hinter R-Befehlen eine kurze Erklärung hinzufügen. Außerdem können jederzeit Leerzeilen eingefügt werden, um das Skript etwas aufzulockern:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Zunächst ein wenig Addition}
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{5}
\DecValTok{6} \OperatorTok{+}\StringTok{ }\DecValTok{12}

\CommentTok{# Dann ein wenig Multiplikation}
\DecValTok{21} \OperatorTok{*}\StringTok{ }\DecValTok{35}
\DecValTok{2345} \OperatorTok{*}\StringTok{ }\FloatTok{1.6}

\CommentTok{# Und zum Schluss etwas komplexere Rechenoperationen}
\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{) }\OperatorTok{^}\StringTok{ }\DecValTok{3} \CommentTok{# Das ^ steht für Exponentiation, hier also 5 hoch 3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
## [1] 18
## [1] 735
## [1] 3752
## [1] 125
\end{verbatim}

Skriptdateien können und sollten natürlich abgespeichert werden - entweder über \emph{File - Save} oder die Tastenkombination \texttt{Strg/Cmd\ +\ S}. R-Skriptdateien erhalten die Dateiendung \texttt{.R}.

\hypertarget{environment}{%
\subsection{Environment}\label{environment}}

Im rechten oberen Bildschrimbereich öffnet sich standardmäßig das \emph{Environment} an, in dem RStudio alle derzeit angelegten und somit verfügbaren Objekte anzeigt. Mit Objekten werden in uns im nächsten Kapitel genauer auseinandersetzen.

Weitere Registerkarten in diesem Bereich sind die \emph{History} (eine Auflistung sämtlicher ausgeführter Zeilen der aktuellen Sitzung) sowie \emph{Connections} und \emph{Build}, die für uns aber vorerst keine Rolle spielen werden.

\hypertarget{files}{%
\subsection{Files}\label{files}}

Der rechte untere Bildschirmbereich zeigt standardmäßig einen Dateibrowser (\emph{Files}) an, der das aktuelle Arbeitsverzeichnis zeigt. Auch damit setzen wir uns in den kommenden Kapiteln ausführlicher auseinander.

Weitere Registerkarten in diesem Bereich sind:

\begin{itemize}
\tightlist
\item
  \emph{Plots}: hier werden Grafiken angezeigt, wenn wir diese in R erstellen.
\item
  \emph{Packages}: Eine Übersicht aller installieren Packages (kurz gesagt Sammlungen von R-Funktionen, die nicht in der Basisversion enthalten sind). Auch mit Packages beschäftigen wir uns in einem eigenen Kapitel.
\item
  \emph{Help}: Hier wird die Dokumentation einzelner Funktionen angezeigt, sobald wir diese anfordern. Diesen Bereich sehen wir uns an, sobald wir uns mit Funktionen beschäftigen.
\item
  \emph{Viewer}: Hier kann RStudio Webinhalte anzeigen, die mit R-Funktionen erstellt wurden. Dies wird vorab keine Rolle für uns spielen.
\end{itemize}

\hypertarget{anpassen}{%
\section{RStudio anpassen}\label{anpassen}}

Unter \emph{Profile - Global Options} können wir RStudio nach unseren Wünschen anpassen. Die einzelnen Einstellungsmöglichkeiten sollen hier nicht ausführlich diskutiert werden; hier jedoch einige sinnvolle Einstellungen:

\begin{figure}
\centering
\includegraphics{img/1/optionen1.png}
\caption{Global Options in RStudio}
\end{figure}

Im Bereich \emph{General} ist es sinnvoll, zwei Anpassungen vorzunehmen. Zum einen können wir unter \emph{R Sessions} ein \emph{Default working directory} (also ein standardmäßiges Arbeitsverzeichnis) einstellen. Dieses Verzeichnis öffnet R dann beim Start automatisch. Hier bietet es sich an, einen eigenen Ordner anzulegen.

Unter \emph{Workspace} entfernen Sie bitte, falls vorhanden, das Häkchen bei \emph{Restore .RData into workspace at startup} und stellen \emph{Save workspace to .RData on exit} auf \emph{Never}. Zwar mag es praktisch erscheinen, dass RStudio automatisch die zuletzt bearbeitete \emph{Session} wiederherstellt, das führt in der Praxis aber gerne zu Konflikten und Problemen -- und letztlich ist es längerfristig auch sinnvoller, sich einen Arbeitsprozess anzueignen, bei dem Skripte schnell den jeweiligen Arbeitsstand wiederherstellen.

\begin{figure}
\centering
\includegraphics{img/1/optionen2.png}
\caption{Anzeigeeinstellungen in RStudio}
\end{figure}

Eher Geschmackssache sind die Anzeigeeinstellungen, die Sie unter \emph{Appearance} vornehmen können. Hier können Sie die Schriftart und -größe im Skripteditor einstellen sowie unter verschiedenen \emph{Themes} (Farbschemata) wählen (darunter auch ``dunkle'' Themes, also solche, die hellen Text auf dunklem Hintergrund bieten). Am besten, Sie probieren hier unterschiedliche Einstellungen aus, bis Sie ein subjektiv angenehmes Anzeigebild von RStudio gefunden haben.

\hypertarget{uxfcbungsaufgaben}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben}}

Diese Aufgaben sollen Sie lediglich mit den grundlegendsten Funktionen von RStudio vertraut machen. Sie müssen daher keine Dateien abgeben.

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-26}{}{\label{exr:unnamed-chunk-26} }Installieren Sie R (siehe \ref{rinstallieren}) und RStudio (\ref{rstudioinstallieren}) und nehmen Sie die Einstellungen unter \ref{anpassen} vor.
\EndKnitrBlock{exercise}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-27}{}{\label{exr:unnamed-chunk-27} }Öffnen Sie RStudio und führen Sie ein paar simple Berechnungen in der Konsole durch.
\EndKnitrBlock{exercise}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-28}{}{\label{exr:unnamed-chunk-28} }Erstellen Sie eine neue Skriptdatei und fügen dort mindestens sechs Berechnungen hinzu. Gliedern Sie die Skriptdatei durch einige Kommentare.
\EndKnitrBlock{exercise}

\hypertarget{objekte-und-datenstrukturen}{%
\chapter{Objekte und Datenstrukturen}\label{objekte-und-datenstrukturen}}

Wir können R bzw. RStudio nun als Taschenrechner verwenden und uns arithmetische Operationen direkt in der Konsole ausgeben lassen:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \CommentTok{# Addition}
\DecValTok{1} \OperatorTok{-}\StringTok{ }\DecValTok{2} \CommentTok{# Subtraktion}
\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{2} \CommentTok{# Multiplikation}
\DecValTok{4} \OperatorTok{/}\StringTok{ }\DecValTok{2} \CommentTok{# Division}
\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{5} \CommentTok{# Exponentiation}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
## [1] -1
## [1] 4
## [1] 2
## [1] 32
\end{verbatim}

Wirklich sinnvoll ist dies aber nicht: wir wollen Ergebnisse ja auch speichern und weiterverwenden können. Hierfür benötigen wir Variablen, also Namen, denen wir (veränderliche) Werte zuordnen können.

In R lassen sich Variablen erstellen, indem wir einer Zeichenkette (zu den Benennungsregeln kommen wir gleich) einen Wert mittels \texttt{\textless{}-} zuordnen (hierfür entweder die Zeichen \texttt{\textless{}} und \texttt{-} eingeben oder die Tastenkombination \texttt{Alt/Option\ +\ -} drücken).\footnote{Es ist prinzipiell auch möglich, die Zuordnung mittels einem \texttt{=} vorzunehmen. Da das \texttt{=} aber auch in anderen Kontexten benötigt wird, erzeugt dies Verwirrung, sodass wir Objekte immer mit \texttt{\textless{}-} zuordnen sollten.} Dies erstellt ein \emph{Objekt}\footnote{Die Begriffe Variable und Objekt können für unsere Zwecke weitestgehend synonym verwendet werden. Wir werden aber gleich noch sehen, das so ziemlich alles in R ein Objekt sein kann.} mit eben diesem Namen und der entsprechenden Zuordnung:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Führen wir diesen Befehl aus, erstellen wir das Objekt \texttt{x} und ordnen den Wert \texttt{2} zu. Wir sollten diese neue Zuordnung zudem im rechten oberen \emph{Environment}-Bereich sehen können.

Wir können nun mit diesem Objekt weiterrechnen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{5}
\NormalTok{x }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 7
## [1] 1
\end{verbatim}

Um den aktuellen Wert eines Objektes anzuzeigen, können wir auch einfach das Objekt ausführen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

Generell wird bei der Zuordnung immer zunächst der Teil rechts vom \texttt{\textless{}-} ausgeführt und dann zugeordnet. Wir können also auch komplexere Befehle ausführen und diese Zuordnen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{3} \OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

Objekte sind veränderlich und können jederzeit neu zugeordnet werden - und dabei auch selbst bei der Zuordnung verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\NormalTok{x}
\NormalTok{x <-}\StringTok{ }\DecValTok{3}
\NormalTok{x}
\NormalTok{x <-}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
## [1] 3
## [1] 2
\end{verbatim}

Schauen wir uns das einmal in einem etwas komplexeren Beispiel an - welchen Wert hat \texttt{b} am Ende dieser Befehlskette?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\NormalTok{a <-}\StringTok{ }\NormalTok{b }\OperatorTok{*}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\NormalTok{a}
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{-}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Die Antwort lautet \texttt{15}. Gehen wir das der Reihe nach durch:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zunächst ordnen wir \texttt{a} den Wert \texttt{10} zu.
\item
  Dann orden wir \texttt{b} den Wert \texttt{a\ /\ 2} zu. Da \texttt{a} in diesem Schritt \texttt{10} zugeordnet ist, wird \texttt{10\ /\ 2} gerechnet. \texttt{b} entspricht nun also dem Wert \texttt{5}.
\item
  Wir ordnen nun \texttt{a} den Wert \texttt{b\ *\ 2\ +\ a} zu. Der gesamte Teil rechts vom \texttt{\textless{}-} wird zuerst ausgeführt und dann zugeordnet, hier also \texttt{5\ *\ 2\ +\ 10}. \texttt{a} entspricht nun dem Wert \texttt{20}, b weiterhin dem Wert \texttt{5}.
\item
  Zuletzt ordnen wir \texttt{b} das Ergebnis von \texttt{a\ -\ b} zu, was vor dieser Zuordnung \texttt{20\ -\ 5} bedeutet. \texttt{b} entspricht schlussendlich also \texttt{15}.
\end{enumerate}

Nochmals die wichtigsten Punkte zusammengefasst:

\begin{itemize}
\tightlist
\item
  Mit \texttt{\textless{}-} erstellen wir Objekte und ordnen diesen Werte zu.
\item
  Alle Objekte sind veränderlich und können überschrieben werden.
\item
  Bei einer Zuordnung wird der gesamte Teil rechts vom Zuordnungspfeil \texttt{\textless{}-} zuerst ausgeführt und dann die Zuordnung vorgenommen.
\end{itemize}

\hypertarget{objektnamen}{%
\section{Objektnamen}\label{objektnamen}}

Für die obigen Beispiele haben wir nur einzelne Buchstaben für Objekte verwendet. In der Praxis können und sollten wir längere Objektnamen verwenden. Dabei gelten folgende Regeln:

\begin{itemize}
\tightlist
\item
  Objektnamen können Groß- und Kleinbuchstaben, Ziffern sowie Punkte \texttt{.} und Unterstriche \texttt{\_} beinhalten. Andere Sonderzeichen, Umlaute und Leerzeichen sind nicht gestattet.
\item
  Objektnamen können mit einem Buchstaben oder einem \texttt{.} beginnen, nicht jedoch mit Ziffern oder \texttt{\_}.
\item
  Objektnamen sind \emph{case-sensitive}, d.~h. unterscheiden zwischen Groß- und Kleinschreibung. \texttt{myVar} und \texttt{myvar} sind also unterschiedliche Objekte.
\end{itemize}

Es ist sinnvoll, Objekten ``sprechende'' Namen zu geben, sodass andere (und auch Sie zu einem späteren Zeitpunkt) nachvollziehen können, was sich dahinter verbirgt, auch ohne den gesamten Code zu lesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Gute Objektnamen}
\NormalTok{mittelwert <-}\StringTok{ }\FloatTok{2.5}
\NormalTok{mein_alter <-}\StringTok{ }\DecValTok{32}
\NormalTok{groesse_in_cm <-}\StringTok{ }\DecValTok{175}

\CommentTok{# Schlechte Objektnamen}
\NormalTok{x1 <-}\StringTok{ }\FloatTok{2.5}
\NormalTok{var2 <-}\StringTok{ }\DecValTok{32}
\NormalTok{asdasdasd <-}\StringTok{ }\DecValTok{175}
\end{Highlighting}
\end{Shaded}

Es gibt außerdem unterschiedliche Konventionen, um mehrere Wörter in Objektnamen aneinanderzuhängen. \texttt{mein\_alter} ist ein Beispiel für den sogenannten \emph{snake\_case}: Alle Wörter kleingeschrieben und durch einen Unterstrich \texttt{\_} miteinander verbunden. Einen Überblick über verbreitete Konventionen der Objektbenennung gibt folgende Illustration:

\begin{figure}
\centering
\includegraphics{img/horst/coding_cases.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

Was auch immer Sie wählen - wichtig ist vor allem, dass Sie einheitlich vorgehen.\footnote{Aufmerksamen Leser*innen dürfte zudem aufgefallen sein, dass \emph{kebab-case} in R nicht möglich ist.}

\hypertarget{objekttypen}{%
\section{Objekttypen}\label{objekttypen}}

Bisher haben wir lediglich Zahlen Objekten zugewiesen. Natürlich können Daten aber auch in anderen Formen vorliegen; wir sprechen daher von verschiedenen \emph{Objekttypen}.\footnote{Tatsächlich ist die Sache etwas komplexer: es gibt in R einige wenige Kernobjekttypen, die wiederum mit bestimmten Attributen versehen werden können, um daraus zusätzliche Objekttypen abzuleiten. So kann etwa eine Zahlenfolge mit einem zusätzlichen Attribut als Datumsangabe interpretiert werden. Für unsere Zwecke spielt diese Unterscheidung jedoch keine Rolle.}

\hypertarget{numerische-objekte}{%
\subsection{Numerische Objekte}\label{numerische-objekte}}

Zahlenwerte werden in R als \texttt{numeric} bezeichnet. Wir können hier zudem zwischen den Typen \texttt{integer} (ganze Zahlen) und \texttt{double} (Kommazahlen\footnote{Der Typenbezeichnung leitet sich von \href{https://de.wikipedia.org/wiki/Doppelte_Genauigkeit}{Gleitkommazahlen mit doppelter Genauigkeit} ab.}) unterscheiden.

Grundsätzlich ordnet R Zahlen als \texttt{double} zu, auch wenn nur ganze Zahlen zugeordnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{4}
\KeywordTok{typeof}\NormalTok{(x) }\CommentTok{# Mit dieser Funktion können wir den Objekttyp anfordern}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

Um explizit den Typ \texttt{integer} anzufordern, muss Zahlenwerten ein \texttt{L} nachgestellt werden:\footnote{Warum \texttt{L}? Hier gibt es unterschiedliche Erklärungsansätze, die beispielsweise \href{https://stackoverflow.com/questions/22191324/clarification-of-l-in-r/22192378\#22192378}{hier} nachgelesen werden können}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{4L}
\KeywordTok{typeof}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

In der Praxis macht es aber kaum einen Unterschied, ob eine ganze Zahl als \texttt{integer} oder \texttt{double} abgespeichert wird - \texttt{integer} verbraucht weniger Speicherplatz, aber das wird erst bei \emph{sehr} großen Datensätzen relevant. Wir können die Unterscheidung also guten Gewissens ignorieren und von numerischen Objekten sprechen.

\hypertarget{textobjekte}{%
\subsection{Textobjekte}\label{textobjekte}}

Wir können Objekten auch Text zuordnen - diese Objekte haben dann den Typ \texttt{character} (Textvariablen werden zum häufig als ``string'' bezeichnet). Um ein \texttt{character}-Objekt zu erstellen, müssen wir die Zeichenkette in einfache \texttt{\textquotesingle{}\textquotesingle{}} oder doppelte \texttt{""} Anführungszeichen setzen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text1 <-}\StringTok{ "Guten Morgen!"}
\NormalTok{text2 <-}\StringTok{ 'Einfache Anführungszeichen sind sinnvoll, wenn im "Text" ebenfalls Anführungszeichen vorkommen'}
\end{Highlighting}
\end{Shaded}

Natürlich können auch Zahlen als Text gespeichert werden - werden dann aber natürlich auch als Text behandelt, sodass man nicht mehr mit ihnen rechnen kann.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahl_als_text <-}\StringTok{ "123"}
\end{Highlighting}
\end{Shaded}

\hypertarget{logicals-logische-objekte}{%
\subsection{Logicals (logische Objekte)}\label{logicals-logische-objekte}}

Der dritte Kernobjekttyp heißt \texttt{logical} und kann nur zwei Werte annehmen: \texttt{TRUE} (wahr) oder \texttt{FALSE} (falsch). Logicals entstehen durch logische Vergleiche zweier Objekte, wobei u.a. folgende Operatoren verwendet werden können:

\begin{longtable}[]{@{}lll@{}}
\caption{\label{tab:logischeoperatoren} Logische Operatoren in R}\tabularnewline
\toprule
Operator & Vergleich & Beispiele\tabularnewline
\midrule
\endfirsthead
\toprule
Operator & Vergleich & Beispiele\tabularnewline
\midrule
\endhead
\texttt{==} & ist gleich & \texttt{1\ ==\ 1} (ergibt \texttt{TRUE})\texttt{"a"\ ==\ "b"} (ergibt \texttt{FALSE})\tabularnewline
\texttt{!=} & ist nicht gleich & \texttt{1\ !=\ 1} (ergibt \texttt{FALSE})\texttt{"a"\ !=\ "b"} (ergibt \texttt{TRUE})\tabularnewline
\texttt{\textless{}} & ist kleiner als & \texttt{1\ \textless{}\ 2} (ergibt \texttt{TRUE})\texttt{2\ \textless{}\ 2} (ergibt \texttt{FALSE})\tabularnewline
\texttt{\textgreater{}} & ist größer als & \texttt{2\ \textgreater{}\ 1} (ergibt \texttt{TRUE})\texttt{2\ \textgreater{}\ 2} (ergibt \texttt{FALSE})\tabularnewline
\texttt{\textless{}=} & ist kleiner gleich & \texttt{1\ \textless{}=\ 2} (ergibt \texttt{TRUE})\texttt{2\ \textless{}=\ 2} (ergibt \texttt{TRUE})\tabularnewline
\texttt{\textgreater{}=} & ist größer gleich & \texttt{2\ \textgreater{}=\ 1} (ergibt \texttt{TRUE})\texttt{2\ \textgreater{}=\ 2} (ergibt \texttt{TRUE})\tabularnewline
\bottomrule
\end{longtable}

Die Zuordnung erfolgt wie bei anderen Objekten auch:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ "a"} \OperatorTok{==}\StringTok{ "b"}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Logicals werden vor allem bei Wenn-Dann-Bedingungen benötigt, mit denen wir uns im übernächsten Kapitel auseinandersetzen werden.

\hypertarget{weitere-objekttypen}{%
\subsection{Weitere Objekttypen}\label{weitere-objekttypen}}

Diese drei Objekttypen (\texttt{numeric}, \texttt{character}, \texttt{logical}) bilden die Basis fast aller Objekte in R. Durch zusätzliche Attribute können jedoch noch zusätzliche Objekttypen erzeugen, die dne Umgang mit bestimmten Daten erleichtern. Für kategoriale Variablen kennt R beispielsweise den Typ \texttt{factor}, für Datumsangaben den Typ \texttt{date}. Diese werden bei der Zuordnung nicht automatisch erkannt und müssen stattdessen durch bestimmte Funktionen erzeugt werden.

Erzeugen wir beispielsweise ein Objekt mit einer Zeichenfolge, die ein Datum repräsentiert (z. B. \texttt{date1\ \textless{}-\ "2020-05-05"}, im Format \emph{YYYY\_MM\_DD}, also Jahr-Monat-Tag), speichert R dies zunächst als \texttt{character} ab. Wir können aber R explizit sagen, dass er dies als Datum behandeln soll:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date2 <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2020-05-05"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Dies hat nun u.a. den Vorteil, dass wir im Gegensatz zu \texttt{character}-Objekten auch arithmetische Operationen durchführen können, also beispielsweise zwei Datums-Objekte voneinander subtrahieren, um die zeitliche Differenz zu berechnen.

Wir werden uns im späteren Verlauf noch ausführlicher mit diesen spezielleren Objekttypen beschäftigen -- bis jetzt nehmen Sie vor allem mit, dass sowohl kategoriale Variablen als auch Datumsangaben kein Problem für R darstellen.

\hypertarget{coercion}{%
\subsection{Objekttypen ändern}\label{coercion}}

Bisweilen wird es relevant sein, Objekttypen zu ändern - etwa weil Zahlen fälschlicherweise als Text eingelesen wurden. Hierfür bietet R Funktionen an, die allesamt nach dem Schema \texttt{as.{[}Objekttyp{]}()} aufgebaut sind: mit \texttt{as.numeric()} wandeln wir Objekte in numerische Objekte um (genauer gesagt in \texttt{double}), mit \texttt{as.character()} in Textobjekte und, wie im vorigen Abschnitt gesehen, mit \texttt{as.Date()} in ein Datumsobjekt. Der Fachbegriff hierfür lautet \emph{Coercion}, wir \emph{zwingen} R also dazu, ein Objekt als einen bestimmten Typ zu behandeln, auch wenn R automatisch einen anderen Typus bestimmt hätte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ "25"}
\NormalTok{x1}
\KeywordTok{typeof}\NormalTok{(x1)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"25"}\NormalTok{)}
\NormalTok{x2 }\CommentTok{# Beachten Sie, dass in der Ausgabe nun die Anführungszeichen fehlen}
\KeywordTok{typeof}\NormalTok{(x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "25"
## [1] "character"
## [1] 25
## [1] "double"
\end{verbatim}

Natürlich klappt das nur, solange die Umwandlung auch sinnvoll durchführbar ist -- in allen anderen Fällen wird eine Warnung ausgegeben und fehlende Werte erzeugt (siehe Kapitel \ref{missingvals}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"Dieser Text kann nicht sinnvoll als Zahl interpretiert werden"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\hypertarget{datenstrukturen}{%
\section{Datenstrukturen}\label{datenstrukturen}}

Bisher haben wir einem Objekt immer nur einen einzigen Wert zugeordnet. Der Fachbegriff hierfür lautet \emph{Skalar} und beschreibt somit die einfachst mögliche Datenstruktur, eben dass einem Objekt nur ein einziger Wert zugeordnet wurde. Objekte können in R jedoch auch mehrere Werte enthalten und somit komplexere Datenstrukturen erzeugen.

Im Folgen betrachten wir daher die vier wichtigsten komplexeren Datenstrukturen in R. Diese unterscheiden sich zum einen in ihrer Dimensionalität (also ob sie ein- oder zweidimensional sind) und zum anderen, ob sie homogene (also nur dieselben) oder heterogene (also unterschiedliche) Objekttypen beinhalten können:

\begin{longtable}[]{@{}lll@{}}
\caption{\label{tab:datenstrukturen} Datenstrukturen in R}\tabularnewline
\toprule
Datenstruktur & Dimensionalität & Objekttypen\tabularnewline
\midrule
\endfirsthead
\toprule
Datenstruktur & Dimensionalität & Objekttypen\tabularnewline
\midrule
\endhead
Vektor & eindimensional & homogen\tabularnewline
Liste & eindimensional & heterogen\tabularnewline
Matrix & zweidimensional & homogen\tabularnewline
Dataframe & zweidimensional & heterogen\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{vektoren}{%
\subsection{Vektoren}\label{vektoren}}

Vektoren sind Objekte, die mehrere Werte desselben Typs beinhalten. Wir erzeugen Vektoren über die Funktion \texttt{c()} (von \emph{concatenate}, also verketten). Die einzelnen Elemente des Vektors werden durch Kommas \texttt{,} getrennt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gerade_zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\NormalTok{gerade_zahlen}
\NormalTok{ungerade_zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{ungerade_zahlen}
\NormalTok{simpsons <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Homer Simpson"}\NormalTok{, }\StringTok{"Marge Simpson"}\NormalTok{, }\StringTok{"Bart Simpson"}\NormalTok{, }\StringTok{"Lisa Simpson"}\NormalTok{, }\StringTok{"Maggie Simpson"}\NormalTok{)}
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8
## [1] 1 3 5 7 9
## [1] "Homer Simpson"  "Marge Simpson"  "Bart Simpson"   "Lisa Simpson"   "Maggie Simpson"
\end{verbatim}

Wir können auch Vektoren über \texttt{c()} mit einander verketten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(gerade_zahlen, ungerade_zahlen)}
\NormalTok{zahlen}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8 1 3 5 7 9
\end{verbatim}

Beachten Sie, dass die Verkettung immer in der angegebenen Reihenfolge erfolgt -- R sortiert die Elemente also nicht automatisch.

\hypertarget{vektorelemente-auswuxe4hlen}{%
\subsubsection{Vektorelemente auswählen}\label{vektorelemente-auswuxe4hlen}}

Um bestimmte Elemente eines Vektors auszuwählen, können wir die gewünschten Elemente in eckigen Klammern \texttt{{[}{]}} hinter einem Vektor definieren. Hier geben wir nur das zweite Element des oben erzeugten \texttt{zahlen}-Vektors aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Um mehrere Elemente eines Vektors auszugeben, benötigen wir wiederum einen Vektor mit den gewünschten Positionen -- hier geben wir uns beispielsweise das erste, dritte und fünfte Element aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 6 1
\end{verbatim}

\hypertarget{vektorelemente-benennen}{%
\subsubsection{Vektorelemente benennen}\label{vektorelemente-benennen}}

Elemente in Vektoren können benannt werden, indem beim Erstellen die Namen der Elemente mit einem \texttt{=} angegeben werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{nachname =} \StringTok{"Simpson"}\NormalTok{, }\DataTypeTok{vorname =} \StringTok{"Homer"}\NormalTok{, }\DataTypeTok{wohnort =} \StringTok{"Springfield"}\NormalTok{)}
\NormalTok{homer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      nachname       vorname       wohnort 
##     "Simpson"       "Homer" "Springfield"
\end{verbatim}

Benannte Elemente können dann auch über den Namen ausgewählt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer[}\StringTok{"wohnort"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       wohnort 
## "Springfield"
\end{verbatim}

Auch dies funktioniert mit mehreren Elementen gleichzeitig:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer[}\KeywordTok{c}\NormalTok{(}\StringTok{"vorname"}\NormalTok{, }\StringTok{"nachname"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   vorname  nachname 
##   "Homer" "Simpson"
\end{verbatim}

Alternativ können Elementnamen im Nachhinein über die Funktion \texttt{names()} hinzugefügt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{marge <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Simpson"}\NormalTok{, }\StringTok{"Marge"}\NormalTok{, }\StringTok{"Springfield"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(marge) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"nachname"}\NormalTok{, }\StringTok{"vorname"}\NormalTok{, }\StringTok{"wohnort"}\NormalTok{)}
\NormalTok{marge}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      nachname       vorname       wohnort 
##     "Simpson"       "Marge" "Springfield"
\end{verbatim}

\hypertarget{mit-vektoren-rechnen}{%
\subsubsection{Mit Vektoren rechnen}\label{mit-vektoren-rechnen}}

Mit numerischen Vektoren können arithmetische Berechnungen durchgeführt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{zahlen }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3  5  7  9  2  4  6  8 10
## [1]  4  8 12 16  2  6 10 14 18
\end{verbatim}

Berechnungen werden dabei der Reihe nach für jedes einzelne Vektorelement durchgeführt. Es ist auch möglich, Vektoren gleicher Länge zu addieren, subtrahieren etc. -- im Falle einer Addition wird dann das erste Element des ersten Vektors zum ersten Element des zweiten Vektors addiert, dann das zweite Element des ersten Vektors zum zweiten Element des zweiten Vektors usw.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{x1 }\OperatorTok{*}\StringTok{ }\NormalTok{x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2  9 20
\end{verbatim}

\hypertarget{nuxfctzliche-vektorfunktionen}{%
\subsubsection{Nützliche Vektorfunktionen}\label{nuxfctzliche-vektorfunktionen}}

Abschließend einige nützliche Funktionen für den Umgang mit Vektoren:

\begin{itemize}
\tightlist
\item
  \texttt{length()} gibt die Anzahl der Elemente eines Vektors aus.
\item
  Die unter @ref(\#coercion) eingeführten \emph{Coercion}-Funktionen (\texttt{as.numeric()}, \texttt{as.character()} usw.) können auch auf Vektoren angewendet werden und wandeln so jedes Vektorelement um.\#
\item
  für numerische Vektoren stehen zahlreiche statistische Funktionen bereit, z. B. zur Berechnung der Summe (\texttt{sum()}), des arithmetischen Mittels (\texttt{mean()}) und der Standardabweichung (\texttt{sd()})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{999}\NormalTok{)}
\KeywordTok{length}\NormalTok{(x)}
\KeywordTok{sum}\NormalTok{(x)}
\KeywordTok{mean}\NormalTok{(x)}
\KeywordTok{sd}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 1065
## [1] 266.25
## [1] 488.5846
\end{verbatim}

Oftmals benötigen wir aufsteigende Zahlenfolgen für Vektoren, beispielsweise für laufende Nummern. Dies lässt sich die Funktion \texttt{:} abkürzen, die einen Vektor \texttt{Startwert:Endwert} erstellt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eins_bis_zehn <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{eins_bis_zehn}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\hypertarget{listen}{%
\subsection{Listen}\label{listen}}

Listen ähneln zunächst Vektoren und werden mit der Funktion \texttt{list()} erzeugt. Auch die Benennung von Listenelementen erfolgt analog zu Vektoren entweder beim Erstellen der Liste mit \texttt{=} oder im Nachhinein mit \texttt{names()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{name =} \StringTok{"München", bundesland = "}\NormalTok{Bayern}\StringTok{", bezirk = "}\NormalTok{Oberbayern}\StringTok{")}
\StringTok{munich_facts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $name
## [1] "München"
## 
## $bundesland
## [1] "Bayern"
## 
## $bezirk
## [1] "Oberbayern"
\end{verbatim}

Wir sehen aber bereits am Konsolenoutput, dass die Darstellung von Vektoren abweicht: anstatt alle Elemente nebeneinander angezeigt zu bekommen, werden die einzelnen Elemente untereinander angezeigt.

Das rührt daher, dass Listen deutlich mächtiger und flexibler sind als Vektoren. Nicht nur können wir in den einzelnen Elementen Objekttypen mischen, wir sind auch nicht auf einzelne Werte (Skalare) als Elemente beschränkt. Tatsächlich kann so gut wie jedes Objekt ein Listenelement sein -- also auch Vektoren, ganze Datensätze und sogar Listen (die wiederum eigene Listen enthalten können -- wir können hier also Daten prinzipiell endlos verschachteln). Erweitern wir dazu die Liste von oben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{namen =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{hochdeutsch =} \StringTok{"München", englisch = "}\NormalTok{Munich}\StringTok{", bairisch = "}\NormalTok{Minga}\StringTok{"),}
\StringTok{  bundesland = "}\NormalTok{Bayern}\StringTok{",}
\StringTok{  gruendungsjahr = 1158,}
\StringTok{  daten = list(}
\StringTok{    einwohner = 1471508,}
\StringTok{    geographie = c(flaeche_in_km2 = 310.7, hoehe_NHN_in_m = 519)}
\StringTok{  )}
\StringTok{)}
\StringTok{munich_facts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $namen
## hochdeutsch    englisch    bairisch 
##   "München"    "Munich"     "Minga" 
## 
## $bundesland
## [1] "Bayern"
## 
## $gruendungsjahr
## [1] 1158
## 
## $daten
## $daten$einwohner
## [1] 1471508
## 
## $daten$geographie
## flaeche_in_km2 hoehe_NHN_in_m 
##          310.7          519.0
\end{verbatim}

Mit ihrer Flexibilität stellen Listen in R die Basis für nahezu alle komplexeren Datenstrukturen -- auch bei Datensätze, Regressionsmodellen etc. handelt es sich um Listen, die mit bestimmten Attributen versehen wurden.

\hypertarget{listenelemente-auswuxe4hlen}{%
\subsubsection{Listenelemente auswählen}\label{listenelemente-auswuxe4hlen}}

Auch die Auswahl von Listenelementen funktioniert ähnlich wie bei Vektoren über die numerische Position oder den Elementnamen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $namen
## hochdeutsch    englisch    bairisch 
##   "München"    "Munich"     "Minga"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts[}\StringTok{"daten"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $daten
## $daten$einwohner
## [1] 1471508
## 
## $daten$geographie
## flaeche_in_km2 hoehe_NHN_in_m 
##          310.7          519.0
\end{verbatim}

Vielleicht ist Ihnen bereits das Dollarsymbol \texttt{\$} vor den Elementnamen aufgefallen -- dieses verweist auf eine Funktion, mit der Listenelemente noch komfortabler ausgewählt werden können:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts}\OperatorTok{$}\NormalTok{bundesland}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Bayern"
\end{verbatim}

Nicht nur sparen Sie sich ein paar Zeichen bei der Eingabe, RStudio macht Ihnen auch automatisch Vorschläge, sobald Sie das Dollarzeichen eingetippt haben (im Beispiel also ab \texttt{munich\_facts\$}), welche Elemente sie auswählen können. Auch tiefer verschachtelte Elemente können so ausgewählt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts}\OperatorTok{$}\NormalTok{daten}\OperatorTok{$}\NormalTok{einwohner}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1471508
\end{verbatim}

\hypertarget{nuxfctzliche-listenfunktionen}{%
\subsubsection{Nützliche Listenfunktionen}\label{nuxfctzliche-listenfunktionen}}

Auch für Listen stehen einige nützliche Funktionen zur Verfügung, die die Arbeit mit ihnen erleichtern.

\texttt{length} gibt wie auch schon bei Vektoren die Anzahl der Elemente aus (wobei auch komplexere Elemente, also z. B. Vektoren, Listen etc., jeweils als ein Element gezählt werden):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(munich_facts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Spezifisch für Listen relevant ist die Funktion \texttt{str()}, die zusätzliche Informationen über die Struktur der Liste ausgibt, was gerade bei verschachtelteren Listen den Überblick erleichtert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(munich_facts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 4
##  $ namen         : Named chr [1:3] "München" "Munich" "Minga"
##   ..- attr(*, "names")= chr [1:3] "hochdeutsch" "englisch" "bairisch"
##  $ bundesland    : chr "Bayern"
##  $ gruendungsjahr: num 1158
##  $ daten         :List of 2
##   ..$ einwohner : num 1471508
##   ..$ geographie: Named num [1:2] 311 519
##   .. ..- attr(*, "names")= chr [1:2] "flaeche_in_km2" "hoehe_NHN_in_m"
\end{verbatim}

Wir sehen, dass die Liste \texttt{munich\_facts} aus 4 Elementen besteht \texttt{List\ of\ 4}. Das erste Element trägt den Namen \texttt{namen} ist ein benannter \texttt{character}-Vektor (abgekürzt durch \texttt{chr}) mit 3 Elementen (Angabe \texttt{{[}1:3{]}}) usw.

Durch die komplexe Struktur sind Listen jedoch nicht so einfach zu handhaben. Mittels der Funktion \texttt{unlist()} können Listen daher in Vektoren (inkl. Elementnamen, soweit vorhanden) umgewandelt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts_vector <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(munich_facts)}
\NormalTok{munich_facts_vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##               namen.hochdeutsch                  namen.englisch                  namen.bairisch 
##                       "München"                        "Munich"                         "Minga" 
##                      bundesland                  gruendungsjahr                 daten.einwohner 
##                        "Bayern"                          "1158"                       "1471508" 
## daten.geographie.flaeche_in_km2 daten.geographie.hoehe_NHN_in_m 
##                         "310.7"                           "519"
\end{verbatim}

\hypertarget{matrizen}{%
\subsection{Matrizen}\label{matrizen}}

Matrizen sind Vektoren, die in eine zweidimensionale Struktur, also Zeilen und Spalten, überführt werden und können mit der Funktion \texttt{matrix()} erstellt werden. Hierzu ist zusätzlich noch die Anzahl an Zeilen, in die der Vektor aufgeteilt werden soll, nötig:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10} \CommentTok{# Zahlen von 1 bis 10 als Vektor}
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(x, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{) }\CommentTok{# Vektor in Matrix mit zwei Zeilen aufteilen}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
\end{verbatim}

Alternativ können wir mehrere Vektoren mit den Funktionen \texttt{cbind()} spaltenweise (von \emph{c}olumn) und \texttt{rbind()} zeilenweise (von \emph{r}ow) zu einer Matrix ``zusammenkleben''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{x2 <-}\StringTok{ }\DecValTok{5}\OperatorTok{:}\DecValTok{8}
\NormalTok{x3 <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{3}
\NormalTok{m <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(x1, x2, x3)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      x1 x2 x3
## [1,]  1  5  0
## [2,]  2  6  1
## [3,]  3  7  2
## [4,]  4  8  3
\end{verbatim}

\hypertarget{matrizen-benennen}{%
\subsubsection{Matrizen benennen}\label{matrizen-benennen}}

Auch Matrizen können benannt werden. Da wir nun aber eine zweidimensionale Struktur haben, können wir entsprechend auch Zeilen und Spalten einzeln benennen. Hierfür gibt es die Funktionen \texttt{rownames()} und \texttt{colnames()}, die analog zu \texttt{names()} verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"spalte_1"}\NormalTok{, }\StringTok{"spalte_2"}\NormalTok{, }\StringTok{"spalte_3"}\NormalTok{)}
\KeywordTok{rownames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"zeile_a"}\NormalTok{, }\StringTok{"zeile_b"}\NormalTok{, }\StringTok{"zeile_c"}\NormalTok{, }\StringTok{"zeile_d"}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         spalte_1 spalte_2 spalte_3
## zeile_a        1        5        0
## zeile_b        2        6        1
## zeile_c        3        7        2
## zeile_d        4        8        3
\end{verbatim}

\hypertarget{nuxfctzliche-matrixfunktionen}{%
\subsubsection{Nützliche Matrixfunktionen}\label{nuxfctzliche-matrixfunktionen}}

\texttt{length()} funktioniert auch für Matrizen und gibt die Anzahl aller Elemente an. Interessieren wir uns dagegen für die Anzahl an Zeilen und Spalten, gibt die Funktion \texttt{dim()} Aufschluss, die einen Vektor mit der Anzahl der Zeilen und der Anzahl der Spalten ausgibt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(m)}
\KeywordTok{dim}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
## [1] 4 3
\end{verbatim}

Die Funktion \texttt{t()} transponiert die Matrix, dreht die Matrix also um 90 Grad und vertauscht somit Zeilen und Spalten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{t}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          zeile_a zeile_b zeile_c zeile_d
## spalte_1       1       2       3       4
## spalte_2       5       6       7       8
## spalte_3       0       1       2       3
\end{verbatim}

\hypertarget{dataframes}{%
\subsection{Dataframes}\label{dataframes}}

Mit Matrizen kommen wir der Datensatzstruktur, wie wir sie von SPSS oder Excel kennen, schon recht nahe. Allerdings repräsentieren Matrizen Vektoren und sind daher auf einen Objekttyp beschränkt. Diese Einschränkung hebt die Datenstruktur \emph{Dataframe} auf, mit der gleich lange Vektoren unterschiedlichen Typs kombiniert werden können. Wir erstellen Dataframes mit der gleichnamigen Funktion \texttt{data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beatles_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{name =} \KeywordTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Paul"}\NormalTok{, }\StringTok{"George"}\NormalTok{, }\StringTok{"Ringo"}\NormalTok{),}
  \DataTypeTok{surname =} \KeywordTok{c}\NormalTok{(}\StringTok{"Lennon"}\NormalTok{, }\StringTok{"McCartney"}\NormalTok{, }\StringTok{"Harrison"}\NormalTok{, }\StringTok{"Starr"}\NormalTok{),}
  \DataTypeTok{born =} \KeywordTok{c}\NormalTok{(}\DecValTok{1940}\NormalTok{, }\DecValTok{1942}\NormalTok{, }\DecValTok{1943}\NormalTok{, }\DecValTok{1940}\NormalTok{)}
\NormalTok{)}
\NormalTok{beatles_data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name   surname born
## 1   John    Lennon 1940
## 2   Paul McCartney 1942
## 3 George  Harrison 1943
## 4  Ringo     Starr 1940
\end{verbatim}

Wenn wir mit tabellarischen Daten arbeiten, geschieht das also in der Regel mit Dataframes. Natürlich wäre es nicht zielführend, wenn wir diese immer von Hand erstellen müssten. Es gibt daher Funktionen, mit denen wir externe Dateien (z. B. CSV-, Excel- und sogar SPSS-Dateien) als Dataframes in R laden können. Wie wir externe Dateien laden, schauen wir uns zu einem späteren Zeitpunkt genauer an.

\hypertarget{missingvals}{%
\section{Fehlende Werte}\label{missingvals}}

Fehlende Werte können in R als \texttt{NA} oder als \texttt{NULL} gekennzeichnet werden. Der Unterschied zwischen beiden liegt darin, wie R den fehlenden Wert behandelt: \texttt{NA} bedeutet, dass R hier einen Wert erwarten würde, dieser ab fehlt. \texttt{NULL} hingegen bedeutet für R schlicht, dass der Wert nicht vorhanden ist und daher ignoriert werden sollte.

\hypertarget{uxfcbungsaufgaben-1}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-1}}

\hypertarget{funktionen}{%
\chapter{Funktionen}\label{funktionen}}

\hypertarget{kontrollstrukturen}{%
\chapter{Kontrollstrukturen}\label{kontrollstrukturen}}

\hypertarget{packages}{%
\chapter{Packages}\label{packages}}

\hypertarget{workflow}{%
\chapter{Workflow}\label{workflow}}

  \bibliography{book.bib,packages.bib}

\end{document}
