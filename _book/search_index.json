[
["index.html", "Computational Methods in der politischen Kommunikationsforschung Methodische Vertiefung: Computational Methods mit R und RStudio Einführung Seminarinformationen Ablauf des Kurses Motivation und Ziele des Seminars Hinweise zur Nutzung des Online-Kurses", " Computational Methods in der politischen Kommunikationsforschung Methodische Vertiefung: Computational Methods mit R und RStudio Julian Unkel Einführung Zuletzt aktualisiert: 2020-05-08 14:03:21. Dies ist ein Work-in-Progress und wird laufend aktualisiert. Seminarinformationen Dozent: Julian Unkel, unkel@ifkw.lmu.de Zeit und Ort: Donnerstags, 12-14 Uhr, Oe 057 (bis auf weiteres findet das Seminar rein digital statt) Moodle: https://moodle.lmu.de/course/view.php?id=8250 Ablauf des Kurses Aufgrund der aktuellen Situation wird dieses Seminar in einen Online-Kurs überführt. Alle Seminarinhalte werden in Textform aufbereitet und nach und nach diesem Online-Kurs hinzugefügt. Auf Basis des Kurses sollen die Seminarinhalte selbstständig und mit weitestgehend eigenem Lerntempo erarbeitet werden. In jedem Kapitel werden hierzu zunächst die wesentlichen Konzepte und Inhalte erläutert. Jedes Kapitel schließt mit einigen Übungsaufgaben, die über Moodle abgegeben werden müssen. Deadlines für die Übungsaufgaben werden ebenfalls über Moodle kommuniziert, Lösungen im Anschluss an die Deadlines im Kurs hinzugefügt. Jeden Donnerstag zum regulären Seminartermin findet von 12-14 Uhr eine Online-Sprechstunde via Zoom statt. Hier können Fragen zu den Seminarinhalten, Übungsaufgaben etc. gestellt und diskutiert werden. In Moodle stehen zudem zwei Foren zur Verfügung, in dem Sie 1) allgemeine Fragen zu R und RStudio sowie 2) spezifische Fragen / alternative Lösungen zu den Übungsaufgaben (vor-)stellen und diskutieren können. Scheuen Sie sich bitte nicht, auch selbst auf Fragen und Probleme von Kommiliton*innen einzugehen. Neben den regulären Übungsaufgaben werden Sie bisweilen auch optionale, besonders knifflige Aufgaben vorfinden, die ich in der Sprache meiner Ahnen als Käpseles-Aufgaben kennzeichnen werde. Diese sind nicht verpflichtend, können Ihnen aber als Gradmesser dienen, ob Sie die jeweiligen Inhalte auch eigenständig und in leicht abgewandelter Form anwenden können. Motivation und Ziele des Seminars Das Ziel des Kurses ist es, methodische Kenntnisse zur Anwendung computationaler Methoden zu vermitteln. Hierzu werden wir uns zunächst allgemein mit der Datenbearbeitung und -analyse mit der statistischen Programmiersprache R auseinandersetzen. Es folgen dann spezifischere Verfahren der computationalen Datenerhebung und -analyse. Dabei stehen insbesondere folgende Inhalte im Vordergrund: Einführung in R und die Arbeit mit RStudio Datenmanagement in R Computationale Datenerhebung mit R Datenvisualisierung mit R Automatisierte Inhaltsanalyse mit R Zudem wird darauf eingegangen, wie mittels R und RStudio Kommunikationsforschung transparent, nachvollziehbar und reproduzierbar gestaltet werden kann. Es werden keine Vorkenntnisse in R vorausgesetzt; die Inhalte der Veranstaltung 15424 Datenanalyse werden als bekannt vorausgesetzt. Bevor es jedoch ans Eingemachte geht, ein paar Worte zur Motivation hinter diesem Seminar: Warum lohnt es sich überhaupt, eine Programmiersprache für die quantitativ-wissenschaftliche Arbeit zu lernen? Und warum ausgerechnet R? Warum also eine Programmiersprache für Datenanalyse lernen? Wenn Sie bisher Daten statistisch ausgewertet haben, etwa im Rahmen von Forschungsseminaren oder der Bachelorarbeit, wird das in der Regel mit einem Programm mit grafischer Oberfläche erfolgt sein, etwa mit Microsoft Excel oder mit IBM SPSS. Diese Programme haben viele Vorteile: sie sind meist auf spezifische Funktionen zugeschnitten, in ihrer Aufmachung an typische Computersoftware angepasst und entsprechend intuitiv zu bedienen - ein paar Klicks, und schon gibt SPSS eine Regressionstabelle mit allen relevanten Informationen aus. Für die meisten Anwendungsfälle im KW-Studium bieten genannten Programme leicht zu erlernende und umzusetzende Lösungen an. Programmiersprachen haben hingegen eine zweifellos höhere Einstiegshürde, deren Bewältigung für viele Anwendungsfälle in der Kommunikationswissenschaft auf den ersten Blick keinen größeren Nutzen verspricht. Vielleicht ist im Studium aber auch schon eine Situation aufgetreten, in der SPSS keine Hilfe bot. Eine Effektstärke für einen Mittelwertvergleich? Die bietet SPSS zwar in Form von \\(\\eta^2_p\\) für die ANOVA an, nicht jedoch Cohen’s \\(d\\) für den t-Test. Sie haben zusammen mit Komilliton*innen eine Inhaltsanalyse geplant und möchten vorab einen Intercoderreliabilitätstest durchführen? SPSS kennt weder die Reliabilität nach Holsti noch Krippendorff’s \\(\\alpha\\). Und auch wenn SPSS Grafiken ausgeben kann, so hat es doch einen Grund, warum man diese selten in wissenschaftlichen Veröffentlichungen (und hoffentlich auch in studentischen Arbeiten) findet. Benötigt man also eine Funktion, die in der gewählten Softwarelösung nicht vorhanden ist, so muss man auf eine andere ausweichen. Programmiersprachen bieten hier deutlich mehr Flexibilität - ist die gewünschte Funktion nicht vorhanden, so schreibt man sie eben selbst (bzw. hat dies in aller Regel schon jemand anderes, der ebenfalls vor diesem Problem stand, für Sie getan). Dies gilt natürlich umso mehr, je weniger standardisiert die zu analysierenden Daten und gewählten Analyseverfahren sind. Beschäftigen wir uns beispielsweise mit Onlinetexten oder digitalen Spurendaten, dann liegen diese oftmals nicht in vorstrukturierter Form vor, müssen erst über Schnittstellen abgerufen, automatisiert heruntergeladen und/oder für die weitere Nutzung aufbereitet werden. Computationale Analyseverfahren wie beispielsweise Verfahren zur automatisierten Inhaltsanalyse werden beständig weiterentwickelt und angepasst. Die Flexibilität, die skriptbasierte Datenanalyse bietet, ist daher einer der Hauptgründe, warum nicht nur in der Wissenschaft, sondern auch in anderen professionellen Kontexten, etwa der Markt- und Medienforschung, wo Lösungen für vielseitige datenanalytische Fragen gesucht werden, die Bedeutung von Programmiersprachen zur Datenanalyse zunimmt. Zugleich ist der Einstieg in das Programmieren deutlich einfacher geworden. Für viele Programmiersprachen stehen sogenannte Integrierte Entwicklungsumgebungen (IDEs) zur Verfügung, die mittels grafischer Benutzeroberflächen, intuitiver Bedienung und Hilfswerkzeugen (z. B. der automatischen Vervollständigung von Funktionsnamen) den Umgang mit Programmiersprachen deutlich erleichtern und komfortabler gestalten. Ein weiterer entscheidender Vorteil der programmatischen1 Datenanalyse ist, dass Skripte und Code alle Analyseschritte nachvollziehbar, transparent und reproduzierbar gestalten (entsprechend wurden Sie in der Datenanalyse-Ausbildung vermutlich auch dazu angehalten, in SPSS stets die Syntax zu nutzen). Einmal durchgeführte Arbeiten können somit jederzeit und problemlos von anderen und auch Ihnen selbst wiederholt und angepasst werden. Schließlich können auch karrieretechnische Überlegungen eine Rolle spielen. Viele Unternehmen setzen für datenanalytische Tätigkeiten die Kenntnis einer einschlägigen Programmiersprache inzwischen zwingend voraus. Und natürlich spiegelt sich das auch im Gehalt wider: das Vergleichsportal PayScale gibt beispielweise für Data Analysts, die die statistische Programmiersprache R beherrschen, ein um rund 5.000 US-Dollar höheres Jahresdurchschnittsgehalt an als für diejenigen Data Analysts, die mit SPSS arbeiten. Warum R lernen? Bisher wurde allgemein von Programmiersprachen gesprochen. In der Datenanalyse-Praxis sind viele unterschiedliche Programmiersprachen gängig, z. B. Python, R, SQL und Julia. Wir werden in den kommenden zwei Semestern mit R arbeiten. Dies hat einige Gründe: R ist eine speziell auf statistische und datenanalytische Anwendungen ausgelegte Programmiersprache (auch wenn die Anwendungsbereiche inzwischen darüber hinausgehen). Das bedeutet, dass viele gängige statistische Verfahren bereits in der Basis-Version vorhanden sind und ohne weitere Anpassungen genutzt werden können. In der Scientific Community ist R inzwischen sehr weit verbreitet und wird durch diese kontinuierlich weiterentwickelt. Das bedeutet auch, dass neue Verfahren, sowohl zur Datenerhebung als auch zur Datenanalyse, meist sehr schnell auch in R verfügbar sind. Zugleich gibt es durch die weite Verbreitung auch vielzählige Hilfsangebote. In Communities wie Stack Overflow und durch googeln werden Sie für nahezu jedes Problem, das sich Ihnen bei der Arbeit mit R stellt, schnell eine Lösung finden. R ist komplett kostenlos und für jedes Betriebssystem verfügbar. Mit RStudio steht eine ebenfalls kostenfreie IDE zur Verfügung, die die ehemals hohen Einstiegshürden erheblich senkt. R und RStudio decken durch Erweiterungen nahezu alle Schritte ab, die für die wissenschaftliche Arbeit erforderlich sind. Das reicht vom Datenabruf aus Befragungssoftware sowie der Datenerhebung durch Programmierschnittstellen oder Web Scraping über die Datenbearbeitung, -bereinigung und -analyse bis hin zur Erstellung von Manuskripten und publikationsfähigen Grafiken. Auch dieser Kurs ist komplett in RStudio erstellt. Auch wenn sich R in einigen Aspekten von den oben genannten Programmiersprachen unterscheidet, so sind viele der Konzepte, die wir in den kommenden zwei Semestern lernen werden, auch in anderen Programmiersprachen gleich oder zumindest ähnlich umgesetzt. Ihnen wird es in Zukunft also auch leichter fallen, sich bei Bedarf in andere Programmiersprachen einzuarbeiten. Hinweise zur Nutzung des Online-Kurses In der Onlineversion können Sie mit den Cursortasten ← und → durch die Seiten des Kurses blättern. In der oberen Leiste finden Sie einen Download-Knopf, mit dem Sie sich die aktuelle Version des Kurses als PDF oder EPUB (für E-Reader) herunterladen können. Bitte achten Sie in diesem Fall darauf, regelmäßig die aktuellste und somit vollständigste Version herunterzuladen. Oben auf dieser Seite ist angegeben, wann der Kurs zuletzt aktualisiert wurde. Früher oder später wird etwas in Ihrem Code nicht so funktionieren, wie Sie sich das vorstellen oder wünschen. Hier greift die 15-Minuten-Regel: Versuchen Sie zunächst, 15 Minuten lang das Problem selbst zu lösen - in dem Sie das Problem in kleinere Schritte zerlegen, den Code nach Tippfehlern durchsuchen, nochmals Hilfsdokumente konsultieren etc. Sind Sie nach 15 Minuten noch nicht weitergekommen, fragen Sie um Hilfe - z. B. in unseren Moodle-Foren. Der Witz, wonach Programmieren zu 70% aus Googeln bestehe, hat einen wahren Kern. Es ist nicht verwerflich, im Internet nach Hilfestellungen und Lösungen zu suchen und Code-Schnipsel von anderen zu verwenden - ganz im Gegenteil, gezieltes Suchen stellt einen wesentlichen Teil der Problemlösekompetenz dar. Auch wenn es jedoch verlockend und einfach erscheinen mag, Code von StackOverflow und vergleichbaren Portalen zu kopieren, sollten Sie immer versuchen, den Code und damit die Lösung auch nachvollziehen zu können. Illustration von @allison_horst: https://twitter.com/allison_horst Beginnen wir mit der Installation von R und RStudio sowie ersten Schritten. d. h. skript- bzw. codebasiert; im Englischen wird programmatically verwendet, um auszudrücken, dass etwas ‘durch Code’ und nicht durch Klicken von Knöpfen in einem Computerprogramm erfolgt ist, im Deutschen ist diese Wortbedeutung außerhalb von Informatikkreisen (noch) kaum geläufig; siehe auch diese Diskussion zur Wortbedeutung.↩ "],
["firststeps.html", "1 Installation und erste Schritte 1.1 R installieren 1.2 RStudio installieren 1.3 Die Benutzeroberfläche von RStudio 1.4 RStudio anpassen 1.5 Übungsaufgaben", " 1 Installation und erste Schritte In diesem Kapitel installieren wir die notwendige Software und machen uns mit der Benutzeroberfläche von RStudio vertraut. 1.1 R installieren Zunächst benötigen wir natürlich R. Die aktuellste Version erhalten wir immer über CRAN (Comprehensive R Archive Network). Unter “Download and Install R” wählen wir zunächst unser Betriebssystem. Im Falle von Windows wählen wir zusätzlich auf der folgenden Seite noch “base” (die Basisversion) aus. Es sollte dann ein Download-Link für die aktuellste Version erscheinen (3.6.3, Stand 9. April 2020). Der Installationsprozess selbst läuft wie bei anderer Software auch ab. Neben einem Interpreter, einem Programm, das Code (in diesem Fall also Code, der in R geschrieben wurde) für unseren Computer in ausführbare Befehle übersetzt, umfasst die Installation von R auch schon eine (sehr) rudimentäre grafische Benutzeroberfläche, die aber nur wenig komfortabel und nutzerfreundlich ist. Als nächstes installieren wir daher noch RStudio. 1.2 RStudio installieren RStudio ist eine grafische Benutzeroberfläche für R, die die Arbeit mit der Programmiersprache deutlich erleichert. Auch RStudio ist für Privatanwender komplett kostenfrei nutzbar. Die aktuellste Version kann über https://rstudio.com/products/rstudio/download/#download heruntergeladen werden. Für den Rest des Kurses arbeiten wir immer mit RStudio (und nicht direkt mit der Oberfläche von R). Öffnen wir also zum ersten Mal RStudio. 1.3 Die Benutzeroberfläche von RStudio Die Benutzeroberfläche von RStudio Nach dem Starten von RStudio sollte sich das Programm Ihnen wie oben präsentieren - mit einer Dreiteilung in drei abgetrennte Bereiche. Wir beginnen mit dem großen, aktuell noch weitestgehend leeren Bereich auf der linken Seite, der Konsole. 1.3.1 Konsole Die Konsole ist zugleich das Eingabe- und das Ausgabefenster von R bzw. RStudio. Befehle, die wir hier eingeben, werden durch Druck auf die Eingabe/Enter-Taste direkt ausgeführt. Die Konsole signalisiert uns, dass sie bereit ist, einen Befehl zu empfangen, durch ein vorangestelltes &gt;. Wir können dies mit simplen Berechnungen ausprobieren: (Zur Darstellung in diesem Kurs: die erste hellgraue Box umfasst hier und im Folgenden jeweils die Befehle, die wir eingeben - in diesem Fall also den Befehl 1 + 2. Die zweite hellgraue Box enthält dann immer die Ausgabe in der Konsole, gekennzeichnet durch zwei vorangestellte Rautensymbole ##.) 1 + 2 ## [1] 3 Die Konsole spuckt also direkt das Ergebnis aus – in diesem Fall 3 – und wartet auf den nächsten Befehl, wieder zu erkennen am &gt;. Die [1] links neben dem Ergebnis gibt an, dass es sich hierbei um den ersten (und einzigen) Ausgabewert handelt. Wir werden aber noch zahlreiche Befehle kennenlernen, bei denen mehr als nur ein Wert ausgegeben wird. Mit den Cursortasten ↑ und ↓ können wir in der Konsole durch bisher eingegebene Befehle schalten. Ein Druck auf ↑ sollte also den ersten und bisher einzigen Befehl - 1 + 2 - anzeigen. Ist ein Befehl noch nicht vollständig, signalisiert uns dies die Konsole durch ein vorangestelltes +. Wir können dies ausprobieren, in dem wir beispielsweise eine unvollständigen Additionsbefehl eingeben: 3 +. Die Konsole wartet nun auf den restlichen Befehl - in diesem Fall können wir eine weitere Zahl eingeben und den Befehl abschließen. Alternativ können wir den unvollständigen Befehl durch Druck der ESC-Taste abbrechen. In der Praxis passiert dies vor allem, wenn in einem längeren Befehl eine Klammer ) oder Anführungszeichen \" fehlt. Sollte die Konsole also einmal die Arbeit verweigern, liegt das oft daran, dass noch ein unvollständiger Befehl vorhanden ist. Prinzipiell könnten wir alle Arbeitsschritte über die Konsole ausführen. Das ist in der Praxis aber wenig sinnvoll, da wir im Normalfall längere und mehrere Befehle hintereinander ausführen und diese auch festhalten möchten. Wir arbeiten daher mit Skript-Dateien. 1.3.2 R-Skripte Um eine neue Skriptdatei zu erstellen, klicken wir entweder links oben auf das Symbol mit der leeren Seite und dem grünen Plus und anschließend auf R-Script, auf File - New File - R-Script oder drücken die Tastenkombination Strg/Cmd + Shift + N. Es sollte sich im links-oberen Bildschirmviertel eine leere Skriptdatei öffnen und unser RStudio-Fenster somit in ein viergeteiltes Layout übergehen: Hier können wir nun alle Befehle der Reihen der Reihe nach schreiben und gesammelt abspeichern. Einzelne Befehlszeilen lassen sich über die Tastenkombination Strg/Cmd + Eingabe/Enter ausführen. Das Ergebnis des Befehls erscheint dann in der Konsole. Wir können auch mehrere Zeilen auf einmal markieren und gemeinsam über dieselbe Tastenkombination ausführen. Schreiben wir z. B. mehrere Rechenoperationen hintereinander, so erscheinen deren Ergebnisse in der Ausführungsreihenfolge in der Konsole: 1 + 3 12 * 25 17 / 4 ## [1] 4 ## [1] 300 ## [1] 4.25 Längere Skriptdateien werden schnell unübersichtlich. Wir können aber an jeder Stelle Kommentare einfügen, indem wir eine Raute # voran stellen - alles was in dieser Zeile hinter dem Symbol steht, wird von R beim Ausführen ignoriert, wir können also sowohl ganze Zeilen auskommentieren als auch hinter R-Befehlen eine kurze Erklärung hinzufügen. Außerdem können jederzeit Leerzeilen eingefügt werden, um das Skript etwas aufzulockern: # Zunächst ein wenig Addition 2 + 5 6 + 12 # Dann ein wenig Multiplikation 21 * 35 2345 * 1.6 # Und zum Schluss etwas komplexere Rechenoperationen (2 + 3) ^ 3 # Das ^ steht für Exponentiation, hier also 5 hoch 3 ## [1] 7 ## [1] 18 ## [1] 735 ## [1] 3752 ## [1] 125 Skriptdateien können und sollten natürlich abgespeichert werden - entweder über File - Save oder die Tastenkombination Strg/Cmd + S. R-Skriptdateien erhalten die Dateiendung .R. 1.3.3 Environment Im rechten oberen Bildschrimbereich öffnet sich standardmäßig das Environment an, in dem RStudio alle derzeit angelegten und somit verfügbaren Objekte anzeigt. Mit Objekten werden in uns im nächsten Kapitel genauer auseinandersetzen. Weitere Registerkarten in diesem Bereich sind die History (eine Auflistung sämtlicher ausgeführter Zeilen der aktuellen Sitzung) sowie Connections und Build, die für uns aber vorerst keine Rolle spielen werden. 1.3.4 Files Der rechte untere Bildschirmbereich zeigt standardmäßig einen Dateibrowser (Files) an, der das aktuelle Arbeitsverzeichnis zeigt. Auch damit setzen wir uns in den kommenden Kapiteln ausführlicher auseinander. Weitere Registerkarten in diesem Bereich sind: Plots: hier werden Grafiken angezeigt, wenn wir diese in R erstellen. Packages: Eine Übersicht aller installieren Packages (kurz gesagt Sammlungen von R-Funktionen, die nicht in der Basisversion enthalten sind). Auch mit Packages beschäftigen wir uns in einem eigenen Kapitel. Help: Hier wird die Dokumentation einzelner Funktionen angezeigt, sobald wir diese anfordern. Diesen Bereich sehen wir uns an, sobald wir uns mit Funktionen beschäftigen. Viewer: Hier kann RStudio Webinhalte anzeigen, die mit R-Funktionen erstellt wurden. Dies wird vorab keine Rolle für uns spielen. 1.4 RStudio anpassen Unter Tools - Global Options können wir RStudio nach unseren Wünschen anpassen. Die einzelnen Einstellungsmöglichkeiten sollen hier nicht ausführlich diskutiert werden; hier jedoch einige sinnvolle Einstellungen: Global Options in RStudio Im Bereich General ist es sinnvoll, zwei Anpassungen vorzunehmen. Zum einen können wir unter R Sessions ein Default working directory (also ein standardmäßiges Arbeitsverzeichnis) einstellen. Dieses Verzeichnis öffnet R dann beim Start automatisch. Hier bietet es sich an, einen eigenen Ordner anzulegen. Unter Workspace entfernen Sie bitte, falls vorhanden, das Häkchen bei Restore .RData into workspace at startup und stellen Save workspace to .RData on exit auf Never. Zwar mag es praktisch erscheinen, dass RStudio automatisch die zuletzt bearbeitete Session wiederherstellt, das führt in der Praxis aber gerne zu Konflikten und Problemen – und letztlich ist es längerfristig auch sinnvoller, sich einen Arbeitsprozess anzueignen, bei dem Skripte schnell den jeweiligen Arbeitsstand wiederherstellen. Anzeigeeinstellungen in RStudio Eher Geschmackssache sind die Anzeigeeinstellungen, die Sie unter Appearance vornehmen können. Hier können Sie die Schriftart und -größe im Skripteditor einstellen sowie unter verschiedenen Themes (Farbschemata) wählen (darunter auch “dunkle” Themes, also solche, die hellen Text auf dunklem Hintergrund bieten). Am besten, Sie probieren hier unterschiedliche Einstellungen aus, bis Sie ein subjektiv angenehmes Anzeigebild von RStudio gefunden haben. 1.5 Übungsaufgaben Diese Aufgaben sollen Sie lediglich mit den grundlegendsten Funktionen von RStudio vertraut machen. Sie müssen daher keine Dateien abgeben. Übungsaufgabe 1.1 Installieren Sie R (siehe 1.1) und RStudio (1.2) und nehmen Sie die Einstellungen unter 1.4 vor. Übungsaufgabe 1.2 Öffnen Sie RStudio und führen Sie ein paar simple Berechnungen in der Konsole durch. Übungsaufgabe 1.3 Erstellen Sie eine neue Skriptdatei und fügen dort mindestens sechs Berechnungen hinzu. Gliedern Sie die Skriptdatei durch einige Kommentare. "],
["objekte-und-datenstrukturen.html", "2 Objekte und Datenstrukturen 2.1 Objektnamen 2.2 Objekttypen 2.3 Datenstrukturen 2.4 Übungsaufgaben", " 2 Objekte und Datenstrukturen Wir können R bzw. RStudio nun als Taschenrechner verwenden und uns arithmetische Operationen direkt in der Konsole ausgeben lassen: 1 + 2 # Addition 1 - 2 # Subtraktion 2 * 2 # Multiplikation 4 / 2 # Division 2 ^ 5 # Exponentiation ## [1] 3 ## [1] -1 ## [1] 4 ## [1] 2 ## [1] 32 Wirklich sinnvoll ist dies aber nicht: wir wollen Ergebnisse ja auch speichern und weiterverwenden können. Hierfür benötigen wir Variablen, also Namen, denen wir (veränderliche) Werte zuordnen können. In R lassen sich Variablen erstellen, indem wir einer Zeichenkette (zu den Benennungsregeln kommen wir gleich) einen Wert mittels &lt;- zuordnen (hierfür entweder die Zeichen &lt; und - eingeben oder die Tastenkombination Alt/Option + - drücken).2 Dies erstellt ein Objekt3 mit eben diesem Namen und der entsprechenden Zuordnung: x &lt;- 2 Führen wir diesen Befehl aus, erstellen wir das Objekt x und ordnen den Wert 2 zu. Wir sollten diese neue Zuordnung zudem im rechten oberen Environment-Bereich sehen können. Wir können nun mit diesem Objekt weiterrechnen: x * 2 x + 5 x / 2 ## [1] 4 ## [1] 7 ## [1] 1 Um den aktuellen Wert eines Objektes anzuzeigen, können wir auch einfach das Objekt ausführen: x ## [1] 2 Generell wird bei der Zuordnung immer zunächst der Teil rechts vom &lt;- ausgeführt und dann zugeordnet. Wir können also auch komplexere Befehle ausführen und diese Zuordnen: y &lt;- (2 + 4) * (3 - 1) / 2 y ## [1] 6 Objekte sind veränderlich und können jederzeit neu zugeordnet werden - und dabei auch selbst bei der Zuordnung verwendet werden: x &lt;- 2 x x &lt;- 3 x x &lt;- x - 1 x ## [1] 2 ## [1] 3 ## [1] 2 Schauen wir uns das einmal in einem etwas komplexeren Beispiel an - welchen Wert hat b am Ende dieser Befehlskette? a &lt;- 10 b &lt;- a / 2 a &lt;- b * 2 + a b &lt;- a - b Die Antwort lautet 15. Gehen wir das der Reihe nach durch: Zunächst ordnen wir a den Wert 10 zu. Dann orden wir b den Wert a / 2 zu. Da a in diesem Schritt 10 zugeordnet ist, wird 10 / 2 gerechnet. b entspricht nun also dem Wert 5. Wir ordnen nun a den Wert b * 2 + a zu. Der gesamte Teil rechts vom &lt;- wird zuerst ausgeführt und dann zugeordnet, hier also 5 * 2 + 10. a entspricht nun dem Wert 20, b weiterhin dem Wert 5. Zuletzt ordnen wir b das Ergebnis von a - b zu, was vor dieser Zuordnung 20 - 5 bedeutet. b entspricht schlussendlich also 15. Nochmals die wichtigsten Punkte zusammengefasst: Mit &lt;- erstellen wir Objekte und ordnen diesen Werte zu. Alle Objekte sind veränderlich und können überschrieben werden. Bei einer Zuordnung wird der gesamte Teil rechts vom Zuordnungspfeil &lt;- zuerst ausgeführt und dann die Zuordnung vorgenommen. 2.1 Objektnamen Für die obigen Beispiele haben wir nur einzelne Buchstaben für Objekte verwendet. In der Praxis können und sollten wir längere Objektnamen verwenden. Dabei gelten folgende Regeln: Objektnamen können Groß- und Kleinbuchstaben, Ziffern sowie Punkte . und Unterstriche _ beinhalten. Andere Sonderzeichen, Umlaute und Leerzeichen sind nicht gestattet. Objektnamen können mit einem Buchstaben oder einem . beginnen, nicht jedoch mit Ziffern oder _. Objektnamen sind case-sensitive, d. h. unterscheiden zwischen Groß- und Kleinschreibung. myVar und myvar sind also unterschiedliche Objekte. Es ist sinnvoll, Objekten “sprechende” Namen zu geben, sodass andere (und auch Sie zu einem späteren Zeitpunkt) nachvollziehen können, was sich dahinter verbirgt, auch ohne den gesamten Code zu lesen. # Gute Objektnamen mittelwert &lt;- 2.5 mein_alter &lt;- 32 groesse_in_cm &lt;- 175 # Schlechte Objektnamen x1 &lt;- 2.5 var2 &lt;- 32 asdasdasd &lt;- 175 Es gibt außerdem unterschiedliche Konventionen, um mehrere Wörter in Objektnamen aneinanderzuhängen. mein_alter ist ein Beispiel für den sogenannten snake_case: Alle Wörter kleingeschrieben und durch einen Unterstrich _ miteinander verbunden. Einen Überblick über verbreitete Konventionen der Objektbenennung gibt folgende Illustration: Illustration von @allison_horst: https://twitter.com/allison_horst Was auch immer Sie wählen - wichtig ist vor allem, dass Sie einheitlich vorgehen.4 2.2 Objekttypen Bisher haben wir lediglich Zahlen Objekten zugewiesen. Natürlich können Daten aber auch in anderen Formen vorliegen; wir sprechen daher von verschiedenen Objekttypen.5 2.2.1 Numerische Objekte Zahlenwerte werden in R als numeric bezeichnet. Wir können hier zudem zwischen den Typen integer (ganze Zahlen) und double (Kommazahlen6) unterscheiden. Grundsätzlich ordnet R Zahlen als double zu, auch wenn nur ganze Zahlen zugeordnet werden. x &lt;- 4 typeof(x) # Mit dieser Funktion können wir den Objekttyp anfordern ## [1] &quot;double&quot; Um explizit den Typ integer anzufordern, muss Zahlenwerten ein L nachgestellt werden:7 x &lt;- 4L typeof(x) ## [1] &quot;integer&quot; In der Praxis macht es aber kaum einen Unterschied, ob eine ganze Zahl als integer oder double abgespeichert wird – integer verbraucht weniger Speicherplatz, aber das wird erst bei sehr großen Datensätzen relevant. Wir können die Unterscheidung also guten Gewissens ignorieren und von numerischen Objekten sprechen. 2.2.2 Textobjekte Wir können Objekten auch Text zuordnen - diese Objekte haben dann den Typ character (Textvariablen werden zudem häufig als “string” bezeichnet). Um ein character-Objekt zu erstellen, müssen wir die Zeichenkette in einfache '' oder doppelte \"\" Anführungszeichen setzen: text1 &lt;- &quot;Guten Morgen!&quot; text2 &lt;- &#39;Einfache Anführungszeichen sind sinnvoll, wenn im &quot;Text&quot; ebenfalls Anführungszeichen vorkommen&#39; Natürlich können auch Zahlen als Text gespeichert werden - werden dann aber natürlich auch als Text behandelt, sodass man nicht mehr mit ihnen rechnen kann. zahl_als_text &lt;- &quot;123&quot; 2.2.3 Logicals (logische Objekte) Der dritte Kernobjekttyp heißt logical und kann nur zwei Werte annehmen: TRUE (wahr) oder FALSE (falsch). Logicals entstehen durch logische Vergleiche zweier Objekte, wobei u.a. folgende Operatoren verwendet werden können: Tabelle 2.1: Logische Operatoren in R Operator Vergleich Beispiele == ist gleich 1 == 1 (ergibt TRUE)\"a\" == \"b\" (ergibt FALSE) != ist nicht gleich 1 != 1 (ergibt FALSE)\"a\" != \"b\" (ergibt TRUE) &lt; ist kleiner als 1 &lt; 2 (ergibt TRUE)2 &lt; 2 (ergibt FALSE) &gt; ist größer als 2 &gt; 1 (ergibt TRUE)2 &gt; 2 (ergibt FALSE) &lt;= ist kleiner gleich 1 &lt;= 2 (ergibt TRUE)2 &lt;= 2 (ergibt TRUE) &gt;= ist größer gleich 2 &gt;= 1 (ergibt TRUE)2 &gt;= 2 (ergibt TRUE) Die Zuordnung erfolgt wie bei anderen Objekten auch: x &lt;- &quot;a&quot; == &quot;b&quot; x ## [1] FALSE Logicals werden vor allem bei Wenn-Dann-Bedingungen benötigt, mit denen wir uns im übernächsten Kapitel auseinandersetzen werden. 2.2.4 Weitere Objekttypen Diese drei Objekttypen (numeric, character, logical) bilden die Basis fast aller Objekte in R. Durch zusätzliche Attribute können jedoch noch zusätzliche Objekttypen erzeugen, die den Umgang mit bestimmten Daten erleichtern. Für kategoriale Variablen kennt R beispielsweise den Typ factor, für Datumsangaben den Typ date. Diese werden bei der Zuordnung nicht automatisch erkannt und müssen stattdessen durch bestimmte Funktionen erzeugt werden. Erzeugen wir beispielsweise ein Objekt mit einer Zeichenfolge, die ein Datum repräsentiert (z. B. date1 &lt;- \"2020-05-05\", im Format YYYY_MM_DD, also Jahr-Monat-Tag), speichert R dies zunächst als character ab. Wir können aber R explizit sagen, dass er dies als Datum behandeln soll: date2 &lt;- as.Date(&quot;2020-05-05&quot;) Dies hat nun u.a. den Vorteil, dass wir im Gegensatz zu character-Objekten auch arithmetische Operationen durchführen können, also beispielsweise zwei Datums-Objekte voneinander subtrahieren, um die zeitliche Differenz zu berechnen. Wir werden uns im späteren Verlauf noch ausführlicher mit diesen spezielleren Objekttypen beschäftigen – bis jetzt nehmen Sie vor allem mit, dass sowohl kategoriale Variablen als auch Datumsangaben kein Problem für R darstellen. 2.2.5 Fehlende Werte Fehlende Werte werden in R als NA angegeben. Es ist sinnvoll, fehlende Werte immer explizit als NA zu kennzeichnen und nicht etwa durch einen negativen Wert bei numerischen Variablen (z. B. -9) oder durch einen leeren String bei Textvariablen (\"\"), damit sichergestellt ist, dass Funktionen den fehlenden Wert auch entsprechend als einen solchen behandeln. 2.2.6 Objekttypen ändern Bisweilen wird es relevant sein, Objekttypen zu ändern - etwa weil Zahlen fälschlicherweise als Text eingelesen wurden. Hierfür bietet R Funktionen an, die allesamt nach dem Schema as.[Objekttyp]() aufgebaut sind: mit as.numeric() wandeln wir Objekte in numerische Objekte um (genauer gesagt in double), mit as.character() in Textobjekte und, wie im vorigen Abschnitt gesehen, mit as.Date() in ein Datumsobjekt. Der Fachbegriff hierfür lautet Coercion, wir zwingen R also dazu, ein Objekt als einen bestimmten Typ zu behandeln, auch wenn R automatisch einen anderen Typus bestimmt hätte. x1 &lt;- &quot;25&quot; x1 typeof(x1) x2 &lt;- as.numeric(&quot;25&quot;) x2 # Beachten Sie, dass in der Ausgabe nun die Anführungszeichen fehlen typeof(x2) ## [1] &quot;25&quot; ## [1] &quot;character&quot; ## [1] 25 ## [1] &quot;double&quot; Natürlich klappt das nur, solange die Umwandlung auch sinnvoll durchführbar ist – in allen anderen Fällen wird eine Warnung ausgegeben und es werden fehlende Werte erzeugt. x &lt;- as.numeric(&quot;Dieser Text kann nicht sinnvoll als Zahl interpretiert werden&quot;) ## Warning: NAs durch Umwandlung erzeugt x ## [1] NA 2.3 Datenstrukturen Bisher haben wir einem Objekt immer nur einen einzigen Wert zugeordnet. Der Fachbegriff hierfür lautet Skalar und beschreibt somit die einfachst mögliche Datenstruktur, eben dass einem Objekt nur ein einziger Wert zugeordnet wurde. Objekte können in R jedoch auch mehrere Werte enthalten und somit komplexere Datenstrukturen erzeugen. Im Folgen betrachten wir daher die vier wichtigsten komplexeren Datenstrukturen in R. Diese unterscheiden sich zum einen in ihrer Dimensionalität (also ob sie ein- oder zweidimensional sind) und zum anderen, ob sie homogene (also nur dieselben) oder heterogene (also unterschiedliche) Objekttypen beinhalten können: Tabelle 2.2: Datenstrukturen in R Datenstruktur Dimensionalität Objekttypen Vektor eindimensional homogen Liste eindimensional heterogen Matrix zweidimensional homogen Dataframe zweidimensional heterogen 2.3.1 Vektoren Vektoren sind Objekte, die mehrere Werte desselben Typs beinhalten. Wir erzeugen Vektoren über die Funktion c() (von concatenate, also verketten). Die einzelnen Elemente des Vektors werden durch Kommas , getrennt. gerade_zahlen &lt;- c(2, 4, 6, 8) gerade_zahlen ungerade_zahlen &lt;- c(1, 3, 5, 7, 9) ungerade_zahlen simpsons &lt;- c(&quot;Homer Simpson&quot;, &quot;Marge Simpson&quot;, &quot;Bart Simpson&quot;, &quot;Lisa Simpson&quot;, &quot;Maggie Simpson&quot;) simpsons ## [1] 2 4 6 8 ## [1] 1 3 5 7 9 ## [1] &quot;Homer Simpson&quot; &quot;Marge Simpson&quot; &quot;Bart Simpson&quot; &quot;Lisa Simpson&quot; ## [5] &quot;Maggie Simpson&quot; Wir können auch Vektoren über c() mit einander verketten: zahlen &lt;- c(gerade_zahlen, ungerade_zahlen) zahlen ## [1] 2 4 6 8 1 3 5 7 9 Beachten Sie, dass die Verkettung immer in der angegebenen Reihenfolge erfolgt – R sortiert die Elemente also nicht automatisch. 2.3.1.1 Vektorelemente auswählen Um bestimmte Elemente eines Vektors auszuwählen, können wir die gewünschten Elemente in eckigen Klammern [] hinter einem Vektor definieren. Hier geben wir nur das zweite Element des oben erzeugten zahlen-Vektors aus: zahlen[2] ## [1] 4 Um mehrere Elemente eines Vektors auszugeben, benötigen wir wiederum einen Vektor mit den gewünschten Positionen – hier geben wir uns beispielsweise das erste, dritte und fünfte Element aus: zahlen[c(1, 3, 5)] ## [1] 2 6 1 2.3.1.2 Vektorelemente benennen Elemente in Vektoren können benannt werden, indem beim Erstellen die Namen der Elemente mit einem = angegeben werden: homer &lt;- c(nachname = &quot;Simpson&quot;, vorname = &quot;Homer&quot;, wohnort = &quot;Springfield&quot;) homer ## nachname vorname wohnort ## &quot;Simpson&quot; &quot;Homer&quot; &quot;Springfield&quot; Benannte Elemente können dann auch über den Namen ausgewählt werden: homer[&quot;wohnort&quot;] ## wohnort ## &quot;Springfield&quot; Auch dies funktioniert mit mehreren Elementen gleichzeitig: homer[c(&quot;vorname&quot;, &quot;nachname&quot;)] ## vorname nachname ## &quot;Homer&quot; &quot;Simpson&quot; Alternativ können Elementnamen im Nachhinein über die Funktion names() hinzugefügt werden: marge &lt;- c(&quot;Simpson&quot;, &quot;Marge&quot;, &quot;Springfield&quot;) names(marge) &lt;- c(&quot;nachname&quot;, &quot;vorname&quot;, &quot;wohnort&quot;) marge ## nachname vorname wohnort ## &quot;Simpson&quot; &quot;Marge&quot; &quot;Springfield&quot; 2.3.1.3 Mit Vektoren rechnen Mit numerischen Vektoren können arithmetische Berechnungen durchgeführt werden: zahlen + 1 zahlen * 2 ## [1] 3 5 7 9 2 4 6 8 10 ## [1] 4 8 12 16 2 6 10 14 18 Berechnungen werden dabei der Reihe nach für jedes einzelne Vektorelement durchgeführt. Es ist auch möglich, Vektoren gleicher Länge zu addieren, subtrahieren etc. – im Falle einer Addition wird dann das erste Element des ersten Vektors zum ersten Element des zweiten Vektors addiert, dann das zweite Element des ersten Vektors zum zweiten Element des zweiten Vektors usw.: x1 &lt;- c(1, 3, 5) x2 &lt;- c(2, 3, 4) x1 * x2 ## [1] 2 9 20 2.3.1.4 Nützliche Vektorfunktionen Abschließend einige nützliche Funktionen für den Umgang mit Vektoren: length() gibt die Anzahl der Elemente eines Vektors aus. Die unter 2.2.6 eingeführten Coercion-Funktionen (as.numeric(), as.character() usw.) können auch auf Vektoren angewendet werden und wandeln so jedes Vektorelement um. Für numerische Vektoren stehen zahlreiche statistische Funktionen bereit, z. B. zur Berechnung der Summe (sum()), des arithmetischen Mittels (mean()) und der Standardabweichung (sd()) x &lt;- c(10, 24, 32, 999) length(x) sum(x) mean(x) sd(x) ## [1] 4 ## [1] 1065 ## [1] 266.25 ## [1] 488.5846 Oftmals benötigen wir aufsteigende Zahlenfolgen für Vektoren, beispielsweise für laufende Nummern. Dies lässt sich über die Funktion : abkürzen, die einen Vektor Startwert:Endwert erstellt: eins_bis_zehn &lt;- 1:10 eins_bis_zehn ## [1] 1 2 3 4 5 6 7 8 9 10 2.3.2 Listen Listen ähneln zunächst Vektoren und werden mit der Funktion list() erzeugt. Auch die Benennung von Listenelementen erfolgt analog zu Vektoren entweder beim Erstellen der Liste mit = oder im Nachhinein mit names(): munich_facts &lt;- list(name = &quot;München&quot;, bundesland = &quot;Bayern&quot;, bezirk = &quot;Oberbayern&quot;) munich_facts ## $name ## [1] &quot;München&quot; ## ## $bundesland ## [1] &quot;Bayern&quot; ## ## $bezirk ## [1] &quot;Oberbayern&quot; Wir sehen aber bereits am Konsolenoutput, dass die Darstellung von Vektoren abweicht: anstatt alle Elemente nebeneinander angezeigt zu bekommen, werden die einzelnen Elemente untereinander angezeigt. Das rührt daher, dass Listen deutlich mächtiger und flexibler sind als Vektoren. Nicht nur können wir in den einzelnen Elementen Objekttypen mischen, wir sind auch nicht auf einzelne Werte (Skalare) als Elemente beschränkt. Tatsächlich kann so gut wie jedes Objekt ein Listenelement sein – also auch Vektoren, ganze Datensätze und sogar Listen (die wiederum eigene Listen enthalten können – wir können hier also Daten prinzipiell endlos verschachteln). Erweitern wir dazu die Liste von oben: munich_facts &lt;- list( namen = c(hochdeutsch = &quot;München&quot;, englisch = &quot;Munich&quot;, bairisch = &quot;Minga&quot;), bundesland = &quot;Bayern&quot;, gruendungsjahr = 1158, daten = list( einwohner = 1471508, geographie = c(flaeche_in_km2 = 310.7, hoehe_NHN_in_m = 519) ) ) munich_facts ## $namen ## hochdeutsch englisch bairisch ## &quot;München&quot; &quot;Munich&quot; &quot;Minga&quot; ## ## $bundesland ## [1] &quot;Bayern&quot; ## ## $gruendungsjahr ## [1] 1158 ## ## $daten ## $daten$einwohner ## [1] 1471508 ## ## $daten$geographie ## flaeche_in_km2 hoehe_NHN_in_m ## 310.7 519.0 Mit ihrer Flexibilität stellen Listen in R die Basis für nahezu alle komplexeren Datenstrukturen – auch bei Datensätze, Regressionsmodellen etc. handelt es sich um Listen, die mit bestimmten Attributen versehen wurden. 2.3.2.1 Listenelemente auswählen Auch die Auswahl von Listenelementen funktioniert ähnlich wie bei Vektoren über die numerische Position oder den Elementnamen: munich_facts[1] ## $namen ## hochdeutsch englisch bairisch ## &quot;München&quot; &quot;Munich&quot; &quot;Minga&quot; munich_facts[&quot;daten&quot;] ## $daten ## $daten$einwohner ## [1] 1471508 ## ## $daten$geographie ## flaeche_in_km2 hoehe_NHN_in_m ## 310.7 519.0 Vielleicht ist Ihnen bereits das Dollarsymbol $ vor den Elementnamen aufgefallen – dieses verweist auf eine Funktion, mit der Listenelemente noch komfortabler ausgewählt werden können: munich_facts$bundesland ## [1] &quot;Bayern&quot; Nicht nur sparen Sie sich ein paar Zeichen bei der Eingabe, RStudio macht Ihnen auch automatisch Vorschläge, sobald Sie das Dollarzeichen eingetippt haben (im Beispiel also ab munich_facts$), welche Elemente sie auswählen können. Auch tiefer verschachtelte Elemente können so ausgewählt werden: munich_facts$daten$einwohner ## [1] 1471508 2.3.2.2 Nützliche Listenfunktionen Auch für Listen stehen einige nützliche Funktionen zur Verfügung, die die Arbeit mit ihnen erleichtern. length gibt wie auch schon bei Vektoren die Anzahl der Elemente aus (wobei auch komplexere Elemente, also z. B. Vektoren, Listen etc., jeweils als ein Element gezählt werden): length(munich_facts) ## [1] 4 Spezifisch für Listen relevant ist die Funktion str(), die zusätzliche Informationen über die Struktur der Liste ausgibt, was gerade bei verschachtelteren Listen den Überblick erleichtert: str(munich_facts) ## List of 4 ## $ namen : Named chr [1:3] &quot;München&quot; &quot;Munich&quot; &quot;Minga&quot; ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;hochdeutsch&quot; &quot;englisch&quot; &quot;bairisch&quot; ## $ bundesland : chr &quot;Bayern&quot; ## $ gruendungsjahr: num 1158 ## $ daten :List of 2 ## ..$ einwohner : num 1471508 ## ..$ geographie: Named num [1:2] 311 519 ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;flaeche_in_km2&quot; &quot;hoehe_NHN_in_m&quot; Wir sehen, dass die Liste munich_facts aus 4 Elementen besteht List of 4. Das erste Element trägt den Namen namen ist ein benannter character-Vektor (abgekürzt durch chr) mit 3 Elementen (Angabe [1:3]) usw. Durch die komplexe Struktur sind Listen jedoch nicht so einfach zu handhaben. Mittels der Funktion unlist() können Listen daher in Vektoren (inkl. Elementnamen, soweit vorhanden) umgewandelt werden: munich_facts_vector &lt;- unlist(munich_facts) munich_facts_vector ## namen.hochdeutsch namen.englisch ## &quot;München&quot; &quot;Munich&quot; ## namen.bairisch bundesland ## &quot;Minga&quot; &quot;Bayern&quot; ## gruendungsjahr daten.einwohner ## &quot;1158&quot; &quot;1471508&quot; ## daten.geographie.flaeche_in_km2 daten.geographie.hoehe_NHN_in_m ## &quot;310.7&quot; &quot;519&quot; 2.3.3 Matrizen Matrizen sind Vektoren, die in eine zweidimensionale Struktur, also Zeilen und Spalten, überführt werden und können mit der Funktion matrix() erstellt werden. Hierzu ist zusätzlich noch die Anzahl an Zeilen, in die der Vektor aufgeteilt werden soll, nötig: x &lt;- 1:10 # Zahlen von 1 bis 10 als Vektor m &lt;- matrix(x, nrow = 2) # Vektor in Matrix mit zwei Zeilen aufteilen m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 Alternativ können wir mehrere Vektoren mit den Funktionen cbind() spaltenweise (von column) und rbind() zeilenweise (von row) zu einer Matrix “zusammenkleben”. x1 &lt;- 1:4 x2 &lt;- 5:8 x3 &lt;- 0:3 m &lt;- cbind(x1, x2, x3) m ## x1 x2 x3 ## [1,] 1 5 0 ## [2,] 2 6 1 ## [3,] 3 7 2 ## [4,] 4 8 3 2.3.3.1 Matrizen benennen Auch Matrizen können benannt werden. Da wir nun aber eine zweidimensionale Struktur haben, können wir entsprechend auch Zeilen und Spalten einzeln benennen. Hierfür gibt es die Funktionen rownames() und colnames(), die analog zu names() verwendet werden: colnames(m) &lt;- c(&quot;spalte_1&quot;, &quot;spalte_2&quot;, &quot;spalte_3&quot;) rownames(m) &lt;- c(&quot;zeile_a&quot;, &quot;zeile_b&quot;, &quot;zeile_c&quot;, &quot;zeile_d&quot;) m ## spalte_1 spalte_2 spalte_3 ## zeile_a 1 5 0 ## zeile_b 2 6 1 ## zeile_c 3 7 2 ## zeile_d 4 8 3 2.3.3.2 Nützliche Matrixfunktionen length() funktioniert auch für Matrizen und gibt die Anzahl aller Elemente an. Interessieren wir uns dagegen für die Anzahl an Zeilen und Spalten, gibt die Funktion dim() Aufschluss, die einen Vektor mit der Anzahl der Zeilen und der Anzahl der Spalten ausgibt: length(m) dim(m) ## [1] 12 ## [1] 4 3 Die Funktion t() transponiert die Matrix, dreht die Matrix also um 90 Grad und vertauscht somit Zeilen und Spalten: t(m) ## zeile_a zeile_b zeile_c zeile_d ## spalte_1 1 2 3 4 ## spalte_2 5 6 7 8 ## spalte_3 0 1 2 3 2.3.4 Dataframes Mit Matrizen kommen wir der Datensatzstruktur, wie wir sie von SPSS oder Excel kennen, schon recht nahe. Allerdings repräsentieren Matrizen Vektoren und sind daher auf einen Objekttyp beschränkt. Diese Einschränkung hebt die Datenstruktur Dataframe auf, mit der gleich lange Vektoren unterschiedlichen Typs kombiniert werden können. Wir erstellen Dataframes mit der gleichnamigen Funktion data.frame(): beatles_data &lt;- data.frame( name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;), surname = c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Harrison&quot;, &quot;Starr&quot;), born = c(1940, 1942, 1943, 1940) ) beatles_data ## name surname born ## 1 John Lennon 1940 ## 2 Paul McCartney 1942 ## 3 George Harrison 1943 ## 4 Ringo Starr 1940 Wenn wir mit tabellarischen Daten arbeiten, geschieht das also in der Regel mit Dataframes. Natürlich wäre es nicht zielführend, wenn wir diese immer von Hand erstellen müssten. Es gibt daher Funktionen, mit denen wir externe Dateien (z. B. CSV-, Excel- und sogar SPSS-Dateien) als Dataframes in R laden können. Wie wir externe Dateien laden, schauen wir uns zu einem späteren Zeitpunkt genauer an. 2.3.4.1 Beispiel-Dataframes R enthält einige eingebaute Beispiel-Dataframes, mit denen Funktionen demonstriert und geübt werden können. Keiner davon hat auch nur einen geringen KW-Bezug, aber damit wir nun auch ohne große Erstellungs-Arbeit mit Dataframes arbeiten können, nutzen wir diese dennoch. Wir werden aber bald auch mit für Sie relevanteren Daten arbeiten, versprochen. Diese Beispiel-Datensätze sind direkt als Objekte hinterlegt und können durch Eingabe des Objektnamens genutzt werden. Wir arbeiten nun mit dem Datensatz iris, der Blütenblatt- und Kelchblatt-Daten zu je 50 Exemplaren dreier Spezies von Schwertlilien (englisch iris) umfasst. Wie gesagt, keinerlei KW-Bezug, aber immerhin ein Grund, um den Text kurz durch einige Blumenfotos aufzulockern. Drei Schwertlilien-Spezies im iris-Datensatz, von links nach rechts: Borsten-Schwertlilie (iris setosa), verschiedenfarbige Schwertlilie (iris versicolor) und Virginia-Schwertlilie (iris virginica). Fotos: Radomił Binek, Danielle Langlois und Eric Hunt. 2.3.4.2 Arbeiten mit Dataframes Dataframes basieren auf Listen und Vektoren (genau genommen ist ein Dataframe eine Liste von gleich langen Vektoren, die zweidimensional dargestellt wird). Entsprechend können wir eine Vielzahl der Funktionen, die wir bei Listen und Vektoren kennengelernt haben, auch auf Dataframes anwenden. In der Regel haben wir Datensätze, die mehr als nur ein paar Fälle umfassen. Sie in der Konsole ausgeben zu lassen, ist daher nur bedingt sinnvoll. Besser ist es, Informationen über die Struktur des Datensatzes über Funktionen abzufragen. Die length()-Funktion gibt bei Dataframes die Anzahl der Spalten zurück (wir erinnern uns: Dataframes sind Listen, deren Elemente die Spaltenvektoren sind; entsprechend ermittelt length() daher die Anzahl der Vektoren). Die Anzahl der Zeilen – mithin die Anzahl der Fälle – gibt die Funktion nrow() aus. Beide Werte gemeinsam können wir erneut über dim() ausgeben. length(iris) nrow(iris) dim(iris) ## [1] 5 ## [1] 150 ## [1] 150 5 Wir sehen, dass der iris-Datensatz 5 Spalten (= Variablen) und 150 Zeilen (= Fälle) umfasst. Für einen Überblick bietet sich wie auch schon bei Listen die str()-Funktion an. str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Der Datensatz umfasst also 4 numerische Variablen (jeweils Länge und Breite des Blüten- (sepal) und des Kelchblattes (petal)) sowie eine kategoriale Faktorvariable mit 3 Stufen, in der die Spezies des jeweiligen Exemplars festgehalten ist. 150 Fälle à 5 Variablen wären im Konsolenoutput sehr lang und unübersichtlich. Wollen wir dennoch in unsere Daten spähen, können wir uns mittels head() und tail() die ersten bzw. letzten Zeilen des Datensatzes ausgeben. Standardmäßig werden bei beiden Funktionen 6 Fälle angezeigt. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa R bietet auch einen Viewer, mit dem der gesamte Datensatz ähnlich wie ein Tabellenblatt in Excel oder die Datenansicht in SPSS angezeigt wird. Hierzu führen wir die Funktion View() aus (großes V beachten), woraufhin in RStudio ein eigener Reiter mit der Datenansicht geöffnet wird. View(iris) Die Datenansicht von R In der Datenansicht können wir den Datensatz nach Variablen sortieren oder bestimmte Wertebereiche je Variable filtern; in der Fußzeile werden Strukturinformationen (Zeilen- und Spaltenanzahl) angezeigt. Fährt man mit dem Mauszeiger über die Kopfzeilen der Variablen, werden zudem weitere Informationen (Objekttyp und Wertebereich) eingeblendet. Um einzelne Variablen (also Spalten bzw. die dahinterliegenden Vektoren) auszuwählen, können wir wie auch bei Listen das $-Zeichen nutzen: iris$Sepal.Length ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 ## [21] 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4 5.1 ## [41] 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 ## [61] 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 ## [81] 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 ## [101] 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 ## [121] 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 ## [141] 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 Das Resultat hat den Objekttyp Vektor. Wir können daher die uns bekannten Vektorfunktionen auf das Resultat anwenden. Um beispielsweise den Mittelwert der Kelchblattbreite zu erhalten, geben wir folgendes ein: mean(iris$Petal.Width) ## [1] 1.199333 Auch die eckigen Klammern [] können genutzt werden, um flexibler nur bestimmte Teile des Datensatzes anzuzeigen. Dabei ist die zweidimensionale Struktur zu beachten – wir können zwei Werte bzw. Vektoren, getrennt durch ein ,, übergeben, die dann die Zeilen respektive die Spalten anwählt. Um etwa die ersten zehn Zeilen der Variablen Sepal.Length und Petal.Length auszuwählen, ist folgender Code nötig: iris[1:10, c(&quot;Sepal.Length&quot;, &quot;Petal.Length&quot;)] ## Sepal.Length Petal.Length ## 1 5.1 1.4 ## 2 4.9 1.4 ## 3 4.7 1.3 ## 4 4.6 1.5 ## 5 5.0 1.4 ## 6 5.4 1.7 ## 7 4.6 1.4 ## 8 5.0 1.5 ## 9 4.4 1.4 ## 10 4.9 1.5 Sollen lediglich Zeilen oder nur Spalten gefiltert werden, lassen wir den jeweiligen Wert vor (Zeilen) oder nach dem , (Spalten) leer. Folgender Code gibt die Zeilen 5-10 und alle Spalten aus: iris[5:10,] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa Auch die Benennung von Dataframes läuft analog zu den bisherigen Objekttypen ab. Um etwa die Variablen einzudeutschen, können wir wieder names() nutzen8: names(iris) &lt;- c(&quot;bluetenblatt_laenge&quot;, &quot;bluetenblatt_breite&quot;, &quot;kelchblatt_laenge&quot;, &quot;kelchblatt_breite&quot;, &quot;spezies&quot;) head(iris) ## bluetenblatt_laenge bluetenblatt_breite kelchblatt_laenge kelchblatt_breite spezies ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Falls Ihnen das nun umständlich erscheint – keine Sorge, wir werden, sobald wir uns ans richtige Datenmanagement begeben, Funktionen kennenlernen, die die obigen Schritte deutlich erleichtern. Für das Grundverständnis ist es aber wichtig, auch diese Art der Arbeit mit Dataframes kennenzulernen. 2.4 Übungsaufgaben Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als ue2_nachname.R ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen. Übungsaufgabe 2.1 Objekttypen und Datenstrukturen I: Erstellen Sie ein Objekt myself, das folgende Elemente enthält: name: Ihren Namen born: Ihr Geburtsjahr from_bavaria: Sind Sie in Bayern geboren? Welche Datenstruktur ist hierfür am sinnvollsten? Welche Objekttypen haben die einzelnen Elemente? Übungsaufgabe 2.2 Vektorfunktionen, Objekttypen und -umwandlung: Führen Sie folgenden Code aus: values &lt;- c(1.2, 1.3, 0.8, 0.7, 0.7, 1.5, 1.1, 1.0, 1.1, 1.2, 1.1) average &lt;- mean(values) above_average &lt;- values &gt; average sum(above_average) / length(values) Beschreiben Sie in eigenen Worten, was hier in jeder Zeile passiert. Was bedeutet das Resultat der letzten Codezeile? Warum wird hier überhaupt ein Resultat ausgeben? Schauen Sie sich hierzu an, was passiert, wenn Sie above_average in einen numerischen Vektor umwandeln. Übungsaufgabe 2.3 Arbeiten mit Dataframes: Im Beispiel-Datensatz mtcars sind einige Daten zu verschiedenen KfZ-Modellen hinterlegt. Beantworten Sie die folgenden Fragen zum Datensatz mittels Funktionen: Wie viele Variablen und Fälle befinden sich in dem Datensatz? Welche der drei Objekttypen (numeric, character, logical) kommen in dem Datensatz vor? Wie viele Zylinder haben die enthaltenen Fahrzeuge im Durchschnitt? (Zylinder: cyl) Erstellen Sie einen neuen Datensatz cars_short, der lediglich die Variablen mpg und hp enthält. Es ist prinzipiell auch möglich, die Zuordnung mittels einem = vorzunehmen. Da das = aber auch in anderen Kontexten benötigt wird, erzeugt dies Verwirrung, sodass wir Objekte immer mit &lt;- zuordnen sollten.↩ Die Begriffe Variable und Objekt können für unsere Zwecke weitestgehend synonym verwendet werden. Wir werden aber gleich noch sehen, das so ziemlich alles in R ein Objekt sein kann.↩ Aufmerksamen Leser*innen dürfte zudem aufgefallen sein, dass kebab-case in R nicht möglich ist.↩ Tatsächlich ist die Sache etwas komplexer: es gibt in R einige wenige Kernobjekttypen, die wiederum mit bestimmten Attributen versehen werden können, um daraus zusätzliche Objekttypen abzuleiten. So kann etwa eine Zahlenfolge mit einem zusätzlichen Attribut als Datumsangabe interpretiert werden. Für unsere Zwecke spielt diese Unterscheidung jedoch keine Rolle.↩ Der Typenbezeichnung leitet sich von Gleitkommazahlen mit doppelter Genauigkeit ab.↩ Warum L? Hier gibt es unterschiedliche Erklärungsansätze, die beispielsweise hier nachgelesen werden können↩ Da Dataframes eine zweidimensionale Struktur darstellen, können wir auch die Funktionen colnames() und rownames(), die wir von den Matrizen kennen, verwenden, um die Spalten respektive Zeilen umzubenennen. colnames() und names() sind bei Dataframes äquivalent; Zeilennamen sind eher unüblich. In der Praxis wird daher meistens lediglich names() verwendet.↩ "],
["funktionen.html", "3 Funktionen 3.1 Funktionen aufrufen 3.2 Eigene Funktionen erstellen 3.3 Übungsaufgaben", " 3 Funktionen Wir haben bereits im vorherigen Kapitel einige Funktionen eingesetzt. Tatsächlich ist alles, was in R ausgeführt wird, eine Funktion. Zeit also, dass wir uns etwas detaillierter mit Funktionen auseinandersetzen. 3.1 Funktionen aufrufen In den allermeisten Fällen rufen wir Funktionen nach dem folgenden Schema auf: funktionsname(argument1 = wert1, argument2 = wert2, argument3 = wert3, ...) Der Funktionsname wird gefolgt von Klammern (), in die in aller Regel mindestens ein Argument übergeben wird.9 Die Funktion gibt daraufhin ein Resultat oder eine Fehlermeldung zurück, wobei das Resultat jede Datenstruktur in R annehmen kann – also sowohl einzelne Werte als auch komplexe Listen oder Dataframes. Da Funktionen im Erfolgsfall immer exakt ein Resultat ausgeben, können wir dieses problemlos wiederum einem Objekt zuweisen und weiterverwenden: mean_petal_length &lt;- mean(iris$Petal.Length) 3.1.1 Funktionsargumente Funktionen benötigen mindestens ein Argument, oft auch mehrere Argumente, um korrekt ausgeführt zu werden. Oftmals umfassen Funktionsargumente zum einen (Daten-)Objekte, die von der Funktion verwendet werden sollen, zum anderen “Optionen”, die die Funktion berücksichtigen soll. Die Funktion round(), die numerische Werte rundet, beispielsweise hat zwei Argumente: x: ein numerischer Vektor, der gerundet werden soll. digits: ein Integer, der angibt, auf wie viele Dezimalstellen gerundet werden soll. Der vollständige Funktionsaufruf läuft dementsprechend in der Form round(x, digits) ab: round(pi, 1) # Die Kreiszahl Pi ist direkt als Objekt in R hinterlegt round(pi, 3) ## [1] 3.1 ## [1] 3.142 3.1.1.1 Funktionsargumente übergeben Funktionsargumente können auf zwei Arten übergeben werden: zum einen implizit, wie im obigen Beispiel, durch die Reihenfolge der Funktionsargumente; zum anderen explizit über den Namen des Funktionsarguments in der Form argument = wert: round(pi, 2) round(pi, digits = 2) ## [1] 3.14 ## [1] 3.14 In diesem Fall macht es keinen Unterschied, ob wir explizit digits = angeben oder nicht. In der Praxis ist es jedoch üblich, maximal die ersten ein oder zwei Funktionsargumente unbenannt zu übergeben, alle anderen Argumente jedoch benannt zu übergeben. Gerade bei Funktionen mit vielen Argumenten müssen Sie so zum einen nicht die exakte Reihenfolge der Argumente einhalten, zum anderen wird ihr Code auch für andere nachvollziehbarer und lesbarer. Schauen wir uns hierzu als zweites Beispiel die schon bekannte mean()-Funktion an und nutzen sie mit einigen zusätzlichen, uns noch nicht bekannten Argumenten. Was passiert wohl hier? mean(iris$Petal.Length, 0.1, TRUE) ## [1] 3.76 Ohne Kenntnis der Funktionsargumente ist dieser Aufruf schwer nachzuvollziehen – wir berechnen wohl den Mittelwert der Variablen Petal.Length im Datensatz iris, aber was bedeutet der Rest? Durchschaubarer wird es, wenn wir die beiden hinteren Argumente mit ihrem Namen übergeben: mean(iris$Petal.Length, trim = 0.1, na.rm = TRUE) ## [1] 3.76 Hier können wir anhand der Argumentnamen Vermutungen anstellen, auch ohne die genaue Funktion zu kennen. trim wird wohl bedeuten, dass ein bestimmter Anteil der Werte getrimmt, also abgeschnitten wird. Tatsächlich gibt trim den Anteil der niedrigsten und höchsten Werte an, der nicht bei der Berechnung berücksichtigt wird – nützlich, um den Einfluss von Ausreißern auf den Mittelwert abzuschwächen. In unserem Fall, trim = 0.1, schließen wir also die untersten und obersten 10% der Werte aus. Mit na.rm = TRUE geben wir an, dass etwaige fehlende Werte NA vor der Berechnung aus dem Vektor entfernt werden sollen (rm steht hier also für “remove”). Die Benennung erlaubt es uns nun auch, die Reihenfolge der Argumente im Funktionsaufruf zu tauschen: mean(iris$Petal.Length, na.rm = TRUE, trim = 0.1) ## [1] 3.76 Natürlich könnten wir auch das erste Argument benennen, aber das verspricht – auch ob des generischen Namens x – keinen zusätzlichen Erkenntnisgewinn und wäre wohl eher Overkill: mean(x = iris$Petal.Length, trim = 0.1, na.rm = TRUE) ## [1] 3.76 Die mittlere Variante – implizite Übergabe des ersten Funktionsarguments, explizite Nennung der weiteren Funktionsargumente – stellt also das gesunde Mittelmaß aus Kürze und Lesbarkeit dar. 3.1.1.2 Default-Werte von Argumenten Wenn die mean()-Funktion drei Argumente besitzt, wie war es uns dann bisher möglich, sie mit nur einem Argument zu übergeben? Funktionsargumente, die eher Optionen als zwingende Voraussetzung für eine Funktion darstellen, haben in R oftmals Default-Werte – Standardwerte, auf die die Funktion zurückgreift, wenn diese nicht im Funktionsaufruf angegeben wurden. So ist es auch bei der mean()-Funktion, die wie folgt definiert ist: mean(x, trim = 0, na.rm = FALSE): x hat keinen Default-Wert und muss daher zwingend angegeben werden. Ohne Angabe von x wird eine Fehlermeldung zurückgegeben. trim hat einen Default-Wert von 0, ohne Angabe von trim werden also keine Werte abgeschnitten. na.rm hat einen Default-Wert von FALSE, standardmäßig werden fehlende Werte also nicht ausgeschlossen. mean() ## Error in mean.default(): Argument &quot;x&quot; fehlt (ohne Standardwert) mean(c(1, 2, 3, NA)) ## [1] NA mean(c(1, 2, 3, NA), na.rm = TRUE) ## [1] 2 In der Regel haben insbesondere Argumente, die eher eine Option denn zwingende Voraussetzung für die Ausführung einer Funktion darstellen, Default-Werte, sodass diese bei der gebräuchlichsten Verwendung weggelassen werden können. 3.1.2 Hilfestellungen zu Funktionen R und RStudio bieten verschiedene Möglichkeiten, Hilfestellungen zu Funktionen anzuzeigen – also z. B. zur Verwendung der Funktion, ihren Argumenten, den zugehörigen Default-Werten usw. Tippen Sie einen Funktionsnamen ein, so macht Ihnen R Vorschläge, welche Funktion Sie meinen könnten. Daneben wird ein Tooltip angezeigt, der die Funktion beschreibt. Geben Sie beispielsweise die Buchstaben rou in ein R-Skript oder die Konsole ein, sollten Sie nach kurzer Zeit eine Auswahl von Funktionen sehen, die mit eben diesen Buchstaben beginnen, darunter an erster Stelle die round()-Funktion. Die anderen vorgeschlagenen Funktionen können Sie mit den Cursortasten ↑ und ↓ wählen. Neben der ausgewählten Funktion wird die Funktionsbeschreibung angezeigt. Drücken Sie nun die tab-Taste, wird nicht nur die Funktion inklusive Klammern () eingefügt; ein Tooltip zeigt Ihnen zudem noch die Argumente am. Im Falle der round()-Funktion sollte round(x, digits = 0) angezeigt werden. Daran sehen Sie, dass round() zwei Argumente annimmt – ein Argument x ohne Default-Wert und ein Argument digits mit dem Default-Wert 0 – ohne Angabe des digits-Arguments rundet round() also standardmäßig auf ganze Zahlen ohne Nachkommastellen. Oftmals benötigen Sie jedoch noch mehr Informationen zu einer Funktion. In diesem Fall können Sie vor einen beliebigen Funktionsnamen ein ? stellen und ausführen – dieser Befehl öffnet die Dokumentationsseite der jeweiligen Funktion im Bereich rechts unten in RStudio: ?mean() Dokumentation der mean()-Funktion Dokumentationsseiten in R sind zumeist nach demselben Schema aufgebaut: Beschriftung der Funktion. In Falle von mean() also “Arithmetic Mean”. Description: Kurze Beschreibung der Funktion. Usage: Verwendung der Funktion. Anhand von mean(x, trim = 0, na.rm = FALSE, ...) können wir die Argumente und deren Default-Werte ablesen. Die ... weisen hier auf einen Spezialfall hin, dass bestimmte Objekttypen und Datenstrukturen noch zusätzliche Argumente für die Funktion bereitstellen können – dies braucht uns an dieser Stelle aber nicht weiter zu kümmern. Arguments: Hier werden alle Argumente der Funktion aufgelistet und ausführlicher beschrieben. Wir erfahren im Falle von mean() beispielsweise, welche Objekttypen für x unterstützt werden, was trim bedeutet etc. Value: Hier wird das Resultat, das die Funktion ausgibt, beschrieben. Außerdem können Funktionsdokumentationen noch weitere Abschnitte, beispielsweise Verwendungsbeispiele oder Literaturverweise, enthalten. Es ist daher immer sinnvoll, vor der ersten Verwendung einer Funktion die zugehörige Dokumentation zu konsultieren. 3.2 Eigene Funktionen erstellen Wir wissen nun einiges über Funktionen; tatsächlich reicht unser Wissen sogar schon aus, um eigene Funktionen zu programmieren. Wir beschäftigen uns daher abschließend in diesem Kapitel mit der Frage, warum und wann wir eigene Funktionen schreiben sollten, und schauen uns an, wie wir unseren Code in Funktionen übersetzen und so weiterverwertbar machen. 3.2.1 Funktionen erstellen: wann und warum? Viele Schritte in der Datenaufbereitung und -analye wiederholen sich: oft müssen wir mehrere Variablen transformieren, meistens führen wir zur Deskription die gleichen oder zumindest ähnliche Schritte durch, interessieren uns bei Auswertungsverfahren immer wieder für die gleichen Kennwerte. Funktionen sind das zentrale Element des Programmierens. Im Prinzip handelt es sich bei Funktionen um Code-Fragmente oder Skripte, die durch die Verwendung von “Platzhaltern” (= Variablen, Argumente) so angepasst werden, dass sie immer wieder auf vergleichbare Problemstellungen angewendet werden können. Nehmen wir das Beispiel der Variablendeskription. Wenn wir Daten erhoben haben, sind wir bei metrischen Variablen in der Regel zunächst an den selben Kennwerten interessiert: der Anzahl der Werte, dem arithmetischen Mittel, der Standardabweichung, dem Minimum und Maximum, eventuell noch dem Median oder anderen Perzentilen. Mit unserem bisherigen Wissen (und drei neuer, aber ebenso einfacher Funktionen) können wir diese Kennwerte einzeln anfordern, zum Beispiel für die Variable Sepal.Length im Beispiel-Datensatz iris: length(iris$Sepal.Length) # Anzahl Werte mean(iris$Sepal.Length) # Arithmetisches Mittel sd(iris$Sepal.Length) # Standardabweichung min(iris$Sepal.Length) # Minimum max(iris$Sepal.Length) # Maximum median(iris$Sepal.Length) # Median ## [1] 150 ## [1] 5.843333 ## [1] 0.8280661 ## [1] 4.3 ## [1] 7.9 ## [1] 5.8 Die Ausgabe ist jedoch etwas unübersichtlich. Schöner wird es, wenn wir alle Werte in einem benannten Vektor ablegen: sepal_length_descriptives &lt;- c( n = length(iris$Sepal.Length), M = mean(iris$Sepal.Length), SD = sd(iris$Sepal.Length), Minimum = min(iris$Sepal.Length), Maximum = max(iris$Sepal.Length), Median = median(iris$Sepal.Length) ) sepal_length_descriptives ## n M SD Minimum Maximum Median ## 150.0000000 5.8433333 0.8280661 4.3000000 7.9000000 5.8000000 Das sieht doch gleich übersichtlicher aus – in einem Vektor haben wir alle relevanten Werte gespeichert und können diese auf einen Schlag anzeigen. Nun haben wir im iris-Datensatz aber noch weitere Variablen, die wir ebenfalls auf diese Art beschreiben möchten (ganz zu schweigen von zukünftigen Datensätzen, für deren Variablen diese Beschreibung ebenfalls relevant ist). Wir könnten natürlich den obigen Code für jede weitere Variablen kopieren und den Variablennamen austauschen; das würde aber unser Skript unnötig aufblähen und unübersichtlicher machen. Sobald Sie Code(-Fragmente) mehrfach verwenden möchten, ist daher der Zeitpunkt gekommen, darübernachzudenken, ob es nicht sinnvoll ist, ihn in eine Funktion umzuwandeln. Dies hat einige entscheidende Vorteile: Code ist einfacher wiederzuverwenden. Anstatt mehrerer Codezeilen ist in Zukunft für dasselbe Ergebnis dann nur noch eine Codezeile – der Funktionsaufruf – erforderlich. Skripte werden weniger redundant und dadurch übersichtlicher. Fehlerkorrekturen und Anpassungen werden vereinfacht – möchten wir im obigen Beispiel etwa noch einen weiteren Kennwert (z. B. die Spannweite) ergänzen, müssten wir den Code für jede einzelne Variable erneut anpassen; hätten wir eine entsprechende Funktion, wäre die Anpassung nur einmal im Funktionscode nötig. Schauen wir uns also an, wie wir aus obigen Code eine Funktion erstellen können. 3.2.2 Aufbau und Erstellung von Funktionen Funktionen in R sind ebenfalls Objekte und werden dementsprechend erstellt: indem einem Objektnamen durch den Zuweisungs-Operator &lt;- die Funktion zugewiesen wird. Neben dem Namen haben Funktionen zwei zentrale Komponenten: die Funktionsargumente, wie wir sie auch schon vom Aufruf von eingebauten Funktionen kennen den Body der Funktion, der den Code enthält, den die Funktion ausführt Die Erstellung von Funktionen läuft dabei nach folgendem Schema ab: funktionsname &lt;- function(argument_1, argument_2) { # Body: Code, der ausgeführt wird } Wir weisen also einem Objektnamen ein Funktionsobjekt zu; dies geschieht mit der Funktion function(), wobei wir innerhalb der Klammern die Argumente definieren, die wir im Code der Funktion verwenden möchten. Zwischen zwei geschweiften Klammern {} steht dann der Code, den wir ausführen wollen. Sehen wir uns nochmals unser obiges Beispiel an: sepal_length_descriptives &lt;- c( n = length(iris$Sepal.Length), M = mean(iris$Sepal.Length), SD = sd(iris$Sepal.Length), Minimum = min(iris$Sepal.Length), Maximum = max(iris$Sepal.Length), Median = median(iris$Sepal.Length) ) Um den Code auf eine andere Variable anzuwenden, müssten wir jeweils iris$Sepal.Length ersetzen – z. B. durch iris$Sepal.Width, iris$Petal.Length oder eine Variable aus einem anderen Datensatz. Wir möchten diesen Teil also durch einen Platzhalter ersetzen, den wir dann als Funktionsargument übergeben können. Mit einem generischen Platzhalter, den wir der Einfachheit halber (und vollkommen willkürlich!) als x bezeichnen, sähe der Code also wie folgt aus: descriptives_vector &lt;- c( n = length(x), M = mean(x), SD = sd(x), Minimum = min(x), Maximum = max(x), Median = median(x) ) Zuletzt müssen wir diesen Code nun nur noch als Funktion einem Objekt zuweisen – und dabei unserer Funktionen einen treffenden Namen geben, z. B. descriptives, und dabei x als Funktionsargument definieren: descriptives &lt;- function(x) { # Wir definieren &#39;x&#39; als Argument descriptives_vector &lt;- c( n = length(x), M = mean(x), SD = sd(x), Minimum = min(x), Maximum = max(x), Median = median(x) ) } Einmal ausgeführt, taucht unsere neue Funktion nun in unserer Arbeitsumgebung auf (siehe den Bereich Environment rechts oben in RStudio, in dem descriptives nun unter Functions erscheinen sollte) und wir können Sie auf beliebige Vektoren anwenden: descriptives(iris$Sepal.Length) Nur warum sehen wir keine Ausgabe? Das liegt daran, dass wir noch nicht definiert haben, was die Funktion zurückgeben soll. Wir erstellen derzeit lediglich den Vektor descriptives_vector, machen aber noch nichts mit ihm – ähnlich, wie uns die Konsole noch keine Ausgabe anzeigt wenn wir ein Objekt lediglich zuweisen. 3.2.2.1 Rückgabe-Werte Es gibt zwei Möglichkeiten, die Ausgabe einer Funktion zu definieren: generell wird das zuletzt im Funktionscode ausgegebene Objekt zurückgegeben. Wir könnten also im Funktionscode ganz am Ende noch eine Zeile hinzufügen, in der unser neu erstellter Vektor ausgeben wird, in dem wir einfach den Objektnamen tippen descriptives_vector. mit der speziellen Funktion return() können wir im Funktionscode explizit ein im Funktionscode erstelltes Objekt angeben, das zurückgegeben werden soll. Wir müssen also noch eine kleine Anpassung vornehmen: descriptives &lt;- function(x) { descriptives_vector &lt;- c( n = length(x), M = mean(x), SD = sd(x), Minimum = min(x), Maximum = max(x), Median = median(x) ) return(descriptives_vector) # Oder alternativ: lediglich &#39;descriptives_vector&#39; } Unsere Funktion ist nun flexibel für numerische Vektoren einsetzbar: descriptives(iris$Sepal.Length) ## n M SD Minimum Maximum Median ## 150.0000000 5.8433333 0.8280661 4.3000000 7.9000000 5.8000000 descriptives(iris$Petal.Length) ## n M SD Minimum Maximum Median ## 150.000000 3.758000 1.765298 1.000000 6.900000 4.350000 descriptives(c(1, 2, 3, 4, 5, 6)) ## n M SD Minimum Maximum Median ## 6.000000 3.500000 1.870829 1.000000 6.000000 3.500000 3.2.2.2 Funktionsargumente und Default-Werte Unsere Funktion funktioniert also schon ganz gut; im nächsten Schritt möchten wir sie aber noch verbessern, um auch Problemfälle abzudecken. Schauen wir uns einmal an, was passiert, wenn wir einen numerischen Vektor mit fehlenden Werten übergeben: descriptives(c(1, 2, 3, 4, NA)) ## n M SD Minimum Maximum Median ## 5 NA NA NA NA NA Wir sehen, dass alle Kennwerte (außer der Anzahl der Werte) ebenfalls NA sind. Wir erinnern uns, dass Funktionen wie mean() oder sd() bei vorhandenen fehlenden Werten auch einen fehlenden Wert zurückgeben – es sei denn, wir übergeben zusätzlich das Argument na.rm = TRUE, sodass fehlende Werte vor der Berechnung gelöscht werden. Wir möchten dieses Argument nun auch in unserer Funktion nutzen. Hierzu benötigen wir ein weiteres Funktionsargument, das wir dann als Platzhalter für das na.rm-Argument der jeweiligen Kennwert-Funktionen verwenden können. Aus Konsistenzgründen nennen wir es ebenfalls na.rm: descriptives &lt;- function(x, na.rm) { # Wir fügen ein weiteres Argument &#39;na.rm&#39; hinzu... descriptives_vector &lt;- c( n = length(x), M = mean(x, na.rm = na.rm), # ... und übergeben dessen Wert an SD = sd(x, na.rm = na.rm), # das jeweilige &#39;na.rm&#39;-Argument der Minimum = min(x, na.rm = na.rm), # Kennwert-Funktionen Maximum = max(x, na.rm = na.rm), Median = median(x, na.rm = na.rm) ) return(descriptives_vector) } Wir können unsere Funktion nun auch für Vektoren mit fehlenden Werten verwenden, indem wir analog zu mean(), sd() usw. das Argument na.rm = TRUE übergeben. descriptives(c(1, 2, 3, 4, NA), na.rm = TRUE) ## n M SD Minimum Maximum Median ## 5.000000 2.500000 1.290994 1.000000 4.000000 2.500000 Allerdings ist unsere Funktion nun weniger komfortabel einzusetzen, wenn wir dieses Argument weglassen möchten: descriptives(iris$Sepal.Length) ## Error in mean.default(x, na.rm = na.rm): Argument &quot;na.rm&quot; fehlt (ohne Standardwert) Wie wir unter 3.1.1.2 gesehen haben, haben viele Funktionsargumente, die eher optionalen Charakter aufweisen, Default-Werte. Wir können diese ganz einfach bei der Erstellung definieren, indem wir den Default-Wert per = dem jeweiligen Funktionsargument zuweisen: descriptives &lt;- function(x, na.rm = FALSE) { # Default-Wert für &#39;na.rm&#39; = FALSE descriptives_vector &lt;- c( n = length(x), M = mean(x, na.rm = na.rm), SD = sd(x, na.rm = na.rm), Minimum = min(x, na.rm = na.rm), Maximum = max(x, na.rm = na.rm), Median = median(x, na.rm = na.rm) ) return(descriptives_vector) } Dieser Default-Wert wird nun also immer verwendet, wenn wir das Argument nicht angegeben haben. Unsere Funktion ist somit noch flexibler geworden: descriptives(iris$Petal.Width) ## n M SD Minimum Maximum Median ## 150.0000000 1.1993333 0.7622377 0.1000000 2.5000000 1.3000000 descriptives(c(1, 2, 3, 4, NA)) ## n M SD Minimum Maximum Median ## 5 NA NA NA NA NA descriptives(c(1, 2, 3, 4, NA), na.rm = TRUE) ## n M SD Minimum Maximum Median ## 5.000000 2.500000 1.290994 1.000000 4.000000 2.500000 3.3 Übungsaufgaben Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als ue3_nachname.R ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen. Übungsaufgabe 3.1 Funktionen aufrufen und Dokumentation konsultieren: Die Funktion seq() kann verwendet werden, um Zahlenfolgen zu erstellen. Lesen Sie sich die Dokumentationsseite der Funktion durch. Wie müssen Sie die Funktion aufrufen (und welche Argumente benötigen Sie dafür), um eine Zahlenfolge von 0 bis 100 in 5er-Schritten zu erzeugen? Übungsaufgabe 3.2 Funktionen erstellen: Erstellen Sie eine Funktion fahrenheit_to_celsius, die eine Temperaturangabe in Grad Fahrenheit (als numerischen Wert, also z. B. 80) in Grad Celsius umrechnet und diesen Wert zurückgibt. Die Formel zur Umrechnung von Fahrenheit in Celsius lautet \\(°C = (°F − 32) × 5/9\\). Übungsaufgabe 3.3 Funktionen erstellen für Fortgeschrittene: Käpseles-Aufgabe (optional) Erweitern Sie die in Kapitel 3.2.2.2 erstellte Funktion descriptives um folgende Features: Die Kennwerte sollen um die Anzahl der fehlenden Werte ergänzt werden (dieses Element soll den Namen missing tragen). Hierfür benötigen Sie die Funktion is.na(), die für jeden Wert eines Vektors prüft, ob es sich dabei um NA handelt oder nicht und entsprechend TRUE oder FALSE zurückgibt. Die Funktion soll alle Kennwerte einheitlich auf eine gewünschte Anzahl an Nachkommastellen, standardmäßig auf 2 Nachkommastellen runden. Hier nochmals der bisherige Funktionscode: descriptives &lt;- function(x, na.rm = FALSE) { descriptives_vector &lt;- c( n = length(x), M = mean(x, na.rm = na.rm), SD = sd(x, na.rm = na.rm), Minimum = min(x, na.rm = na.rm), Maximum = max(x, na.rm = na.rm), Median = median(x, na.rm = na.rm) ) return(descriptives_vector) } Da der Funktionsname vor den Argumenten steht, wird hierbei auch von Prefix-Funktionen gesprochen. Wir haben im vorherigen Kapitel auch schon zwei andere Arten von Funktionen kennengelernt: Infix-Funktionen, bei dir der Funktionsname zwischen zwei Argumenten steht (dazu zählen beispielsweise alle arithmetischen Operatoren, z. B. +, -, * und /), und Replacement-Funktionen, die Teile eines bestehenden Objekts direkt verändern (z. B. names(x) &lt;-). Das sind aber Spezialfälle – im Alltag werden wir vorrangig Prefix-Funktionen verwenden.↩ "],
["kontrollstrukturen.html", "4 Kontrollstrukturen 4.1 Bedingungen 4.2 Iterationen 4.3 Übungsaufgaben", " 4 Kontrollstrukturen Mittels Kontrollstrukturen können wir definieren, ob und wie oft Code ausgeführt wird; unterschieden wird hierbei vorrangig zwischen Bedingungen – d. h. Code, der nur ausgeführt wird, wenn eine bestimmte Bedingung erfüllt ist – und Iterationen (wiederholtes ausführen von Code, auch als Schleifen bezeichnet). Bedingungen und Iterationen sind Konzepte, die ebenso wie Funktionen in quasi allen Programmiersprachen zu finden sind. Ziel dieses Kapitels ist es, ein Grundverständnis beider Konzepte zu erlangen; relevant werden diese spätestens, wenn wir über APIs oder Webscraping Daten erheben werden. 4.1 Bedingungen Bedingungen führen Code abhängig davon aus, ob eine definierte Bedingung TRUE oder FALSE ist. 4.1.1 if-Bedingungen Bedingungen werden in R – ebenso wie in vielen anderen Programmiersprachen – über das Schlüsselwort if umgesetzt, dem eine in runde Klammern () gesetzte, logische Bedingung folgt. Wie auch bei Funktionen wird der bedingt auszuführende Code in geschweifte Klammern gesetzt {}: if (bedingung) { # Code der ausgeführt wird, wenn bedingung = TRUE ist } Die bedingung muss dabei in dem Objekttypen logical (also TRUE oder FALSE, siehe Kapitel 2.2.3) resultieren; in den meisten Fällen wird daher ein logischer Vergleich in den Klammern () durchgeführt: x &lt;- 2 aktion &lt;- &quot;verdoppeln&quot; if (aktion == &quot;verdoppeln&quot;) { x &lt;- x * 2 } x ## [1] 4 4.1.2 if-else-Bedingungen Mit dem Schlüsselwort else können wir anschließend einen Codeblock definieren, der ausgeführt werden soll, wenn die Bedingung nicht zutrifft: punktzahl &lt;- 45 if (punktzahl &gt; 50) { status &lt;- &quot;bestanden&quot; } else { status &lt;- &quot;nicht bestanden&quot; } status ## [1] &quot;nicht bestanden&quot; 4.1.3 Bedingungen verketten Durch die Kombination von else und if können wir auch beliebig viele Bedingungen hintereinander prüfen: steak_temperatur &lt;- 56 if (steak_temperatur &lt; 45) { garstufe &lt;- &quot;raw&quot; } else if (steak_temperatur &lt; 53) { garstufe &lt;- &quot;rare&quot; } else if (steak_temperatur &lt; 57) { garstufe &lt;- &quot;medium rare&quot; } else if (steak_temperatur &lt; 63) { garstufe &lt;- &quot;medium&quot; } else { garstufe &lt;- &quot;well done&quot; } garstufe ## [1] &quot;medium rare&quot; 4.1.4 Mehrere Bedingungen Mittels Boolescher Operatoren können wir mehrere Bedingungen miteinander verknüpfen, um etwa zu prüfen ob alle Bedingungen zutreffen (UND-Verknüpfung), mindestens eine Bedinung zutrifft (ODER-Verknüpfung), oder das Gegenteil einer Bedingung zutrifft (NICHT-Verknüpfung). Die gebräuchlichsten Operatoren sind: Tabelle 4.1: Boolesche Operatoren in R Operator Verknüpfung Beispiele &amp; und 1 == 1 &amp; 2 == 2 ergibt TRUE1 == 1 &amp; 1 == 3 ergibt FALSE | oder 1 == 1 | 2 == 2 ergibt TRUE1 == 1 | 1 == 3 ergibt TRUE ! nicht !(1 == 1) ergibt FALSE (! wird der Bedingung vorangestellt)!(1 == 3) ergibt TRUE Als Beispiel verknüpfen wir die Bedingungen für ein Schaltjahr. Damit ein Jahr ein Schaltjahr ist, müssen folgende Bedingungen erfüllt sein: Die Jahreszahl ist durch 400 teilbar ODER Die Jahreszahl ist durch 4 teilbar UND ist gleichzeitig NICHT durch 100 teilbar. Ob eine Zahl durch eine andere Zahl teilbar ist, können wir mit dem Modulo-Operator %% prüfen, der den ganzzahligen Rest der Division ausgibt – mit anderen Worten: wenn das Ergebnis der Modulo-Operation 0 ist, dann ist Zahl 1 durch Zahl 2 teilbar, ansonsten nicht. year &lt;- 2020 year %% 400 == 0 | (year %% 4 == 0 &amp; !(year %% 100 == 0)) # Natürlich könnten wir hinten auch prüfen, ob year %% 100 != 0 ist und # nur die UND-Verknüpfung nutzen, aber ich wollte alle drei Booleschen # Operatoren in einer Prüfung unterbringen ## [1] TRUE Oder als Funktion verpackt: is_leap_year &lt;- function(year) { year %% 400 == 0 | (year %% 4 == 0 &amp; !(year %% 100 == 0)) } is_leap_year(c(1900, 2000, 2016, 2018, 2020)) ## [1] FALSE TRUE TRUE FALSE TRUE 4.1.5 Mehrere Prüfwerte Oft wollen wir prüfen, ob ein Wert zu einer Reihe an Werten gehört – beispielsweise wenn wir Werte kategorisieren möchten. Wir können dies mit einer ODER-Verknüpfung erreichen: food &lt;- &quot;Banane&quot; if (food == &quot;Apfel&quot; | food == &quot;Orange&quot; | food == &quot;Banane&quot;) { food_category &lt;- &quot;Obst&quot; } Allerdings wird diese Verknüpfung schnell umständlich, wenn wir viele Prüfwerte haben, im Beispiel also nicht nur 3 Obstsorten, sondern 5, 10 oder 123. Hier hilft uns der Operator %in%, der testet, ob ein Wert in einem Vektor an Werten vorhanden ist: &quot;Banane&quot; %in% c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Zitrone&quot;, &quot;Mango&quot;, &quot;Kumquat&quot;) ## [1] TRUE Das funktioniert auch mit mehreren Werten auf der linken Seite der Prüfung: c(&quot;Banane&quot;, &quot;Mango&quot;, &quot;Leberkäse&quot;) %in% c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Zitrone&quot;, &quot;Mango&quot;, &quot;Kumquat&quot;) ## [1] TRUE TRUE FALSE Und natürlich können wir den Prüfvektor vorab zuweisen: obstsorten &lt;- c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Zitrone&quot;, &quot;Mango&quot;, &quot;Kumquat&quot;) food &lt;- &quot;Kumquat&quot; if (food %in% obstsorten) { food_category &lt;- &quot;Obst&quot; } else { food_category &lt;- &quot;Kein Obst&quot; } food_category ## [1] &quot;Obst&quot; 4.2 Iterationen Mittels Iterationen führen wir ein Code-Fragment wiederholt für verschiedene Input-Objekte aus. R bietet viele unterschiedliche Möglichkeiten für Iterationen – für den Anfang genügen wir uns mit vektorisierten Funktionen, for-Loops und while-Loops: 4.2.1 Vektorisierte Funktionen Tatsächlich haben wir unbewusst bereits mehrfach mit Iterationen gearbeitet, indem wir vektorisierte Funktionen eingesetzt haben – Funktionen, die automatisch auf jedes Element eines Vektors angewendet werden. Dazu zählen beispielsweise alle arithmetischen Operatoren und nahezu alle Funktionen in der Basis-Version von R: zahlen &lt;- c(5, 10, 42) zahlen - 10 zahlen * 3 log(zahlen) # Berechnet den natürlichen Logarithmus tolower(c(&quot;Text 1&quot;, &quot;TEXT 2&quot;, &quot;TEXT DREI&quot;)) # wandelt Text in Kleinbuchstaben um ## [1] -5 0 32 ## [1] 15 30 126 ## [1] 1.609438 2.302585 3.737670 ## [1] &quot;text 1&quot; &quot;text 2&quot; &quot;text drei&quot; Wir haben außerdem in Kapitel 2.3.1.3 gesehen, dass wir so auch mit zwei gleichlangen Vektoren effizient rechnen können: c(2, 3, 4) * c(2, 5, 10) ## [1] 4 15 40 Was passiert, wenn beide Vektoren nicht gleichlang sind? Hier tritt eine Eigenschaft von R zu Tage, die sich Recycling nennt: Ist der längere Vektor durch den kürzeren Vektor teilbar, wiederholt R den kürzeren Vektor einfach entsprechend oft: c(2, 4) * c(2, 3, 5, 10) ## [1] 4 12 10 40 Ist das nicht der Fall, produziert R hingegen eine Fehlermeldung: c(2, 4) * c(2, 3, 5) ## Warning in c(2, 4) * c(2, 3, 5): Länge des längeren Objektes ## ist kein Vielfaches der Länge des kürzeren Objektes ## [1] 4 12 10 4.2.2 for-Loops for-Loops führen (beliebig viele Zeilen) Code für jedes Element eines Vektors durch. Die Grundform eines for-Loops sieht wie folgt aus: for (element in vektor) { # Body: Code, der ausgeführt wird } element ist hierbei ein Objekt, dem nach jeder Ausführung des Codes in den geschweiften Klammern {} das nächste Element aus dem angegebenen Vektor zugewiesen wird. Wir können dem Element einen beliebigen Objektnamen geben und es dann ähnlich wie in Funktionen als Platzhalter im Loop-Code verwenden. Für einfache Loops wird meistens der Objektname i verwendet: zahlen &lt;- 1:5 for (i in zahlen) { neue_zahl &lt;- i * i - 1 print(neue_zahl) # print() schreibt ein Objekt in den Konsolenoutput } ## [1] 0 ## [1] 3 ## [1] 8 ## [1] 15 ## [1] 24 Nutzen wir ein etwas anwendungsbezogeneres Beispiel. Nehmen wir an, wir möchten den Mittelwert aller (numerischen) Variablen in einem Datensatz ausgeben. Wir könnten die mean()-Funktion natürlich einfach händisch für jede Variable anfordern: mean(iris$Sepal.Length) mean(iris$Sepal.Width) mean(iris$Petal.Length) # usw. ## [1] 5.843333 ## [1] 3.057333 ## [1] 3.758 Im Falle von iris bei nur vier numerischen Variablen wäre das noch problemlos möglich, bei längeren Datensätzen hätten wir aber schnell sehr viel zu tun – und in allen Fällen produzieren wir sehr viel redundanten Code. Eleganter lösen wir das mit einem for-Loop und einem Vektor, der alle uns interessierenden Variablennamen enthält: variablen &lt;- c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;) mittelwerte &lt;- c() for (variable in variablen) { mittelwerte[variable] &lt;- mean(iris[[variable]]) } mittelwerte ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 Was passiert hier? Wir erstellen einen Vektor mit den uns interessierenden Variablen variablen sowie einen leeren Vektor mittelwerte. Der for-Loop beginnt: variable bekommt das erste Element aus variablen, also \"Sepal.Length\" zugewiesen. Dann wird der Code in den geschweiften Klammern {} ausgeführt: iris[[variable]] extrahiert aus dem iris-Datensatz die Spalte mit dem Namen, der in variable gespeichert ist – aktuell also \"Sepal.Length\". (Wir kennen bisher nur einfache eckige Klammern [] zur Extraktion; dabei wird der Objekttyp data.frame beibehalten und wir können auch mehrere Variablen extrahieren. Mit den doppelten eckigen Klammern [[]] wird hingegen nur eine einzige Variable extrahiert und in den Objekttyp vector umgewandelt. Diesen Objekttypen benötigen wir für die mean()-Funktion.) Wir berechnen davon den Mittelwert mittels mean(). Der Vektor mittelwerte erhält ein Element mit dem Namen, der in variable gespeichert ist – aktuell also ebenfalls \"Sepal.Length\". Diesem Element weisen wir den berechneten Mittelwert zu. Der Loop ist nun einmal durchlaufen und beginnt von vorne. Dabei wird variable nun das zweite Element von variablen, “Sepal.Width”, zugewiesen. Dann wird der Code in den geschweiften Klammern erneut ausgeführt. Diese Schritte werden so oft wiederholt, bis wir am Ende von variablen angekommen sind und jedes Element aus variablen einmal variable zugewiesen wurde. Als Resultat erhalten wir einen benannten Vektor mittelwerte, der alle Mittelwerte enthält. Mittels for-Loops können wir also sehr schnell Teile unseres Codes automatisieren und als Grundprinzip finden sich for-Loops in nahezu allen Programmiersprachen. Wir werden jedoch in Kürze noch Funktionen kennenlernen, die uns Iterationen nochmals deutlich komfortabler gestalten. 4.2.3 while-Loops Bei for-Loops wissen wir vorab, wie oft der Loop ausgeführt wird – nämlich für jedes Element, das der Vektor, über den wir loopen, enthält. Manchmal ist es uns aber nicht vorab bewusst, wie oft ein Loop ausgeführt werden soll. In diesem Fall können wir while-Loops verwenden, die so lange ausgeführt werden, wie eine Bedingung als TRUE erfüllt ist: while (bedingung) { # Body: Code, der ausgeführt wird } Entsprechend benötigen wir eine Bedingung, die bei jeder Iteration wieder überprüft wird. Das Prüfkriterium sollten wir also im Body des Loops auch anpassen, da der Loop sonst unendlich läuft. Als Beispiel schreiben wir einen Loop, der in 5er-Schritten von 50 bis 100 zählt: x &lt;- 50 while (x &lt;= 100) { print(x) x &lt;- x + 5 } ## [1] 50 ## [1] 55 ## [1] 60 ## [1] 65 ## [1] 70 ## [1] 75 ## [1] 80 ## [1] 85 ## [1] 90 ## [1] 95 ## [1] 100 Was passiert hier? Wir weisen x den Ausgangswert 50 zu. Der while-Loop beginnt. Wir prüfen zunächst ob x kleiner gleich 100, was aktuell der Fall ist. Dann wird der Code ausgeführt: Wir schreiben zunächst den aktuellen Wert von x in die Konsole. Dann addieren wir 5 zu x. x ist nun 55. Der Loop ist nun einmal durchlaufen und beginnt von vorne. Erneut wird geprüft, ob x kleiner gleich 100 ist. Dies ist weiterhin der Fall, der Code wird also erneut ausgeführt. Dies wird so lange wiederholt, bis die Bedingung nicht mehr erfüllt ist. Dies geschieht, nachdem 100 in die Konsole geschrieben wurde, da danach auf x nochmals 5 addiert werden und x am Ende des Loops folglich 105 ist. Die nächste Prüfung 105 &lt;= 100 resultiert in FALSE, der Loop wird abgebrochen. Einen häufigen Anwendungsfall für while-Loops lernen wir kennen, sobald wir mit APIs arbeiten. Wollen wir etwa Tweets zu einem bestimmten Hashtag herunterladen, wissen wir vorab nicht, um wie viele Tweets es sich handelt. Mit einem while-Loop könnten wir daher festlegen, dass wir den Code zum Tweets-aus-der-API-ziehen ausführen, bis diese keine weiteren zurückgibt. Herzlichen Glückwunsch, Sie beherrschen nun die zentralen Grundlagen von R (und fast jeder anderen Programmiersprache) und könnten theoretisch alle weiteren Funktionen von Hand schreiben. In der Praxis wurde aber vermutlich so gut wie jedes Problem, das Ihnen im datenanalytischen Kontext begegnet, schon von jemand anderem gelöst. Wir schauen uns also als nächstes an, wie wir auf Funktionen von anderen in Form von Packages zugreifen können. 4.3 Übungsaufgaben Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als ue4_nachname.R ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen. Übungsaufgabe 4.1 Bedingungen: Wir haben in einer Studie das Nachrichtennutzungsverhalten erhoben und möchten dieses nun basierend auf zwei Variablen in einer neuen Variablen news_category kategorisieren: Falls in der Variable news_channel nicht \"Internet\" angeben wurde, soll die neue Variable news_category den Wert \"Offline\" lauten. Falls dort “Internet” angegeben wurde, steht eine weitere Unterteilung an: Falls in news_website die Werte \"Twitter\", \"Facebook\" oder \"Instagram\" angegeben wurden, soll news_category den Wert \"Online: SNS\" haben. Bei allen anderen Werten von news_website soll news_category den Wert \"Online: Sonstige\" bekommen Bilden Sie im folgenden Codebeispiel diesen Entscheidungsbaum mit Bedingungen nach: news_channel &lt;- &quot;Internet&quot; news_website &lt;- &quot;Facebook&quot; # Ihr Code hier # # _._ _,-&#39;&quot;&quot;`-._ # (,-.`._,&#39;( |\\`-/| # `-.-&#39; \\ )-`( , o o) # `- \\`_`&quot;&#39;- # # (Diese Katze sieht in R kopiert besser aus als hier in der Webansicht) news_category # Wenn alles geklappt hat, sollte &quot;Online: SNS&quot; herauskommen Übungsaufgabe 4.2 Iterationen: Vervollständigen Sie in der folgenden Funktion alle Platzhalter ___, sodass diese für alle numerischen Variablen eines Datensatzes Mittelwert und Standardabweichung ausgibt: numeric_summary &lt;- function(data) { # Alle Variablennamen in Vektor speichern variables &lt;- names(data) # Leere Liste für Ausgabe vorbereiten summary_list &lt;- list() # Über alle Variablen iterieren ___ (___) { # Hier die ___ ersetzen variable_vector &lt;- data[[___]] # Und hier ebenfalls if (is.numeric(variable_vector)) { # Prüfen ob die Variable numerisch ist # Mittelwert und Standardabweichung dieser Variablen der summary_list hinzufügen summary_list[[___]] &lt;- c( # Hier wieder die ___ ersetzen M = mean(variable_vector), SD = sd(variable_vector) ) } } # Summary List ausgeben return(summary_list) } Testen Sie die fertige Version mit den iris- und mtcars-Datensätzen. "],
["packages.html", "5 Packages 5.1 Packages installieren 5.2 Packages nutzen", " 5 Packages Bereits mit der Basisversion von R kommen wir schon recht weit. Der Erfolg von R geht aber nicht zuletzt darauf zurück, dass sich die Basisversion sehr einfach durch Packages erweitern lässt. Dabei handelt es sich um Sammlungen von Funktionen, deren Dokumentation und Zusatzinhalten (z. B. Beispieldaten), die R beispielsweise um neue Analyse- und Erhebungsverfahren erweitern oder bestehende Funktionalitäten vereinfachen. Auf CRAN, dem Comprehensive R Archive Network – Sie erinnern sich, von dort haben Sie auch R installiert –, stehen aktuell rund 15.500 Packages zur Verfügung, die so ziemlich jede Funktionalität abdecken, die man sich wünschen kann. 5.1 Packages installieren Packages lassen von sich von CRAN sehr einfach direkt in R bzw. RStudio über die Funktion install.packages(\"package_name\") installieren. Mit folgendem Befehl installieren wir beispielsweise das Paket tibble: install.packages(&quot;tibble&quot;) R lädt automatisch die benötigten Dateien (und Packages, sollte das gewünschte Package andere Packages voraussetzen) herunter und installiert diese, sodass Sie meist nach wenigen Sekunden mit dem Package arbeiten können. Einmal installierte Packages bleiben Ihnen erhalten, bis Sie den Computer wechseln oder zu einer neuen R-Version (siehe nächstes Kapitel) wechseln. 5.2 Packages nutzen Packages werden über die Funktion library(package_name) für die aktuelle R-Session geladen, sodass Sie auf die enthaltenen Funktionen zugreifen können. Es bietet sich daher an, die library()-Befehle immer ganz oben in ein R-Skript zu schreiben, da von ihnen dann die Funktionalität des restlichen Skripts abhängig ist. Laden wir einmal das tibble-Package: library(tibble) Was kann dieses Package nun? In der Regel haben wir davon natürlich schon eine Vorstellung, da wir das neue Package vermutlich über eine Google-Suche nach dessen Funktionalität gefunden haben (ganz allgemein funktioniert eine Suche nach “R + [Name des gesuchten Verfahrens]” meist gut). Wie auch bei den Basis-Funktionen können wir auch bei Funktionen aus Packages über ein vorangestelltes ? die Dokumentationsseite der jeweiligen Funktion anzeigen. Viele Packages kommen zudem mit einer oder mehreren Vignetten, längeren Dokumentationen, die die Funktionen eines Packages genauer erläutern, oft mit Anwendungsbeispielen. Wir können diese Vignetten über den Befehl vignette() öffnen, wobei wir dafür den Namen der Vignette kennen müssen – viele Packages bieten daher eine Vignette an, die nach dem Package selbst benannt ist. Alternativ öffnet sich über browseVignettes(\"package_name\") in einem Webbrowser eine Übersicht über alle Vignetten, die zu einem bestimmten Package gehören. Öffnen wir einmal die Vignette unseres neues Packages tibble: vignette(&quot;tibble&quot;) Wir erfahren also, dass das tibble-Package einen “modern take on data frames” einführt. Neben einigen technischen Details zeichnen sich “Tibbles” vor allem durch eine schickere Darstellung in der R-Konsole aus. Schauen wir uns das doch einmal an – die Funktion, um einen Dataframe in ein Tibble umzuwandeln lautet as_tibble(): as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows Im Gegensatz zu Dataframes sehen wir auf den ersten Blick folgende Unterschiede: Wir erhalten zunächst eine Zeile mit den Dimensionen des Datensatzes: A tibble: 150 x 5 Unter der Kopfzeile sind die Objekttypen der jeweiligen Spalten aufgelistet, hier also dbl (für double) und fct (für factr). Standardmäßig werden nur die ersten 10 Zeilen des Datensatzes angezeigt, sodass uns bei langen Datensätzen nicht die Konsole vollläuft. hier nicht sichtbar: negative Zahlen und fehlende Werte werden farbig hervorgehoben Wir werden zukünftig viel mit Tibbles arbeiten, doch nun erst einmal zurück zur Package-Nutzung: Bisweilen lohnt es sich nicht, das gesamte Package zu laden, da Sie nur einmal eine einzige Funktion daraus benötigen. In diesem Fall lassen sich die Funktionen installierter Packages auch ohne library() nutzen, indem die Funktion über das Format package_name::funktionsname() aufgerufen wird: tibble::as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows Dies ist vor allem dann sinnvoll, wenn Sie in einem Skript viele verschiedene Packages nutzen: Da es durchaus vorkommen kann, dass mehrere Packages denselben Funktionsnamen nutzen, kann das Laden vieler unterschiedlicher Packages dazu führen, dass die eigentlich gewünschte Funktion aus Package 1 durch eine gleichnamige Funktion aus Package 2 “überschrieben” wird – eine häufige Fehlerquelle. "],
["workflow.html", "6 Workflow 6.1 Arbeitsverzeichnisse 6.2 Projekte und Ordnerstrukturen 6.3 R Markdown 6.4 R aktuell halten", " 6 Workflow Zum Abschluss der Einführung in die Grundlagen von R schauen wir uns noch einige Möglichkeiten an, effizient(er) mit R und RStudio arbeiten zu können. 6.1 Arbeitsverzeichnisse Abgesehen von den Skripten für die Übungsaufgaben haben wir bisher noch nicht mit Dateien gearbeitet. In Zukunft sieht dies natürlich anders aus: wir laden Datensätze auf unserer Festplatte, erstellen Skripte und speichern unsere Ergebnisse, z. B. in Form von Tabellen oder Abbildungen. Sobald wir daher mit Dateien arbeiten, wird das Konzept des Arbeitsverzeichnisses relevant, da R basierend auf diesem nach Dateien sucht. Unser aktuelles Arbeitsverzeichnis können wir mit dem Befehl getwd() (für working directory) anzeigen. Nehmen wir einmal an, unser Arbeitsverzeichnis lautet C:/Projekte/R. R wird nun Pfadangaben zu Dateien relativ zu diesem Verzeichnis betrachten. Eine Datensatz-Datei beispiel.csv, die in diesem Verzeichnis liegt (deren gesamter Dateipfad also C:/Projekte/R/beispiel.csv ist), könnten wir mit der Funktion read.csv(), die zum Einlesen von CSV-Dateien verwendet wird, daher über read.csv(\"beispiel.csv\") laden. Läge die Datei in einem Unterordner data (wäre der vollständige Dateipfad also C:/Projekte/R/data/beispiel.csv), müssten wir entsprechend read.csv(\"data/beispiel.csv\") angeben. Gleiches gilt auch für Dateien, die wir mit R erstellen – geben wir keinen weiteren Pfad an, so landen diese im Hauptordner des aktuellen Arbeitsverzeichnisses. Umgekehrt bedeutet dies auch, dass es umständlich wird, Dateien zu laden, die außerhalb unseres Arbeitsverzeichnisses (also im Beispiel in einem anderen Ordner auf C:) liegen. Zwar kann immer auch der gesamte Dateipfad angegeben werden (z. B. read.csv(\"C:/Projekte/R/data/beispiel.csv\")), das hat aber die Nachteile, dass Sie immer sehr viel tippen müssen und vor allem, dass Ihre Skripte nur noch auf Ihrem eigenen Rechner laufen, da Sie auf anderen Rechnern mit hoher Wahrscheinlichkeit auch eine andere Ordnerstruktur haben. Es ist daher wichtig, sich a) eine sinnvolle Ordnerstruktur zu überlegen und b) sicherzustellen, dass R auch das korrekte Arbeitsverzeichnis nutzt. Das Arbeitsverzeichnis kann mit der Funktion setwd() festgelegt bzw. geändert werden – allerdings bietet R-Studio noch eine Funktionalität, die das nochmals deutlich erleichert: 6.2 Projekte und Ordnerstrukturen RStudio bietet mittels Projekten eine einfache Möglichkeit, alle relevanten Projektdateien zusammenzuhalten und das Arbeitsverzeichnis automatisch zu setzen. Projektdateien (Dateieindung .rproj) sind prinzipiell nichts weiter als “Markierungen” für RStudio, dass es sich bei einen Ordner auf der Festplatte (und den darin enthaltenen Dateien) um ein Analyseprojekt mit R handelt. Erstellen wir also unser erstes R-Projekt für diesen Kurs: Klicken Sie in RStudio auf File - New Project und wählen Sie im sich nun öffnenden Fenster New Directory und anschließend New Project aus. Im folgenden Fenster können Sie Ihrem Projekt einen sinnvollen Namen (z. B. “R-Kurs”) geben und das Verzeichnis auswählen, in dem Ihr Projekt erstellt werden soll (RStudio erzeugt darin einen Unterordner mit dem Namen des Projekts): Schließen Sie nun RStudio und navigieren zu dem Projektordner auf Ihrer Festplatte. Durch einen Doppelklick auf die .rproj-Datei öffnet sich RStudio mit diesem Projekt; das Arbeitsverzeichnis wird automatisch auf den Hauptordner des Projektes gesetzt, der Files-Browser im rechten unteren Bildschirmbereich zeigt ebenfalls dieses an. Am rechten oberen Bildschirmrand wird Ihnen außerdem das aktuelle Projekt angezeigt – bearbeiten Sie mehrere Projekte gleichzeitig, können Sie hier auch direkt von einem Projekt in ein anderes wechseln (oder sogar mehrere gleichzeitig in unterschiedlichen RStudio-Sessions öffnen). Auswahl von Projekten in RStudio Schließlich ist nun auch ein guter Zeitpunkt, sich eine Ordnerstruktur zu überlegen. Ich persönlich lege (nummerierte) Skriptdateien meist direkt im Hauptordner des Projektes ab, speichere alle relevanten Datensätze in einem Unterordner data, und alle Ergbnisse in entsprechend benannten Unterordnern (z. B. tables und figures). Finden Sie hier vor allem eine Struktur, in der Sie sich – und im besten Falle auch andere, wenn Sie Daten aus einem Projekt anderen zur Verfügung stellen – intuitiv zurechtfinden. Ein – besonders für meine Verhältnisse – gut aufgeräumter Projektordner 6.3 R Markdown R Markdown ist ein Dateiformat (Endung: .Rmd) von RStudio, das es erlaubt, Code, Ergebnisse und freien Text in nur einem Dokument zu kombinieren. Es ist dementsprechend gut geeignet, um Analyseschritte und die dahinterstehenden Entscheidungen und Gedanken festzuhalten. Zudem können solche Dokumente schnell in andere Dokumenttypen – z. B. HTML-Websiten, PDF-Dateien oder Word-Dokumente – umgewandelt werden. Ein R Markdown-Dokument mit Text, Code und Ergebnissen – in diesem Fall – Grafiken …und dasselbe Dokument als HTML-Seite konvertiert Wir erstellen R-Markdown-Dokumente über File - New File - R Markdown. Im folgenden Fenster können wir einen Dokumenttitel, Ausgabeformat usw. einstellen – all dies lässt sich aber auch später noch bearbeiten, sodass Sie fürs erste die Standardeinstellungen übernehmen können. Die erzeugte Datei ist bereits mit etwas Beispieltext gefüllt und besteht aus drei Komponenten: 6.3.1 YAML-Header Ganz oben steht ein (optionaler) Block in der Auszeichnungssprache YAML (für Yet Another Markdown Language), abgetrennt durch ---, der die Outputoptionen festlegt. --- title: &quot;Auswertung&quot; author: &quot;Julian Unkel&quot; date: &quot;4/29/2020&quot; output: html_document --- Je nach Ausgabeformat können hier noch weitere Optionen angegeben werden, beispielsweise ob automatisch ein Inhaltsverzeichnis erzeugt werden soll. Auch hier reichen die Standardeinstellungen fürs erste jedoch vollkommen aus. 6.3.2 Freitext in Markdown Freier Text kann jeder Stelle in das Dokument eingefügt werden. Dabei nutzt das Format die Formatierungssyntax Markdown (daher auch der Dateiformatname), mit der sich Text schnell mittels bestimmter Symbole formatieren lässt. Die Grundidee dahinter ist, dass man sich beim Schreiben auf das Schreiben konzentriert und alle wesentlichen Formatierungen im Nachhinein automatisiert auf Basis von Vorlagen erfolgen. Einige Formatierungsoptionen sind: Tabelle 6.1: Einige Formatierungsoptionen in R Markdown Syntax Erzeugt Klartext Klartext _kursiv_*kursiv* kursivkursiv __fett__**fett** fettfett # Überschrift## Überschrift### Überschrift Überschrift erster EbeneÜberschrift zweiter EbeneÜberschrift dritter Ebene - Listenpunkt 1- Listenpunkt 2 - Listenpunkt 1- Listenpunkt 2 1. nummerierte Liste2. Listenpunkt 2 1. nummerierte Liste2. Listenpunkt 2 Ein gelungener Spickzettel für R Markdown findet sich zudem hier. 6.3.3 Code Chunks R-Code kann in speziellen Blöcken hinzugefügt werden, die durch ```{r} (und einem optionalen Namen hinter r) eingeleitet werden und abschließend ``` begrenzt werden. Alles innerhalb dieser Blöcke (“Chunks”) wird als R-Code interpretiert. Einfacher können R-Code-Chunks mit der Tastenkombination Strg/Cmd + Alt + I eingefügt werden. Einzelne Codezeilen können wie gehabt mit Strg/Cmd + Enter/Return ausgeführt werden; mittels Strg/Cmd + Shift + Enter/Return oder durch Klick auf den grünen “Play”-Knopf am rechten oberen Ende des Chunks wird der gesamte Code des Chunks auf einmal ausgeführt. Die Besonderheit dabei ist, dass das Ergebnis direkt unter dem Chunk – und nicht in der Konsole – angezeigt wird, sodass Sie Code damit auch sehr schön gliedern können. Die Codebeispiele in der erzeugten R-Markdown-Datei verdeutlichen dies – einzelne Werte, Tabellen und auch Grafiken können so direkt in dem Dokument angezeigt werden. 6.3.4 Ausgabedateien erzeugen Mit einem Klick auf den “Knit”-Knopf (mit Stricksymbol) am oberen Rand wird die im Header definierte Ausgabedatei erzeugt – standardmäßig also eine HTML-Datei, die im Arbeitsverzeichnis abgelegt wird und mit jedem Browser geöffnet werden kann. Auch dies können Sie einmal mit dem Beispielcode ausprobieren. Diese Einführung kann nicht alle Ausgabeformate in Detail ansprechen – hier gibt es aber inzwischen vielfältige Möglichkeiten, die quasi den gesamten wissenschaftlichen Prozess abdecken, aber natürlich auch etwas Einarbeitung erfordern: mittels spezieller Packages lassen sich so unter anderem Präsentationen, PDF-Berichte (inklusive Literaturverwaltung und automatischer Formatierung von Ergebnistabellen nach gängigen wissenschaftlichen Standards) oder ganze Webseiten erstellen (auch dieser Kurs bzw. diese Website ist komplett in R Markdown erstellt). Übungsaufgaben können Sie zukünftig sowohl als R-Skript (.R) als auch als R Markdown (.Rmd) abgeben. Illustration von @allison_horst: https://twitter.com/allison_horst 6.4 R aktuell halten Wie bei jeder anderen Software auch sollte die Arbeitsumgebung in R durch regelmäßige Updates aktuell gehalten werden, um neue Features, Fehlerkorrekturen, Performance-Verbesserungen und Beseitigungen von Sicherheitslücken zu erhalten. Da wir mit unterschiedlichen Komponenten – R, RStudio und jeder Menge Packages – arbeiten, müssen all diese Komponenten auch getrennt geupdated werden. 6.4.1 Packages aktualisieren Am häufigsten sollten Sie Ihre installierten Packages aktualisieren. Dies geht in RStudio sehr komfortabel über Tools - Check for Package Updates, wodurch alle Packages angezeigt werden, für die Updates bereitstehen. Nach einer Auswahl der gewünschten Packages können Updates gesammelt über den Button Install Updates heruntergeladen und installiert werden. Um nur ein einzelnes Packages zu aktualisieren, kann dieses auch einfach über die Funktion install.packages(\"package_name\") mit der aktuellsten Version neu installiert werden. 6.4.2 RStudio aktualisieren Auch RStudio kann direkt aus dem Programm heraus aktualisiert werden. Hier empfiehlt es sich, regelmäßig unter Help - Check for Updates zu überprüfen, ob eine Aktualisierung bereitsteht. 6.4.3 R aktualisieren Etwas unkomfortabler ist es, R selbst zu aktualisieren. Dass eine neue Version bereitsteht, erfährt man häufig dadurch, dass Packages beim Laden darauf aufmerksam machen, dass Sie mit einer aktuelleren Version von R als der aktuell installierten erstellt wurden. Das liest sich in der Konsole dann so: Warning message: package ‘package_name’ was built under R version x.x.x Das Updaten funktioniert dabei ebenso wie eine Neuinstallation, wie sie in Kapitel 1.1 beschrieben wurde – RStudio sollte die neue R-Version dann automatisch erkennen (die aktuell installierte R-Version wird stets beim Starten von R/RStudio in der Konsole angezeigt). Dabei ist zu beachten, dass installierte Packages nicht von einer R-Version zur nächsten kopiert werden; es ist also entweder manuelles Kopieren oder eine Neuinstallation der Packages nötig. Unter Windows kann zudem das Paket installr genutzt werden, dessen Funktion updateR() prüft, ob eine neue R-Version bereitsteht, diese herunterlädt und installiert sowie die Möglichkeit bietet, automatisch Packages der alten Installation für die neue Installation zu kopieren (was nicht immer auch funktioniert). Allerdings wird empfohlen, diese Funktion nicht in RStudio, sondern direkt in R zu nutzen. Da vorige Woche eine neue Hauptversion von R erschienen ist (R 4.0.0) und wir aktuell noch kaum Packages installiert haben, die wir durch ein Update verlieren könnten, ist nun ein guter Zeitpunkt, um diese Version zu installieren. Falls Sie einen Mac nutzen, führen Sie also eine Neuinstallation von R wie unter Kapitel 1.1 beschrieben durch. Auch unter Windows können Sie diesen Weg wählen – oder Sie probieren das installr-Package aus. Hierzu installieren Sie das Package zunächst über install.packages(\"installr\"). Schließen Sie dann RStudio und öffnen R (Sie finden R in der Regel im Startmenü unter R; das gibt Ihnen auch die Gelegenheit, wertzuschätzen, wie viel komfortabler RStudio ist). In die Konsole können Sie nun installr::updateR() ein und folgen den Anweisungen des Installationsprogramms. In beiden Fällen sollte beim nächsten Start von RStudio in der ersten Konsolenzeile die neue R-Version angezeigt werden: R version 4.0.0 (2020-04-24) -- &quot;Arbor Day&quot; "],
["datahandling-intro.html", "7 Einführung in das Datenhandling 7.1 Daten- und Dateiformate tabellarischer Daten 7.2 Willkommen im Tidyverse", " 7 Einführung in das Datenhandling Das Paretoprinzip – 80% der Ergebnisse werden mit 20% des Aufwands, 20% der Ergebnisse mit 80% des Aufwands erreicht – behält auch im datenanalytischen Kontext seine Gültigkeit: ein Großteil der Arbeitszeit wird darauf verwendet, Daten zu finden, zu importieren, zu säubern, zu transformieren, zu modifizieren und zu explorieren; die tatsächliche Analyse der Daten hingegen ist dann verhältnismäßig schnell erledigt. Wir fassen diese Schritte unter dem Begriff des Datenhandlings zusammen. 7.1 Daten- und Dateiformate tabellarischer Daten Wenn wir von Datensätzen sprechen, denken wir zumeist direkt an tabellarische Daten. In den kommenden Kapiteln werden wir auch zunächst lediglich mit tabellarischen Daten arbeiten. Daten können und werden aber auch in anderen Datenformaten repräsentiert, zum Beispiel als verschachtelte und hierarchisch strukturierte Daten (dieses Datenformat wird uns u.a. bei der Arbeit mit APIs begegnen) oder als unstrukturierte Textdokumente – dazu an gegegeber Stelle mehr. 7.1.1 Tidy data Dieselben Daten können in Tabellen unterschiedlich repräsentiert werden. Schauen wir uns dazu einen Datensatz an – was könnten hier Probleme sein? ## # A tibble: 8 x 3 ## name variable value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Anakin Skywalker height 188 ## 2 Anakin Skywalker mass 84 ## 3 Leia Organa height 150 ## 4 Leia Organa mass 49 ## 5 Luke Skywalker height 172 ## 6 Luke Skywalker mass 77 ## 7 Obi-Wan Kenobi height 182 ## 8 Obi-Wan Kenobi mass 77 Diese Datenanordnung ist in dreierlei Hinsicht nicht optimal, wobei alle Probleme miteinander verbunden sind: Zwei Variablen sind in einer Spalte hinterlegt: value enthält sowohl Werte, die sich auf die Körpergröße als auch auf das Gewicht beziehen. Entsprechend ist die Spalte value abhängig von der Spalte variable – allein anhand der Werte 188, 84, 150 etc. wissen wir nicht, ob diese sich auf die Größe height oder das Gewicht mass beziehen. Daraus folgt, dass wir Probleme mit vektorisierten Funktionen – wir erinnern uns, in R sind Spalten in Datensätzen Vektoren – bekommen: wir können beispielsweise nicht einfach die mean()-Funktion auf die Spalte value anwenden, um das Durchschnittsgewicht der Star-Wars-Charaktere zu berechnen, da dort auch die Werte für die Körpergröße enthalten wären. Schauen wir uns eine zweite Version derselben Daten an: ## # A tibble: 4 x 2 ## name height_and_mass ## &lt;chr&gt; &lt;chr&gt; ## 1 Anakin Skywalker 188;84 ## 2 Leia Organa 150;49 ## 3 Luke Skywalker 172;77 ## 4 Obi-Wan Kenobi 182;77 Auch hier ergeben sich zwei miteinander verbundene Probleme: In einer Zelle stehen zwei Werte, die je eine unterschiedliche Variable abbilden. Sowohl bei Körpergröße als auch Gewicht handelt es sich um numerische Werte, sie werden aber hier als character gespeichert, wodurch wir keine Berechnungen durchführen können. Dieselben Daten können wir jedoch auch besser tabellarisch abbilden: ## # A tibble: 4 x 3 ## name height mass ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Anakin Skywalker 188 84 ## 2 Leia Organa 150 49 ## 3 Luke Skywalker 172 77 ## 4 Obi-Wan Kenobi 182 77 Daten, die so aufbereitet, werden als tidy data bezeichnet. Sie befolgen drei Regeln: Jede Variable steht in einer eigenen Spalte Jede Beobachtung/jeder Fall steht in einer eigenen Zeile Jeder Wert steht in einer Zelle Tidy data (Quelle: R for Data Science) Im Umkehrschluss bedeutet dies, dass Daten die nicht diesen Regeln folgen, als messy data vorliegen und entsprechend aufbereitet werden sollten. Tidy data hat zwei entscheidende Vorteile: Konsistent aufbereitete Daten sind leichter zu lesen, zu verarbeiten, zu laden und zu speichern. Viele Verfahren (bzw. die zugehörigen Funktionen) in R setzen diese Art der Daten voraus. Wenn Sie bisher vor allem mit Daten aus Befragungssoftware o.ä. gearbeitet haben, dann werden Ihnen diese Grundprinzipien bereits vertraut sein, da der Datenexport aus Befragungssoftware in der Regel diesen Prinzipien folgt. Tatsächlich liegen in der “Realität” Daten aber häufig nicht in dieser Form vor, beispielsweise weil die Eingabe oder Speicherung der Daten anderen Prinzipien als einer möglichst einfachen Analyse folgt (z. B. möglichst einfache Dateneingabe; Abruf von bestimmten Werten). 7.1.2 Dateiformate Sie kennen vermutlich bereits eine Vielzahl an Dateiformaten, in denen tabellarische Daten gespeichert werden können. Einige Beispiel sind Excel-Dateien mit den Endungen .xls bzw. .xlsx oder SPSS-Dateien mit der Endung .sav. Hierbei handelt es sich um sogenannte proprietäre Dateiformate, sich im Eigentum von Unternehmen befindliche und oft softwarespezifische Dateiformaten. Ein Vorteil dieser Formate ist es, dass oft relevante Zusatzinformationen für die jeweilige Software mitgespeichert werden, etwa Formatierungen in Excel oder Wertebeschriftungen in SPSS. Zugleich entsteht hierbei der große Nachteil, dass der Austausch der Daten zwischen verschiedenen Programmen oft recht kompliziert, durch Zusatzpakete oder Zwischenschritte möglich ist. Ein offenes und sehr simples Dateiformat ist .csv (für comma-separated values), das tabellarische Daten als Klartext abspeichert, von so gut wie jedem Programm auf jedem Computer der Welt gelesen werden kann und daher das Standardformat für tabellarische Daten ist. Dabei werden Kommas zu Trennung von Spalten und Zeilenumbrüche zur Trennung von Zeilen genutzt, wobei in der ersten Zeile optional Spaltenüberschriften stehen können. Die Daten aus obigen Beispiel sähen als .csv also so aus: name,height,mass Anakin Skywalker,188,84 Leia Organa,150,49 Luke Skywalker,172,77 Obi-Wan Kenobi,182,77 Soll das Trennzeichen in den einzelnen Text-Werten vorkommen (beispielsweise als Komma in einem Satz), werden Textbegrenzungszeichen, häufig doppelte Anführungszeichen \" verwendet: name,height,mass &quot;Skywalker, Anakin&quot;,188,84 &quot;Organa, Leia&quot;,150,49 &quot;Skywalker, Luke&quot;,172,77 &quot;Kenobi, Obi-Wan&quot;,182,77 In verallgemeinerter Form kann letztlich jedes Zeichen als Trennzeichen genutzt werden; im deutschsprachigen Raum wird in .csv-Dateien häufig ein Semikolon ; statt einem Komma genutzt , (z. B. wenn Sie Daten aus SPSS oder Excel als .csv exportieren): name;height;mass Anakin Skywalker;188;84 Leia Organa;150;49 Luke Skywalker;172;77 Obi-Wan Kenobi;182;77 Zwar kann R mittels unterschiedlicher Packages inzwischen auch relativ komfortabel Excel- und SPSS-Dateien einlesen; aus oben genannten Gründen werden wir zum Laden und Speichern jedoch vorrangig .csv-Dateien nutzen. 7.2 Willkommen im Tidyverse Die Idee, Datenhandling komplett codebasiert durchzuführen, erscheint zunächst vielleicht wenig komfortabel – vor allem wenn wir daran denken, dass das Auswählen und Verarbeiten von Dataframes bisher wenig intuitiv ablief (oder wissen Sie auf Anhieb noch, was der Unterschied zwischen iris[, \"Sepal.Width\"], iris$Sepal.Width und iris[[\"Sepal.Width\"]] ist?).10 Seit einigen Jahren hat sich jedoch das Tidyverse als Standard des Datenhandlings in R durchgesetzt, was die mit dem Datenhandling verbundenen Schritte deutlich vereinfacht. Dabei handelt es sich um ein sogenanntes Meta-Package, also eine Sammlung von verschiedenen Packages, die allesamt den gleichen Designprinzipien folgen, um Datenhandling zu vereinfachen und den zugehörigen Code möglichst lesbar (für Menschen) zu machen. So haben beispielsweise Funktionen im Tidyverse in der Regel Verben als Namen, die genau das beschreiben, was die Funktion macht. The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. Das Tidyverse umfasst hierzu unter anderem Pakete für: Datenstrukturen (tibble) Einlesen von Daten (z. B. readr für CSV, haven für SPSS, Stata und SAS, readxl für Excel) Datentransformation und -modifikation (tidyr, dplyr) Spezielle Objekttypen (z. B. stringr für die Arbeit mit Textobjekten, forcats für Faktoren, lubridate für Zeitdaten) Programmieren mit R (purrr) Grafik-/Diagrammerstellung (ggplot2) Alle Pakete lassen sich gesammelt installieren und laden11: install.packages(&quot;tidyverse&quot;) # Dies muss natürlich nur einmal ausgeführt werden library(tidyverse) Die Standard-Datenstruktur des Tidyverse ist das Tibble, das wir bereits aus Kapitel 5.2 kennen. Zur Erinnerung, dabei handelt es sich im Wesentlichen um Dataframes mit einigen technischen und kosmetischen Verbesserungen: as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows Im folgenden Kapitel werden wir uns nun ansehen, wie wir mittels Tidyverse-Funktionen Datensätze laden und modifizieren können. Die erste Variante resultiert in einem Dataframe, der lediglich Sepal.Width enthält, Varianten zwei und drei extrahieren diese Spalte als Vektor.↩ library(tidyverse) lädt dabei genauer gesagt die Kernpakete des Tidyverse, die die alltäglich am häufigsten genutzten Funktionen bereitstellen. Tidyverse-Packages für eher spezifische Anwendungsgebiete – z. B. lubridate für Zeitdaten oder haven für SPSS-Datensätze – müssen einzeln über den library()-Befehl geladen werden.↩ "],
["workingwithdata.html", "8 Daten laden, modifizieren und speichern 8.1 Daten laden 8.2 Daten modifizieren 8.3 Daten speichern 8.4 Übungsaufgaben", " 8 Daten laden, modifizieren und speichern In diesem Kapitel sehen wir uns grundlegende Arbeitsschritte und Funktionen des Datenhandlings: das Einlesen von Daten, einfaches Modifizieren von Datensätzen und das Abspeichern der Ergebnisse. Für all diese Schritte arbeiten wir mit Funktionen aus dem Tidyverse – falls noch nicht geschehen, sollten Sie das Package jetzt also installieren. install.packages(&quot;tidyverse&quot;) Und dann laden wir das Package zu Beginn unseres Auswertungsskripts: library(tidyverse) 8.1 Daten laden Wir sprechen von lokalen Daten, wenn wir diese in Form einer Datei auf unserer Festplatte gespeichert haben. Externe Daten liegen beispielsweise auf Webservern oder sind in Packages enthalten. Zunächst laden wir nur lokale Daten. 8.1.1 CSV-Dateien einlesen Wenn Sie den Schritten in Kapitel 6.2 gefolgt sind, haben Sie ein R-Projektverzeichnis auf des Festplatte. Auf Moodle finden Sie den Datensatz facebook_europawahl.csv, der Informatationen zu Facebook-Posts der deutschen Parteien im Vorfeld der Europawahl 2019 enthält.12 Speichern Sie diesen Datensatz in Ihrem Projektverzeichnis ab – im Beispiel liegt der Datensatz im Unterordner data. Funktionen zum Einlesen von Daten folgen im Tidyverse dem Namensschema read_, wobei nach dem Unterstrich der Dateityp folgt. Für CSV-Dateien sind zwei Funktionen relevant: read_csv() liest CSV-Dateien, die ein Komma , als Spalten- und einen Punkt . als Dezimaltrennzeichen verwenden read_csv2() liest CSV-Dateien, die ein Semikolon ; als Spalten- und das Komma , als Dezimaltrennzeichen verwenden Bei beiden Funktionen handelt es sich um spezifische Varianten der Funktion read_delim(), bei der Trennzeichen etc. einzeln definiert werden können. In der Regel sollten aber die beiden oben genannten Funktionen ausreichen. Im Zweifelsfall können CSV-Dateien durch anklicken im Files-Bereich in RStudio geöffnet werden, sodass ersichtlich wird, wie diese aufgebaut sind und welches Trennzeichen verwendet wird. Alle Funktionen aus der read_-Familie benötigen als erstes (und oft auch einziges) Argument den Dateipfad (relativ zum Arbeitsverzeichnis) als Textobjekt. Da unser Datensatz im Unterordner data liegt, lautet der gesamte Dateipfad also \"data/facebook_europawahl.csv\". Natürlich sollten wir das Resultat der Funktion einem treffend benannten Objekt zuweisen.13 df_fb_eu &lt;- read_csv(&quot;data/facebook_europawahl.csv&quot;) ## Parsed with column specification: ## cols( ## id = col_double(), ## URL = col_character(), ## party = col_character(), ## timestamp = col_datetime(format = &quot;&quot;), ## type = col_character(), ## message = col_character(), ## link = col_character(), ## comments_count = col_double(), ## shares_count = col_double(), ## reactions_count = col_double(), ## like_count = col_double(), ## love_count = col_double(), ## wow_count = col_double(), ## haha_count = col_double(), ## sad_count = col_double(), ## angry_count = col_double() ## ) Die Funktion teilt uns direkt mit, welche Objekttypen für welche Variable verwendet wurden, sodass wir hier auch direkt sehen können, ob z. B. eine numerische Variable als Text eingelesen wurde. Zudem ist der eingelesene Datensatz direkt ein Tibble, wir müssen also nicht mehr durch as_tibble() konvertieren.14 Schauen wir uns unseren gerade geladenen Datensatz einmal an – da unser Datensatz als Tibble vorliegt, erhalten wir die wichtigsten Informationen zu Struktur und einen Einblick in die Daten direkt in Konsole, wenn wir das Datensatz-Objekt aufrufen: df_fb_eu ## # A tibble: 902 x 16 ## id URL party timestamp type message link comments_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 http~ oedp~ 2019-04-28 09:00:00 video &quot;Guido~ http~ 0 ## 2 2 http~ tier~ 2019-04-28 13:57:00 photo &quot;Aus u~ http~ 17 ## 3 3 http~ B90D~ 2019-04-28 06:00:01 video &quot;Beim ~ http~ 70 ## 4 4 http~ FDP 2019-04-28 11:49:59 photo &quot;Unser~ http~ 16 ## 5 5 http~ tier~ 2019-04-28 08:24:15 link &quot;Eine ~ http~ 6 ## 6 6 http~ CDU 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 ## 7 7 http~ SPD 2019-04-28 13:06:09 photo &quot;Katar~ http~ 180 ## 8 8 http~ Pira~ 2019-04-28 17:36:30 video &quot;Unser~ http~ 0 ## 9 9 http~ DieP~ 2019-04-28 07:44:28 link &quot;Der a~ http~ 35 ## 10 10 http~ CSU 2019-04-28 08:21:00 photo &quot;#Klar~ http~ 174 ## # ... with 892 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; Wir haben also einen Datensatz mit 902 Zeilen bzw. Fällen – im diesen Falle also Facebook-Posts – und 16 Spalten bzw. Variablen. Darunter sind: eine numerische id, die URL und ein Zeitstempel (timestamp) des Posts Die Parteiseite party von der der Post abgesetzt wurde Der Typ (type) des Posts (Video, Photo, Link oder Status) Der Text (message) des Posts und ein etwaiger enthaltener link Die Anzahl verschiedener Facebook-Metriken, darunter Kommentare, Shares sowie Reactions gesamt und getrennt in einzelne Typen, allesamt auf _count endend 8.1.2 Andere Dateiformate Andere Dateiformate funktionieren analog – in der Regel reicht es, die korrekte Funktion zu verwenden und den Dateipfad anzugeben. Allerdings müssen für proprietäre Dateiformate erst die – mit dem Tidyverse bereits installierten – Packages geladen werden: das Paket readxl bietet Funktionen zum Import von Excel-Dateien, z. B. readxl::read_xlsx() das Paket haven deckt den Import von Datensätzen aus anderer Statistiksoftware (SAS, Stata, SPSS) ab, z. B. haven::read_sav() für SPSS-Datensätze 8.2 Daten modifizieren Zur Datenmodifikation betrachten wir sechs zentrale Funktionen (+ einige zugehörige Hilfsfunktionen bzw. Variationen davon), die das Tidyverse – genauer gesagt das Teilpaket dplyr15 – zur Verfügung stellt: select() zum Auswählen von Variablen (spaltenweise) filter() zum Filtern von Variablen (zeilenweise) arrange() zum Sortieren des Datensatzes mutate() zum Erzeugen neuer Variablen summarize() zum Zusammenfassen von Variablen group_by zum Gruppieren von Variablen Alle Funktionen haben dabei gemeinsam (und das trifft auf nahezu alle Funktionen des Tidyverse zu), dass das erste Argument der Datensatz selbst (als Tibble) ist und auch das Resultat der Funktion wiederum ein Tibble ist. Illustration von @allison_horst: https://twitter.com/allison_horst 8.2.1 Variablen spaltenweise auswählen mit select() Mit select() können wir bestimmte Spalten eines Datensatzes auswählen. Hierzu übergeben wir nach dem Datensatz einfach alle Variablen, die wir benötigen, direkt als Objektnamen – in unserem Beispiel id, URL, party usw. – ohne Anführungszeichen durch Kommas getrennt:16 # Wähle nur die Variablen id, party und timestamp aus select(df_fb_eu, id, party, timestamp) ## # A tibble: 902 x 3 ## id party timestamp ## &lt;dbl&gt; &lt;chr&gt; &lt;dttm&gt; ## 1 1 oedp.de 2019-04-28 09:00:00 ## 2 2 tierschutzpartei 2019-04-28 13:57:00 ## 3 3 B90DieGruenen 2019-04-28 06:00:01 ## 4 4 FDP 2019-04-28 11:49:59 ## 5 5 tierschutzpartei 2019-04-28 08:24:15 ## 6 6 CDU 2019-04-28 09:12:19 ## 7 7 SPD 2019-04-28 13:06:09 ## 8 8 Piratenpartei 2019-04-28 17:36:30 ## 9 9 DiePARTEI 2019-04-28 07:44:28 ## 10 10 CSU 2019-04-28 08:21:00 ## # ... with 892 more rows Durch ein vorangstelltes - werden Variablen ausgeschlossen: # Entferne die id und die URL-Variable select(df_fb_eu, -id, -URL) ## # A tibble: 902 x 14 ## party timestamp type message link comments_count shares_count ## &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 oedp~ 2019-04-28 09:00:00 video &quot;Guido~ http~ 0 4 ## 2 tier~ 2019-04-28 13:57:00 photo &quot;Aus u~ http~ 17 130 ## 3 B90D~ 2019-04-28 06:00:01 video &quot;Beim ~ http~ 70 28 ## 4 FDP 2019-04-28 11:49:59 photo &quot;Unser~ http~ 16 9 ## 5 tier~ 2019-04-28 08:24:15 link &quot;Eine ~ http~ 6 46 ## 6 CDU 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 136 ## 7 SPD 2019-04-28 13:06:09 photo &quot;Katar~ http~ 180 54 ## 8 Pira~ 2019-04-28 17:36:30 video &quot;Unser~ http~ 0 NA ## 9 DieP~ 2019-04-28 07:44:28 link &quot;Der a~ http~ 35 76 ## 10 CSU 2019-04-28 08:21:00 photo &quot;#Klar~ http~ 174 61 ## # ... with 892 more rows, and 7 more variables: reactions_count &lt;dbl&gt;, ## # like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, haha_count &lt;dbl&gt;, ## # sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; Durch ein vorangestelltes neuer_objektname = können wir Variablen beim Auswählen auch direkt umbenennen: # Benenne party und message beim Auswählen um in partei respektive inhalt select(df_fb_eu, partei = party, inhalt = message) ## # A tibble: 902 x 2 ## partei inhalt ## &lt;chr&gt; &lt;chr&gt; ## 1 oedp.de &quot;Guido #Klamt aus #Ludwigsburg, Listenplatz 5 auf der Kandidatenlis~ ## 2 tierschutzpart~ &quot;Aus unserem Europawahlprogramm, Kapitel 7: Gesundheits- und Sozial~ ## 3 B90DieGruenen &quot;Beim Wahlkampf-Camp in Berlin waren gestern hunderte Freiwillige, ~ ## 4 FDP &quot;Unser neuer Bundesvorstand \\U0001f389\\U0001f38a\\U0001f388 #Chancen~ ## 5 tierschutzpart~ &quot;Eine neue Studie der Universität Oxford zeigt, dass eine vegane Er~ ## 6 CDU &quot;Freiheit ist nicht selbstverständlich. #UnserEuropa steht für frei~ ## 7 SPD &quot;Katarina Barley sagt: Eine weitere Koalition mit der #EVP will ich~ ## 8 Piratenpartei &quot;Unser Spitzenkandidat Patrick Breyer mit einem Update zum EU19 Wor~ ## 9 DiePARTEI &quot;Der absolut härteste „Martin-Sonneborn-Moment“ kommt für Watson.de~ ## 10 CSU &quot;#Klartext von Bayerns Ministerpräsident und CSU-Chef Markus Söder ~ ## # ... with 892 more rows Um Variablen basierend auf Namensbestandteilen auszuwählen, sind einige Hilfsfunktionen - z. B. starts_with(), ends_with() und contains() - verfügbar. Da in unserem Beispiel alle Facebook-Metriken auf _count enden, können wir diese gesammelt mit ends_with(\"count\") auswählen: # Wähle party und alle Facebook-Metriken aus select(df_fb_eu, party, ends_with(&quot;count&quot;)) ## # A tibble: 902 x 10 ## party comments_count shares_count reactions_count like_count love_count wow_count ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 oedp~ 0 4 9 9 0 0 ## 2 tier~ 17 130 395 354 23 3 ## 3 B90D~ 70 28 215 174 14 3 ## 4 FDP 16 9 262 254 7 0 ## 5 tier~ 6 46 145 129 14 2 ## 6 CDU 239 136 398 292 8 0 ## 7 SPD 180 54 699 576 34 4 ## 8 Pira~ 0 NA 7 6 0 1 ## 9 DieP~ 35 76 612 509 49 0 ## 10 CSU 174 61 458 334 3 5 ## # ... with 892 more rows, and 3 more variables: haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, ## # angry_count &lt;dbl&gt; Schließlich kann die Hilfsfunktion everything() (ohne Argumente) genutzt werden, um sämtliche nicht zuvor angegebenen Variablen auswählen – das ist hilfreich, wenn nur bestimmte Variablen z. B. umbenannt oder an den Anfang des Datensatzes gestellt werden sollen, aber man nicht alle anderen Variablen von Hand tippen möchte: # Stelle party umbenannt in Partei an den Anfang und hänge alle verbleibenden Variablen an select(df_fb_eu, Partei = party, everything()) ## # A tibble: 902 x 16 ## Partei id URL timestamp type message link comments_count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 oedp.~ 1 http~ 2019-04-28 09:00:00 video &quot;Guido~ http~ 0 ## 2 tiers~ 2 http~ 2019-04-28 13:57:00 photo &quot;Aus u~ http~ 17 ## 3 B90Di~ 3 http~ 2019-04-28 06:00:01 video &quot;Beim ~ http~ 70 ## 4 FDP 4 http~ 2019-04-28 11:49:59 photo &quot;Unser~ http~ 16 ## 5 tiers~ 5 http~ 2019-04-28 08:24:15 link &quot;Eine ~ http~ 6 ## 6 CDU 6 http~ 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 ## 7 SPD 7 http~ 2019-04-28 13:06:09 photo &quot;Katar~ http~ 180 ## 8 Pirat~ 8 http~ 2019-04-28 17:36:30 video &quot;Unser~ http~ 0 ## 9 DiePA~ 9 http~ 2019-04-28 07:44:28 link &quot;Der a~ http~ 35 ## 10 CSU 10 http~ 2019-04-28 08:21:00 photo &quot;#Klar~ http~ 174 ## # ... with 892 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; 8.2.2 Variablen zeilenweise filtern mit filter() Um nur bestimmte Zeilen auswählen, können wir mittels filter() eine oder mehrere Bedingungen übergeben, die analog zu den if-Bedingungen in Kapitel 4.1 angegeben werden. Zuerst wird erneut der Datensatz übergeben: # Wähle alle Facebookposts mit mindestens einem Kommentar filter(df_fb_eu, comments_count &gt; 0) # Achten Sie in der Ausgabe auf die veränderte Zeilenanzahl ## # A tibble: 832 x 16 ## id URL party timestamp type message link comments_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 http~ tier~ 2019-04-28 13:57:00 photo &quot;Aus u~ http~ 17 ## 2 3 http~ B90D~ 2019-04-28 06:00:01 video &quot;Beim ~ http~ 70 ## 3 4 http~ FDP 2019-04-28 11:49:59 photo &quot;Unser~ http~ 16 ## 4 5 http~ tier~ 2019-04-28 08:24:15 link &quot;Eine ~ http~ 6 ## 5 6 http~ CDU 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 ## 6 7 http~ SPD 2019-04-28 13:06:09 photo &quot;Katar~ http~ 180 ## 7 9 http~ DieP~ 2019-04-28 07:44:28 link &quot;Der a~ http~ 35 ## 8 10 http~ CSU 2019-04-28 08:21:00 photo &quot;#Klar~ http~ 174 ## 9 11 http~ DieP~ 2019-04-28 08:11:28 video &quot;Anste~ http~ 61 ## 10 12 http~ alte~ 2019-04-28 14:55:00 link &quot;++ Ha~ http~ 1163 ## # ... with 822 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; Natürlich können auch Boolesche Operatoren (! für NICHT, &amp; für UND, | für ODER) verwendet werden. Mehrere Bedingungen können auch per , getrennt werden (UND-Verknüpfung): # Wähle nur Video-Posts der großen Koalition, die keine fehlenden Werte bei den Shares haben filter(df_fb_eu, party %in% c(&quot;CDU&quot;, &quot;CSU&quot;, &quot;SPD&quot;), type == &quot;video&quot;, !is.na(shares_count)) ## # A tibble: 62 x 16 ## id URL party timestamp type message link comments_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6 http~ CDU 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 ## 2 18 http~ CDU 2019-04-29 11:38:01 video &quot;Live:~ http~ 140 ## 3 26 http~ SPD 2019-04-29 09:02:51 video &quot;Press~ http~ 174 ## 4 31 http~ CDU 2019-04-29 09:58:45 video &quot;Da st~ http~ 274 ## 5 93 http~ CDU 2019-05-01 09:00:47 video &quot;Heute~ http~ 305 ## 6 122 http~ CDU 2019-05-02 18:00:01 video &quot;Heute~ http~ 122 ## 7 141 http~ CDU 2019-05-03 14:06:29 video &quot;Anneg~ http~ 158 ## 8 152 http~ SPD 2019-05-03 14:00:10 video &quot;Jetzt~ http~ 515 ## 9 178 http~ CSU 2019-05-05 08:30:00 video &quot;Die E~ http~ 153 ## 10 197 http~ CSU 2019-05-06 11:04:28 video &quot;Press~ http~ 98 ## # ... with 52 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; 8.2.3 Daten sortieren mit arrange() Um den Datensatz für die Ansicht umzusortieren, wird die Funktion arrange() genutzt, die aufsteigend nach den angegebenen Variablen sortiert: # Sortiere aufsteigend nach Datum arrange(df_fb_eu, timestamp) ## # A tibble: 902 x 16 ## id URL party timestamp type message link comments_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 3 http~ B90D~ 2019-04-28 06:00:01 video &quot;Beim ~ http~ 70 ## 2 13 http~ FDP 2019-04-28 06:18:18 photo &quot;Wir w~ http~ 47 ## 3 9 http~ DieP~ 2019-04-28 07:44:28 link &quot;Der a~ http~ 35 ## 4 11 http~ DieP~ 2019-04-28 08:11:28 video &quot;Anste~ http~ 61 ## 5 10 http~ CSU 2019-04-28 08:21:00 photo &quot;#Klar~ http~ 174 ## 6 5 http~ tier~ 2019-04-28 08:24:15 link &quot;Eine ~ http~ 6 ## 7 1 http~ oedp~ 2019-04-28 09:00:00 video &quot;Guido~ http~ 0 ## 8 6 http~ CDU 2019-04-28 09:12:19 video &quot;Freih~ http~ 239 ## 9 15 http~ FDP 2019-04-28 10:40:57 photo &quot;Weil ~ http~ 14 ## 10 4 http~ FDP 2019-04-28 11:49:59 photo &quot;Unser~ http~ 16 ## # ... with 892 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; Werden mehrere Variablen angegeben, wird zunächst nach der ersten Variablen, dann innerhalb der ersten Variablen nach der zweiten Variablen usw. sortiert. Soll eine Variable stattdessen absteigend sortiert werden, wird der Variablenname in die Hilfsfunktion desc() gepackt: # Sortiere alphabetisch aufsteigend nach Partei # und innerhalb von Parteien absteigend nach Kommentaranzahl arrange(df_fb_eu, party, desc(comments_count)) ## # A tibble: 902 x 16 ## id URL party timestamp type message link comments_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 870 http~ alte~ 2019-05-26 15:50:19 video &quot;+++ H~ http~ 4829 ## 2 752 http~ alte~ 2019-05-23 17:24:43 video &quot;+++ E~ http~ 3294 ## 3 616 http~ alte~ 2019-05-20 09:49:00 photo &quot;++ Me~ http~ 3100 ## 4 802 http~ alte~ 2019-05-24 17:01:12 video &quot;+++ S~ http~ 2874 ## 5 44 http~ alte~ 2019-04-30 19:02:07 video &quot;2. Te~ http~ 2862 ## 6 335 http~ alte~ 2019-05-10 17:27:58 video &quot;+++ H~ http~ 2425 ## 7 343 http~ alte~ 2019-05-11 13:12:00 photo &quot;++ Di~ http~ 2363 ## 8 50 http~ alte~ 2019-04-30 17:18:13 video &quot;+++ H~ http~ 2246 ## 9 198 http~ alte~ 2019-05-06 09:15:00 photo &quot;++ Tä~ http~ 1947 ## 10 868 http~ alte~ 2019-05-26 11:19:19 photo &quot;++ Wi~ http~ 1744 ## # ... with 892 more rows, and 8 more variables: shares_count &lt;dbl&gt;, ## # reactions_count &lt;dbl&gt;, like_count &lt;dbl&gt;, love_count &lt;dbl&gt;, wow_count &lt;dbl&gt;, ## # haha_count &lt;dbl&gt;, sad_count &lt;dbl&gt;, angry_count &lt;dbl&gt; 8.2.4 Neue Variablen hinzufügen mit mutate() Mit mutate(), dem vielleicht einzigen nicht selbsterklärenden Funktionsnamen der sechs diskutierten Funktionen, können wir Datensätzen neue Variablen hinzufügen (oder alte überschreiben). Hierzu geben wir den neuen Variablennamen an, gefolgt von einem = und der Berechnung bzw. Konstruktion der neuen Variablen. Wird als Variablenname ein schon im Datensatz bestehender Variablenname verwendet, so wird diese Variable überschrieben. Mit Kommas getrennt können auch mehrere neue Variablen erstellt werden. # Wir erstellen eine neue Variable comments_centered, # die die Kommentarzahl am allgemeinen Mittelwert zentriert # indem wir von jedem Wert den Mittelwert der Kommentarzahl abziehen # und wandeln die bestehende Variable message in Kleinschreibung # mittels der Funktion tolower() um. # # Zur Darstellung werden die beiden &#39;mutierten&#39; Variablen # anschließend mit select() ausgewählt df_mutated &lt;- mutate(df_fb_eu, comments_centered = comments_count - mean(comments_count, na.rm = TRUE), message = tolower(message)) select(df_mutated, comments_centered, message) ## # A tibble: 902 x 2 ## comments_centered message ## &lt;dbl&gt; &lt;chr&gt; ## 1 -159. &quot;guido #klamt aus #ludwigsburg, listenplatz 5 auf der kandidatenl~ ## 2 -142. &quot;aus unserem europawahlprogramm, kapitel 7: gesundheits- und sozi~ ## 3 -89.2 &quot;beim wahlkampf-camp in berlin waren gestern hunderte freiwillige~ ## 4 -143. &quot;unser neuer bundesvorstand \\U0001f389\\U0001f38a\\U0001f388 #chanc~ ## 5 -153. &quot;eine neue studie der universität oxford zeigt, dass eine vegane ~ ## 6 79.8 &quot;freiheit ist nicht selbstverständlich. #unsereuropa steht für fr~ ## 7 20.8 &quot;katarina barley sagt: eine weitere koalition mit der #evp will i~ ## 8 -159. &quot;unser spitzenkandidat patrick breyer mit einem update zum eu19 w~ ## 9 -124. &quot;der absolut härteste „martin-sonneborn-moment“ kommt für watson.~ ## 10 14.8 &quot;#klartext von bayerns ministerpräsident und csu-chef markus söde~ ## # ... with 892 more rows 8.2.5 Variablen zusammenfassen mit summarize() Mit summarize()17 fassen wir Variablen zusammen, indem wir Funktionen auf eine Variable anwenden. Das Resultat ist ein neues Tibble, das die zusammengefassten Variablen als Spalten enthält. Die Funktionsweise ist ähnlich wie bei mutate(): # Mittelwert der drei zentralen Facebook-Metriken berechen summarize(df_fb_eu, mean_comments = mean(comments_count, na.rm = TRUE), mean_shares = mean(shares_count, na.rm = TRUE), mean_reactions = mean(reactions_count, na.rm = TRUE)) ## # A tibble: 1 x 3 ## mean_comments mean_shares mean_reactions ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 159. 249. 846. 8.2.6 Variablen gruppieren mit group_by() Mittels group_by() können wir unseren Datensatz nach einer oder mehrerer Variablen gruppieren. Das Resultat ist erstmal ein Tibble, das nicht weiter von unserem Ausgangs-Tibble unterscheidet. Die Gruppierung wird dann jedoch bei folgenden Funktionen wie mutate() oder summarize() berücksichtig. # Wir berechnen erneut die zentralen Facebook-Metriken # mit summarize(), gruppieren aber zuvor nach Partei grouped_df &lt;- group_by(df_fb_eu, party) summarize(grouped_df, mean_comments = mean(comments_count, na.rm = TRUE), mean_shares = mean(shares_count, na.rm = TRUE), mean_reactions = mean(reactions_count, na.rm = TRUE)) ## # A tibble: 14 x 4 ## party mean_comments mean_shares mean_reactions ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 alternativefuerde 863. 1796. 4032. ## 2 B90DieGruenen 106. 184. 660. ## 3 CDU 349. 87.1 628. ## 4 CSU 136. 57.1 499. ## 5 DiePARTEI 60.4 160. 1343. ## 6 FamilienParteiDeutschlands 0.633 16.0 10.5 ## 7 FDP 70 67.3 447. ## 8 freie.waehler.bundesvereinigung 25.3 43.1 141. ## 9 linkspartei 116. 218. 935. ## 10 oedp.de 6.58 29.5 110. ## 11 Piratenpartei 11.4 42.5 124. ## 12 SPD 220. 149. 719. ## 13 tierschutzpartei 67.4 391. 979. ## 14 VoltDeutschland 15.6 39.8 230. Analog wird auch bei mutate() die Gruppierung in den Berechnungen berücksichtigt. Wenden wir die oben durchgeführte Mittelwert-Zentrierung der Kommentaranzahl auf unseren gruppierten Datensatz an, wird durch die mean()-Funktion der Mittelwert innerhalb der Gruppen (hier also der Parteien) berechnet. Im Ergebnis bekommen wir also für jeden Facebook-Post einen Wert, wie dieser von der durchschnittlichen Kommentaranzahl auf dieser Parteienseite abweicht: mutated_df &lt;- mutate(grouped_df, comments_group_centered = comments_count - mean(comments_count, na.rm = TRUE)) select(mutated_df, party, comments_group_centered, comments_count) ## # A tibble: 902 x 3 ## # Groups: party [14] ## party comments_group_centered comments_count ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 oedp.de -6.58 0 ## 2 tierschutzpartei -50.4 17 ## 3 B90DieGruenen -35.5 70 ## 4 FDP -54 16 ## 5 tierschutzpartei -61.4 6 ## 6 CDU -110. 239 ## 7 SPD -40.4 180 ## 8 Piratenpartei -11.4 0 ## 9 DiePARTEI -25.4 35 ## 10 CSU 37.7 174 ## # ... with 892 more rows Wir können auch nach mehreren Variablen gruppieren: # Wir berechnen erneut die zentralen Facebook-Metriken # mit summarize(), gruppieren aber zuvor nach Partei UND Post-Typ grouped_df &lt;- group_by(df_fb_eu, party, type) summarize(grouped_df, mean_comments = mean(comments_count, na.rm = TRUE), mean_shares = mean(shares_count, na.rm = TRUE), mean_reactions = mean(reactions_count, na.rm = TRUE)) ## # A tibble: 46 x 5 ## # Groups: party [14] ## party type mean_comments mean_shares mean_reactions ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 alternativefuerde link 826. 1341. 2953 ## 2 alternativefuerde photo 860. 2466. 5269. ## 3 alternativefuerde video 875. 847. 2340. ## 4 B90DieGruenen photo 134. 183. 902. ## 5 B90DieGruenen video 77.9 184. 425. ## 6 CDU photo 394. 114. 810. ## 7 CDU video 293. 53.0 400. ## 8 CSU link 25 11 132. ## 9 CSU photo 143. 63.8 566. ## 10 CSU status 416. 112. 1106 ## # ... with 36 more rows Wir sehen hier also, dass die AfD im Mittel 826.14 Kommentare auf Links bekommt, 860.49 auf Photos usw. Gruppierungen können (und sollten) im Anschluss mittels ungroup() wieder entfernt werden (auch hier wird der Datensatz als Argument übergeben), um Probleme bei der weiteren Datentransformation zu vermeiden. Eine besondere Variante von group_by() ist rowwise(), die den Datensatz zeilenweise gruppiert; dies ermöglicht zeilenweise Berechnungen mit Funktionen über mehrere Variablen hinweg, z. B. die Erstellung von Mittelwerts-Indizes: # Gruppiere den Datensatz zeilenweise, um für jeden Post # den Mittelwert der einzelnen Reactions (Like, Love etc.) # zu berechnen rowwise_df &lt;- rowwise(df_fb_eu) mutated_df &lt;- mutate(rowwise_df, mean_reactions = mean(c(like_count, love_count, wow_count, haha_count, sad_count, angry_count), na.rm = TRUE)) select(mutated_df, mean_reactions) ## Source: local data frame [902 x 1] ## Groups: &lt;by row&gt; ## ## # A tibble: 902 x 1 ## mean_reactions ## &lt;dbl&gt; ## 1 1.5 ## 2 65.8 ## 3 35.8 ## 4 43.7 ## 5 24.2 ## 6 66.3 ## 7 116. ## 8 1.17 ## 9 102 ## 10 76.3 ## # ... with 892 more rows Eine Funktion, die einen häufigen Anwendungsfall von group_by(), summarize() und ungroup() kombiniert, ist count(), die die Fallzahl einer oder mehrerer Gruppierungsvariablen ausgibt. Mit dem Argument sort = TRUE kann die Ausgabe zudem direkt absteigend nach Anzahl sortiert werden: # Zähle Posts pro Partei count(df_fb_eu, party) ## # A tibble: 14 x 2 ## party n ## &lt;chr&gt; &lt;int&gt; ## 1 alternativefuerde 79 ## 2 B90DieGruenen 67 ## 3 CDU 64 ## 4 CSU 103 ## 5 DiePARTEI 96 ## 6 FamilienParteiDeutschlands 30 ## 7 FDP 94 ## 8 freie.waehler.bundesvereinigung 30 ## 9 linkspartei 38 ## 10 oedp.de 71 ## 11 Piratenpartei 73 ## 12 SPD 49 ## 13 tierschutzpartei 33 ## 14 VoltDeutschland 75 # Zähle Posts pro Partei und Post-Typ und sortiere absteigend nach Anzahl count(df_fb_eu, party, type, sort = TRUE) ## # A tibble: 46 x 3 ## party type n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 CSU photo 76 ## 2 FDP photo 67 ## 3 DiePARTEI photo 53 ## 4 alternativefuerde photo 45 ## 5 oedp.de photo 40 ## 6 Piratenpartei photo 39 ## 7 B90DieGruenen video 35 ## 8 CDU photo 35 ## 9 VoltDeutschland photo 35 ## 10 SPD photo 33 ## # ... with 36 more rows 8.3 Daten speichern Wenn wir unsere Dateien modifiziert haben, möchten wir diese wohl auch speichern bzw. exportieren. 8.3.1 Tabellarische Daten exportieren Analog zu den read_-Funktionen stehen daher Exportfunktionen nach dem Schema write_ zur Verfügung. Als Argumente werden dabei der Datensatz, der gespeichert werden soll, sowie der Dateipfad der zu speichernden Datei übergeben. Haben wir durch Modifikation beispielsweise das Tibble df_modified erstellt und möchten es in der Datei datensatz_modifiziert.csv im Unterordner data abspeichern, führen wir die write_csv()-Funktion aus: write_csv(df_modified, &quot;data/datensatz_modifiziert.csv&quot;) write_csv() nutzt dabei das Komma , als Spalten- und einen Punkt . als Dezimaltrennzeichen. Möchten wir stattdessen das in Deutschland gebräuchliche Format mit Semikolon ; als Spalten- und Komma , als Dezimaltrennzeichen haben, verwenden wir analog zu read_csv2() write_csv2(). Da Excel öfters Probleme mit dem Einlesen von CSV-Dateien hat, können, soll die Datei danach in Excel betrachtet werden, auch die Funktionen write_excel_csv() bzw. write_excel_csv2() verwendet werden. Dies fügt ein spezielles Zeichen hinzu, das Excel den Datenimport erleichert. 8.3.2 R-Objekte exportieren Beim Export als CSV gehen unweigerlich auch Informationen verloren – bei unserem Datensatz beispielsweise die Objekttypen, die R den jeweiligen Variablen zugeordnet hat. Wollen wir R-Objekte daher für die zukünftige Verwendung in R abspeichern, lohnt es sich, direkt das jeweilige R-Objekt zu exportieren. Hierfür steht das Dateiformat .rds zur Verfügung, mit dem beliebige R-Objekte – neben Datensätzen also auch Vektoren, Listen, statistische Modelle etc. - gespeichert werden können. Die zugehörige Funktion lautet saveRDS() und wird analog zu den write_-Funktionen verwendet: saveRDS(df_mutated, &quot;data/datensatz_modifiziert.rds&quot;) RDS-Dateien können dann jederzeit mit der Funktion readRDS() wieder geladen werden. Sollen mehrere R-Objekte exportiert werden – also beispielsweise ein Ausgangsdatensatz, ein modifizierter Arbeitsdatensatz und zugehörige statistische Modelle – kann das Dateiformat .RData und die Funktion save() verwendet werden. Dabei werden alle zu speichernden Objekte gefolgt von dem benannten Argument file =, das den Dateipfad angibt, in dem Funktionsaufruf genannt: save(df_fb_eu, df_mutated, &quot;data/eu_file.RData&quot;) So exportiere Objekte können dann gesammelt über die load()-Funktion, die den Dateipfad als Argument benötigt, wieder geladen werden, was sehr praktisch ist, um direkt den gesamten Arbeitsstand wiederherzustellen. 8.4 Übungsaufgaben Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei oder eine R-Markdown-Datei und speichern diese als ue8_nachname.R bzw. ue8_nachname.Rmd ab. Übungsaufgabe 8.1 Daten laden: Laden Sie die Datei facebook_europawahl.csv aus Moodle in Ihr Projektverzeichnis herunter und laden Sie den Datensatz. Übungsaufgabe 8.2 Daten modifizieren und speichern: Erstellen Sie einen Teildatensatz, der: nur Posts der aktuell im Bundestag vertretenen Parteien enthält (CDU, CSU, SPD, FDP, Linke, Grüne, AfD); Tipp: Betrachten Sie vorab die Schreibweise der Parteien (bzw. deren Facebook-Accounts) nur die Variablen party, timestamp, type sowie alle Facebook-Metriken enthält eine neue Variable total_count enthält, in der für jeden Post die Gesamtzahl der Kommentare, Shares und Reactions angegeben ist Speichern Sie diesen Teildatensatz sowohl als CSV- als auch als RDS-Datei. Übungsaufgabe 8.3 Daten modifizieren und zusammenfassen: Nutzen Sie die oben vorgestellten Funktionen, um pro Partei Mittelwert und Standardabweichung der drei Facebook-Metriken (Kommentare, Shares, Reactions) aller Posts zu berechnen, die in der Woche vor der Wahl (also nach dem 19.05.2019) erschienen sind. Tipp: Logische Operatoren funktionieren auch mit Datums- und Zeitvariablen; Text, der wie ein Datum aussieht, wir dabei automatisch in ein Datum bzw. eine Zeitangabe konvertiert. Vielen Dank an den Kollegen Jörg Haßler!↩ Häufig verwendete Objektnamen für Datensätze sind df und data, aber es schadet auch nicht, etwas spezifischere Namen zu vergeben, besonders wenn mit mehreren Datensätzen gearbeitet wird.↩ Auch die Basisversion von R bietet Funktionen zum Einlesen von CSV-Dateien, die read.csv(), read.csv2() etc. heißen. Diese erzeugen einen Dataframe und sind weniger gut für große Dateien optimiert, sodass ich empfehle, immer direkt die Tidyverse-Funktionen zu nutzen. Generell erkennen Sie Tidyverse-Varianten von Funktionen der R-Basisversion daran, dass diese einen Unterstrich anstatt eines Punkts zur Worttrennung nutzen.↩ Wobei umstritten ist, ob man das Paket dee_plier oder deeply_ar ausspricht.↩ Und natürlich müssen wir das Resultat der Funktionen immer einem Objekt zuweisen, wenn wir damit weiterarbeiten wollen – zu Demonstrationszwecken reicht aber der reine Aufruf der Funktion.↩ Wer the King’s English bevorzugt: summarise() funktioniert auch.↩ "],
["der-pipe-operator.html", "9 Der Pipe-Operator %&gt;% 9.1 Lesbarkeit verschachtelter Funktionen 9.2 Ein Beispiel in Pseudo-Code 9.3 Formale Definition 9.4 Einsatz von Pipes im Tidyverse 9.5 Übungsaufgaben", " 9 Der Pipe-Operator %&gt;% Neben vielen praktischen Funktionen und der Datenstruktur Tibbles führt das Tidyverse auch ein neuens Syntax-Konzept in R ein: den sogenannten Pipe-Operator %&gt;%, mit dem Argumente auf eine andere Art und Weise an Funktionen übergeben werden.18 9.1 Lesbarkeit verschachtelter Funktionen Hierzu rufen wir uns zunächst noch einmal in Erinnerung, wie Funktionen in R grundsätzlich aufgerufen werden: funktionsname(argument1 = wert1, argument2 = wert2, argument3 = wert3, ...) Wir haben außerdem bereits gesehen, dass wir Funktionen ineinander verschachteln können, wenn wir mehrere Funktionen hintereinander aufrufen möchten: round(mean(iris$Sepal.Length), 2) ## [1] 5.84 Das wird jedoch irgendwann sehr unübersichtlich und anfällig für Fehler – bereits bei diesem Beispiel müssen wir darauf achten, dass die Klammern zur richtigen Zeit geöffnet und vor allem wieder geschlossen werden, und wir müssen “Klammern zählen”, wenn wir wissen wollen, zu welcher der aufgerufenen Funktionen das Argument 2 gehört. Zusätzlich ergibt sich durch die Verschachtelung die unnatürliche Lesereihenfolge von innen nach außen, was komplexeren Code schwer nachvollziehbar macht. 9.2 Ein Beispiel in Pseudo-Code Um dies zu verdeutlichen, stellen wir uns einmal vor, eine typische Morgenroutine bestünde aus “Funktionen”, die wir der Reihe nach “aufrufen”: Aufstehen Frühstücken Zähne putzen Duschen Anziehen In R-Code ausgedrückt würde das also wie folgt aussehen: einsatzbereit &lt;- anziehen(duschen(zaehne_putzen(fruehstuecken(aufstehen(ich), food = &quot;muesli&quot;)), wasser_temperatur = &quot;warm&quot;)) Wir könnten das ganze durch Einrückungen zumindest etwas lesbarer gestalten: einsatzbereit &lt;- anziehen( duschen( zaehne_putzen( fruehstuecken( aufstehen(ich), food = &quot;muesli&quot;) ), wasser_temperatur = &quot;warm&quot;) ) Das ist schon etwas besser, aber immer noch nicht sonderlich intuitiv zu lesen – und schließen wir nur eine Klammer an der falschen Stelle oder vergessen sie gar ganz, fliegt uns der gesamte Code um die Ohren. Natürlich könnten wir die Schritte der Morgenroutine auch einzeln durchgehen und jeweils einem neuen “Objekt” zuweisen: wach &lt;- aufstehen(ich) satt &lt;- fruehstuecken(wach, food = &quot;muesli&quot;) sauber1 &lt;- zaehe_putzen(satt) sauber2 &lt;- duschen(sauber1, wasser_temperatur = &quot;warm&quot;) einsatzbereit &lt;- anziehen(sauber2) Das erzeugt aber viele Objekte, die wir gar nicht weiter benötigen, da wir nur an einsatzbereit interessiert sind. Wir könnten natürlich auch immer das gleiche Objekt wieder und wieder überschreiben, darunter leidet dann aber erneut die Lesbarkeit. Mit dem Pipe-Operator %&gt;% können wir diese Schritte in einer logischen Lesereihenfolge ohne die Erstellung von redundaten Objekten durchführen: einsatzbereit &lt;- ich %&gt;% aufstehen() %&gt;% fruehstuecken(food = &quot;muesli&quot;) %&gt;% zaehne_putzen() %&gt;% duschen(wasser_temperatur = &quot;warm&quot;) %&gt;% anziehen() 9.3 Formale Definition Formal ausgedrückt übergibt der Pipe-Operator %&gt;% das links von ihm stehende Objekt als erstes Argument an die rechts von ihm stehende Funktion: # Die folgenden beiden Zeilen sind analog f(x) x %&gt;% f() # Oder anhand einer echten Funktion mean(x) # ist analog zu x %&gt;% mean() Weitere Funktionsargumente können regulär entweder positional oder explizit durch Namensnennung an die Funktion übergeben werden: # Die folgenden beiden Zeilen sind wiederum analog f(x, y, z) x %&gt;% f(y, z) # Und wieder am Beispiel der mean()-Funktion mean(x, na.rm = TRUE) # ist analog zu x %&gt;% mean(na.rm = TRUE) 9.4 Einsatz von Pipes im Tidyverse Besonders sinnvoll sind Pipes dann, wenn wir viele Funktionen hintereinander am gleichen Ausgangsobjekt aufrufen wollen, z. B. wenn wir unterschiedliche Schritte der Datenmodifikation an einem Datensatz vornehmen möchten. Bei den Tidyverse-Funktionen wissen wir, dass das erste Argument immer der Datensatz, also ein Tibble, ist und das Resultat der Funktion auch immer ein Datensatz, also ein Tibble ist. Daher können wir diese Schritte schnell aneinanderreihen. Nutzen wir als Beispiel nochmals den Datensatz aus Kapitel 8: # Wir laden den Datensatz df_fb_eu &lt;- read_csv(&quot;data/facebook_europawahl.csv&quot;) # Wir erstellen einen modifizierten Datensatz, indem wir: # 1. nur die Video-Posts auswählen # 2. nur die Variablen id, party und comment_count auswählen # 3. Nach Partei gruppieren # 4. Eine neue Variable erstellen, die für jeden Post angibt, # welchen Anteil dieser an allen Kommentaren unter Post der # jeweiligen Partei hatte # 5. heben die Gruppierung wieder auf und # 6. weisen das Resultat dieser &#39;Pipe&#39; dem Objekt modified_df zu modified_df &lt;- df_fb_eu %&gt;% # Wir definieren die Zuweisung und übergeben df_fb_eu an filter(type == &quot;video&quot;) %&gt;% # die filter()-Funktion; der resultierende Datensatz wird an select(id, party, comments_count) %&gt;% # select() übergeben; das Resultat wiederum wird group_by(party) %&gt;% # gruppiert etc. mutate(comment_percentage = comments_count / sum(comments_count)) %&gt;% ungroup() modified_df ## # A tibble: 272 x 4 ## id party comments_count comment_percentage ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 oedp.de 0 NA ## 2 3 B90DieGruenen 70 NA ## 3 6 CDU 239 NA ## 4 8 Piratenpartei 0 0 ## 5 11 DiePARTEI 61 0.0371 ## 6 14 FDP 358 0.117 ## 7 16 DiePARTEI 15 0.00912 ## 8 18 CDU 140 NA ## 9 26 SPD 174 0.0599 ## 10 31 CDU 274 NA ## # ... with 262 more rows Auch für schnelle deskriptive Auswertungen können wir Pipes gut nutzen – z. B. um uns schnell die Mittelwerte bestimmter Variablen gruppiert nach anderen Variablen anzuzeigen: df_fb_eu %&gt;% group_by(party, type) %&gt;% summarize(mean_comments = mean(comments_count, na.rm = TRUE), mean_shares = mean(shares_count, na.rm = TRUE), mean_reactions = mean(reactions_count, na.rm = TRUE)) ## # A tibble: 46 x 5 ## # Groups: party [14] ## party type mean_comments mean_shares mean_reactions ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 alternativefuerde link 826. 1341. 2953 ## 2 alternativefuerde photo 860. 2466. 5269. ## 3 alternativefuerde video 875. 847. 2340. ## 4 B90DieGruenen photo 134. 183. 902. ## 5 B90DieGruenen video 77.9 184. 425. ## 6 CDU photo 394. 114. 810. ## 7 CDU video 293. 53.0 400. ## 8 CSU link 25 11 132. ## 9 CSU photo 143. 63.8 566. ## 10 CSU status 416. 112. 1106 ## # ... with 36 more rows Praktisch, oder? Bleibt noch die eine Hürde, dass %&gt;% eher kompliziert zu tippen ist – dankenswerterweise stellt RStudio aber auch hier eine Tastenkombination zur Verfügung: Strg/Cmd + Shift + M fügt den gesamten Operator ein. 9.5 Übungsaufgaben Erstellen Sie für die folgende Übungsaufgabe eine eigene Skriptdatei oder eine R-Markdown-Datei und speichern diese als ue9_nachname.R bzw. ue9_nachname.Rmd ab. Übungsaufgabe 9.1 Pipes: Lösen Sie die Übungsaufgaben 8.2 und 8.3 erneut, aber verwenden Sie Pipes, um den Code lesbarer und mit weniger redundanten Zwischenobjekten zu gestalten. An welchen Stellen ist es sinnvoll bzw. weniger sinnvoll, Pipes zu verwenden? Das Konzept ist aus anderen Programmiersprachen entlehnt und wurde ursprünglich durch das Package magrittr in R eingeführt; soll der Pipe-Operator %&gt;% ohne das Tidyverse-Package genutzt werden, kann also dieses Package geladen werden: library(magrittr).↩ "],
["loesungen.html", "A Lösungen der Übungsaufgaben Kapitel 2: Objekte und Datenstrukturen Kapitel 3: Funktionen Kapitel 4: Kontrollstrukturen", " A Lösungen der Übungsaufgaben Kapitel 2: Objekte und Datenstrukturen Lösung zur Übungsaufgabe 2.1: Am sinnvollsten ist eine Liste list(), da diese heterogene Objekttypen beinhalten kann. Ein Dataframe lohnt sich bei nur einem Fall eher nicht. myself &lt;- list( name = &quot;Julian&quot;, # Texte als character year = 1988L, # Jahr als numeric - oder noch präziser als Integer from_bavaria = FALSE # Binäre Entscheidung als logical ) Auch wenn wir hier alle Werte z. B. als Text repräsentieren könnten, ist es immer sinnvoll, den Objekttypen zu verwenden, der am besten zu den Werten passt – numerische (year) und logische Objekte (from_bavaria) ermöglichen uns mehr Rechenoptionen, einfacheres Filtern von Datensätzen etc. Lösung zur Übungsaufgabe 2.2: values &lt;- c(1.2, 1.3, 0.8, 0.7, 0.7, 1.5, 1.1, 1.0, 1.1, 1.2, 1.1) average &lt;- mean(values) above_average &lt;- values &gt; average sum(above_average) / length(values) ## [1] 0.6363636 In der ersten Zeile ordnen wir values einen numerischen Vektor aus einigen Zahlen zu In der zweiten Zeile berechnen wir den Mittelwert von values und weisen diesen average zu. values &gt; average prüft nun für jeden Wert in values, ob dieser größer als der Mittelwert (gespeichert in average ist). Dies erzeugt einen logical-Vektor, den wir above_average zuweisen. sum(above_average) zählt, wie viele TRUE-Werte in dem Vektor sind. Das ist darauf zurückzuführen, dass TRUE die numerische Entsprechung 1, FALSE die numerische Entsprechung 0 hat; sum() wandelt den logischen Vektor automatisch in einen numerischen um. Wir teilen dies durch die Anzahl der Werte in values und bekommen als Ergebnis, dass 63.6 % der Werte in values über dem Mittelwert liegen. (Etwas schneller hätten wir dieses Ergebnis auch bekommen, wenn wir die letzte Zeile durch mean(above_average) ersetzen.) Lösung zur Übungsaufgabe 2.3: str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... mtcars enthält 11 Variablen, allesamt numeric, und 32 Fälle. mean(mtcars$cyl) ## [1] 6.1875 Im Durchschnitt haben die Fahrzeuge ca. 6.2 Zylinder. Um einen Teildatensatz cars_short, der lediglich die Variablen mpg und hp enthält, zu erstellen, führen viele Wege zum Ziel, z. B.: cars_short &lt;- mtcars[, c(&quot;mpg&quot;, &quot;hp&quot;)] cars_short &lt;- mtcars[c(&quot;mpg&quot;, &quot;hp&quot;)] # Steht nur eine Angabe in den eckigen Klammern, interpretiert R dies als Spaltenangabe cars_short &lt;- data.frame(mtcars$mpg, mtcars$hp) Kapitel 3: Funktionen Lösung zur Übungsaufgabe 3.1: Um die gewünschte Sequenz zu erzeugen, benötigen wir die Argumente from (Startwert), to (Endwert) und by (Zunahmewert). seq(from = 0, to = 100, by = 5) ## [1] 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 ## [21] 100 Da es sich, wie wir der Funktionsdokumentation entnehmen können, dabei um die ersten drei Funktionsargumente handelt, können wir diese auch unbenannt übergeben: seq(0, 100, 5) ## [1] 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 ## [21] 100 Lösung zur Übungsaufgabe 3.2: Unsere Funktion benötigt lediglich ein Argument, die Temperatur in Grad Fahrenheit (als numerischen Wert), und soll diese in Grad Celsius mit der Formel \\(°C = (°F − 32) × 5/9\\) umwandeln: fahrenheit_to_celsius &lt;- function(fahrenheit) { celsius &lt;- (fahrenheit - 32) * 5/9 return(celsius) } # Unsere neue Funktion kann sogar mehrere Temperaturwerte auf einmal umrechnen fahrenheit_to_celsius(c(0, 50, 80, 100)) ## [1] -17.77778 10.00000 26.66667 37.77778 Lösung zur Übungsaufgabe 3.3: Für das erste zusätzliche Feature, der Anzahl der fehlenden Werte, müssen wir descriptives_vector lediglich ein Element hinzufügen (das wir z. B. Missing nennen), in dem eben diese Anzahl festgehalten wird. Mit der Funktion is.na() prüfen wir jeden Wert eines Vektors darauf, ob es sich um einen fehlenden Wert NA handelt, mit der Summenfunktion sum() können wir diese addieren. Wir ändern descriptives_vector daher wie folgt: descriptives_vector &lt;- c( n = length(x), Missing = sum(is.na(x)), # Hier zählen wir die fehlenden Werte M = mean(x, na.rm = na.rm), SD = sd(x, na.rm = na.rm), Minimum = min(x, na.rm = na.rm), Maximum = max(x, na.rm = na.rm), Median = median(x, na.rm = na.rm) ) Für das zweite zusätzliche Feature, Rundung auf eine gewünsche Anzahl an Nachkommastelle, benötigen wir die round()-Funktion, mit dem wir descriptives_vector abschließend runden, und ein zusätzliches Argument, mit dem die gewünschte Anzahl an Nachkommastellen übergeben werden kann. Da dieses Argument bei der round()-Funktion digits heißt, nennen wir es aus Konsistenzgründen auch in unserer Funktion so. Um standardmäßig auf zwei Nachkommastellen zu runden, geben wir dem Argument den Default-Wert 2. Der vollständige Funktionscode sieht also wie folgt aus: descriptives &lt;- function(x, na.rm = FALSE, digits = 2) { # Zusätzliches Argument digits mit Default-Wert 2 # Vektor mit Variablenbeschreibung erstellen descriptives_vector &lt;- c( n = length(x), Missing = sum(is.na(x)), # Hier zählen wir die fehlenden Werte M = mean(x, na.rm = na.rm), SD = sd(x, na.rm = na.rm), Minimum = min(x, na.rm = na.rm), Maximum = max(x, na.rm = na.rm), Median = median(x, na.rm = na.rm) ) # Vektor runden descriptives_vector &lt;- round(descriptives_vector, digits = digits) return(descriptives_vector) } Wir haben nun eine flexibel einsetzbare Funktion, um schnell relevante Kennwerte einer numerischen Variablen zu erhalten: descriptives(iris$Sepal.Length) ## n Missing M SD Minimum Maximum Median ## 150.00 0.00 5.84 0.83 4.30 7.90 5.80 descriptives(mtcars$cyl, digits = 1) ## n Missing M SD Minimum Maximum Median ## 32.0 0.0 6.2 1.8 4.0 8.0 6.0 Kapitel 4: Kontrollstrukturen Lösung zur Übungsaufgabe 4.1: Erneut gibt es verschiedene Möglichkeiten, den Entscheidungsbaum abzubilden. Wenn wir uns pro if () bzw. else () oder else if () auf das Prüfen einer Bedingung beschränken wollen, benötigen wir einen verschachtelten Baum, also eine Bedinung in einer Bedingung: if (news_channel != &quot;Internet&quot;) { # Prüfen, ob news_channel NICHT &quot;Internet&quot; ist... news_category &lt;- &quot;Offline&quot; # dann news_category &quot;Offline&quot; zuweisen } else { # Falls das nicht der Fall ist, also news_channel &quot;Internet&quot; ist.. if (news_website == &quot;Twitter&quot;) { # dann prüfen wir ob news_category &quot;Twitter&quot; ist news_category &lt;- &quot;SNS&quot; # falls das so ist, weisen wir news_category &quot;SNS&quot; zu } else if (news_website == &quot;Facebook&quot;) { # analog verfahren wir mit Facebook news_category &lt;- &quot;SNS&quot; # } else if (news_website == &quot;Instagram&quot;) { # analog mit Instagram news_category &lt;- &quot;SNS&quot; # } else { # falls das alles nicht zutrifft news_category &lt;- &quot;Online: Sonstige&quot; # weisen wir &quot;Online: Sonstige&quot; zu } } Das erzeugt allerdings einen ziemlich langen Entscheidungsbaum und einige Redundanzen, da wir für \"Twitter\", \"Facebook\" und \"Instagram\" jeweils dieselbe Aktion, news_category &lt;- \"SNS\" ausführen. Wir können diese Bedingungen also auch verknüpfen: if (news_channel != &quot;Internet&quot;) { # Prüfen, ob news_channel NICHT &quot;Internet&quot; ist... news_category &lt;- &quot;Offline&quot; # dann news_category &quot;Offline&quot; zuweisen } else { # Falls das nicht der Fall ist, also news_channel &quot;Internet&quot; ist.. if (news_website == &quot;Twitter&quot; | news_website == &quot;Facebook&quot; | news_website == &quot;Instagram&quot;) { news_category &lt;- &quot;SNS&quot; # Alle Bedingungen mit ODER verbunden, dann SNS zuweisen } else { # falls das nicht zutrifft news_category &lt;- &quot;Online: Sonstige&quot; # weisen wir &quot;Online: Sonstige&quot; zu } # und haben uns einige Zeilen gespart } Tatsächlich können wir auch die Verschachtelung aufheben, da nach if (news_channel != \"Internet\") folgt, dass bei allen anschließenden else if()-Bedingungen news_channel == \"Internet\" ist: if (news_channel != &quot;Internet&quot;) { news_category &lt;- &quot;Offline&quot; } else if (news_website == &quot;Twitter&quot; | news_website == &quot;Facebook&quot; | news_website == &quot;Instagram&quot;) { news_category &lt;- &quot;SNS&quot; } else { news_category &lt;- &quot;Online: Sonstige&quot; } Und noch kürzer wir der Entscheidungsbaum, wenn wir den %in%-Operator verwenden: SNS &lt;- c(&quot;Twitter&quot;, &quot;Facebook&quot;, &quot;Instagram&quot;) if (news_channel != &quot;Internet&quot;) { news_category &lt;- &quot;Offline&quot; } else if (news_website %in% SNS) { news_category &lt;- &quot;SNS&quot; } else { news_category &lt;- &quot;Online: Sonstige&quot; } Lösung zur Übungsaufgabe 4.2: Beim ersten Platzhalter müssen wir einen for-Loop, wie in Kapitel 4.2.2 beschrieben, einfügen und uns für einen Namen für das Iterator-Objekt entscheiden. Da wir über den Vektor variables loopen, bietet sich der Singular variable an (aber natürlich funktioniert auch jeder andere Objektname). Diesen müssen wir dann bei den folgenden Platzhaltern ergänzen: numeric_summary &lt;- function(data) { # Alle Variablennamen in Vektor speichern variables &lt;- names(data) # Leere Liste für Ausgabe vorbereiten summary_list &lt;- list() # Über alle Variablen iterieren for (variable in variables) { # Wir loopen über variables variable_vector &lt;- data[[variable]] # Und arbeiten nun immer mit dem Iterator-Objekt variable if (is.numeric(variable_vector)) { # Prüfen ob die Variable numerisch ist # Mittelwert und Standardabweichung dieser Variablen der summary_list hinzufügen summary_list[[variable]] &lt;- c( M = mean(variable_vector), SD = sd(variable_vector) ) } } # Summary List ausgeben return(summary_list) } Diese Funktion erzeugt uns nun auf einen Schlag eine Kurzzusammenfassung anhand von Mittelwert und Standardabweichung aller numerischen Variablen in einem Datensatz: numeric_summary(iris) ## $Sepal.Length ## M SD ## 5.8433333 0.8280661 ## ## $Sepal.Width ## M SD ## 3.0573333 0.4358663 ## ## $Petal.Length ## M SD ## 3.758000 1.765298 ## ## $Petal.Width ## M SD ## 1.1993333 0.7622377 numeric_summary(mtcars) ## $mpg ## M SD ## 20.090625 6.026948 ## ## $cyl ## M SD ## 6.187500 1.785922 ## ## $disp ## M SD ## 230.7219 123.9387 ## ## $hp ## M SD ## 146.68750 68.56287 ## ## $drat ## M SD ## 3.5965625 0.5346787 ## ## $wt ## M SD ## 3.2172500 0.9784574 ## ## $qsec ## M SD ## 17.848750 1.786943 ## ## $vs ## M SD ## 0.4375000 0.5040161 ## ## $am ## M SD ## 0.4062500 0.4989909 ## ## $gear ## M SD ## 3.6875000 0.7378041 ## ## $carb ## M SD ## 2.8125 1.6152 "]
]
