% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Computational Methods in der politischen Kommunikationsforschung},
  pdfauthor={Julian Unkel},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}

\title{Computational Methods in der politischen Kommunikationsforschung}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Methodische Vertiefung: Computational Methods mit R und RStudio}
\author{Julian Unkel}
\date{}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Beispiel}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Übungsaufgabe}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Lösung }
\let\BeginKnitrBlock\begin \let\EndKnitrBlock\end
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{einfuxfchrung}{%
\chapter*{Einführung}\label{einfuxfchrung}}
\addcontentsline{toc}{chapter}{Einführung}

Zuletzt aktualisiert: 2020-05-07 12:03:20.
Dies ist ein \emph{Work-in-Progress} und wird laufend aktualisiert.

\hypertarget{seminarinformationen}{%
\section*{Seminarinformationen}\label{seminarinformationen}}
\addcontentsline{toc}{section}{Seminarinformationen}

\begin{itemize}
\tightlist
\item
  Dozent: Julian Unkel, \href{mailto:unkel@ifkw.lmu.de}{\nolinkurl{unkel@ifkw.lmu.de}}
\item
  Zeit und Ort: Donnerstags, 12-14 Uhr, \sout{Oe 057} (bis auf weiteres findet das Seminar rein digital statt)
\item
  Moodle: \url{https://moodle.lmu.de/course/view.php?id=8250}
\end{itemize}

\hypertarget{ablauf-des-kurses}{%
\section*{Ablauf des Kurses}\label{ablauf-des-kurses}}
\addcontentsline{toc}{section}{Ablauf des Kurses}

Aufgrund der aktuellen Situation wird dieses Seminar in einen Online-Kurs überführt. Alle Seminarinhalte werden in Textform aufbereitet und nach und nach diesem Online-Kurs hinzugefügt. Auf Basis des Kurses sollen die Seminarinhalte selbstständig und mit weitestgehend eigenem Lerntempo erarbeitet werden.

In jedem Kapitel werden hierzu zunächst die wesentlichen Konzepte und Inhalte erläutert. Jedes Kapitel schließt mit einigen Übungsaufgaben, die über Moodle abgegeben werden müssen. Deadlines für die Übungsaufgaben werden ebenfalls über Moodle kommuniziert, Lösungen im Anschluss an die Deadlines im Kurs hinzugefügt.

Jeden Donnerstag zum regulären Seminartermin findet von 12-14 Uhr eine Online-Sprechstunde via Zoom statt. Hier können Fragen zu den Seminarinhalten, Übungsaufgaben etc. gestellt und diskutiert werden.

In Moodle stehen zudem zwei Foren zur Verfügung, in dem Sie 1) allgemeine Fragen zu R und RStudio sowie 2) spezifische Fragen / alternative Lösungen zu den Übungsaufgaben (vor-)stellen und diskutieren können. Scheuen Sie sich bitte nicht, auch selbst auf Fragen und Probleme von Kommiliton*innen einzugehen.

Neben den regulären Übungsaufgaben werden Sie bisweilen auch optionale, besonders knifflige Aufgaben vorfinden, die ich in der Sprache meiner Ahnen als \emph{Käpseles-Aufgaben} kennzeichnen werde. Diese sind nicht verpflichtend, können Ihnen aber als Gradmesser dienen, ob Sie die jeweiligen Inhalte auch eigenständig und in leicht abgewandelter Form anwenden können.

\hypertarget{motivation-und-ziele-des-seminars}{%
\section*{Motivation und Ziele des Seminars}\label{motivation-und-ziele-des-seminars}}
\addcontentsline{toc}{section}{Motivation und Ziele des Seminars}

Das Ziel des Kurses ist es, methodische Kenntnisse zur Anwendung computationaler Methoden zu vermitteln. Hierzu werden wir uns zunächst allgemein mit der Datenbearbeitung und -analyse mit der statistischen Programmiersprache R auseinandersetzen. Es folgen dann spezifischere Verfahren der computationalen Datenerhebung und -analyse.

Dabei stehen insbesondere folgende Inhalte im Vordergrund:

\begin{itemize}
\tightlist
\item
  Einführung in \emph{R} und die Arbeit mit \emph{RStudio}
\item
  Datenmanagement in \emph{R}
\item
  Computationale Datenerhebung mit \emph{R}
\item
  Datenvisualisierung mit \emph{R}
\item
  Automatisierte Inhaltsanalyse mit \emph{R}
\end{itemize}

Zudem wird darauf eingegangen, wie mittels R und RStudio Kommunikationsforschung transparent, nachvollziehbar und reproduzierbar gestaltet werden kann.

Es werden keine Vorkenntnisse in R vorausgesetzt; die Inhalte der Veranstaltung \emph{15424 Datenanalyse} werden als bekannt vorausgesetzt.

Bevor es jedoch ans Eingemachte geht, ein paar Worte zur Motivation hinter diesem Seminar: Warum lohnt es sich überhaupt, eine Programmiersprache für die quantitativ-wissenschaftliche Arbeit zu lernen? Und warum ausgerechnet R?

\hypertarget{warum-also-eine-programmiersprache-fuxfcr-datenanalyse-lernen}{%
\subsection*{Warum also eine Programmiersprache für Datenanalyse lernen?}\label{warum-also-eine-programmiersprache-fuxfcr-datenanalyse-lernen}}
\addcontentsline{toc}{subsection}{Warum also eine Programmiersprache für Datenanalyse lernen?}

Wenn Sie bisher Daten statistisch ausgewertet haben, etwa im Rahmen von Forschungsseminaren oder der Bachelorarbeit, wird das in der Regel mit einem Programm mit grafischer Oberfläche erfolgt sein, etwa mit \emph{Microsoft Excel} oder mit \emph{IBM SPSS}. Diese Programme haben viele Vorteile: sie sind meist auf spezifische Funktionen zugeschnitten, in ihrer Aufmachung an typische Computersoftware angepasst und entsprechend intuitiv zu bedienen - ein paar Klicks, und schon gibt SPSS eine Regressionstabelle mit allen relevanten Informationen aus. Für die meisten Anwendungsfälle im KW-Studium bieten genannten Programme leicht zu erlernende und umzusetzende Lösungen an. Programmiersprachen haben hingegen eine zweifellos höhere Einstiegshürde, deren Bewältigung für viele Anwendungsfälle in der Kommunikationswissenschaft auf den ersten Blick keinen größeren Nutzen verspricht.

Vielleicht ist im Studium aber auch schon eine Situation aufgetreten, in der SPSS keine Hilfe bot. Eine Effektstärke für einen Mittelwertvergleich? Die bietet SPSS zwar in Form von \(\eta^2_p\) für die ANOVA an, nicht jedoch Cohen's \(d\) für den t-Test. Sie haben zusammen mit Komilliton*innen eine Inhaltsanalyse geplant und möchten vorab einen Intercoderreliabilitätstest durchführen? SPSS kennt weder die Reliabilität nach Holsti noch Krippendorff's \(\alpha\). Und auch wenn SPSS Grafiken ausgeben kann, so hat es doch einen Grund, warum man diese selten in wissenschaftlichen Veröffentlichungen (und hoffentlich auch in studentischen Arbeiten) findet.

Benötigt man also eine Funktion, die in der gewählten Softwarelösung nicht vorhanden ist, so muss man auf eine andere ausweichen. Programmiersprachen bieten hier deutlich mehr Flexibilität - ist die gewünschte Funktion nicht vorhanden, so schreibt man sie eben selbst (bzw. hat dies in aller Regel schon jemand anderes, der ebenfalls vor diesem Problem stand, für Sie getan). Dies gilt natürlich umso mehr, je weniger standardisiert die zu analysierenden Daten und gewählten Analyseverfahren sind. Beschäftigen wir uns beispielsweise mit Onlinetexten oder digitalen Spurendaten, dann liegen diese oftmals nicht in vorstrukturierter Form vor, müssen erst über Schnittstellen abgerufen, automatisiert heruntergeladen und/oder für die weitere Nutzung aufbereitet werden. Computationale Analyseverfahren wie beispielsweise Verfahren zur automatisierten Inhaltsanalyse werden beständig weiterentwickelt und angepasst. Die Flexibilität, die skriptbasierte Datenanalyse bietet, ist daher einer der Hauptgründe, warum nicht nur in der Wissenschaft, sondern auch in anderen professionellen Kontexten, etwa der Markt- und Medienforschung, wo Lösungen für vielseitige datenanalytische Fragen gesucht werden, die Bedeutung von Programmiersprachen zur Datenanalyse zunimmt.

Zugleich ist der Einstieg in das Programmieren deutlich einfacher geworden. Für viele Programmiersprachen stehen sogenannte Integrierte Entwicklungsumgebungen (IDEs) zur Verfügung, die mittels grafischer Benutzeroberflächen, intuitiver Bedienung und Hilfswerkzeugen (z. B. der automatischen Vervollständigung von Funktionsnamen) den Umgang mit Programmiersprachen deutlich erleichtern und komfortabler gestalten.

Ein weiterer entscheidender Vorteil der \emph{programmatischen}\footnote{d.~h. skript- bzw. codebasiert; im Englischen wird \emph{programmatically} verwendet, um auszudrücken, dass etwas `durch Code' und nicht durch Klicken von Knöpfen in einem Computerprogramm erfolgt ist, im Deutschen ist diese Wortbedeutung außerhalb von Informatikkreisen (noch) kaum geläufig; siehe auch \href{https://german.stackexchange.com/questions/5675/welches-wort-anstelle-von-programmatisch}{diese Diskussion} zur Wortbedeutung.} Datenanalyse ist, dass Skripte und Code alle Analyseschritte nachvollziehbar, transparent und reproduzierbar gestalten (entsprechend wurden Sie in der Datenanalyse-Ausbildung vermutlich auch dazu angehalten, in SPSS stets die Syntax zu nutzen). Einmal durchgeführte Arbeiten können somit jederzeit und problemlos von anderen und auch Ihnen selbst wiederholt und angepasst werden.

Schließlich können auch karrieretechnische Überlegungen eine Rolle spielen. Viele Unternehmen setzen für datenanalytische Tätigkeiten die Kenntnis einer einschlägigen Programmiersprache inzwischen zwingend voraus. Und natürlich spiegelt sich das auch im Gehalt wider: das Vergleichsportal \emph{PayScale} gibt beispielweise für \emph{Data Analysts}, die die \href{https://www.payscale.com/research/US/Job=Data_Analyst/Salary/beb644bc/R}{statistische Programmiersprache R} beherrschen, ein um rund 5.000 US-Dollar höheres Jahresdurchschnittsgehalt an als für diejenigen Data Analysts, die mit \href{https://www.payscale.com/research/US/Job=Data_Analyst/Salary/cc748401/SPSS}{SPSS} arbeiten.

\hypertarget{warum-r-lernen}{%
\subsection*{\texorpdfstring{Warum \emph{R} lernen?}{Warum R lernen?}}\label{warum-r-lernen}}
\addcontentsline{toc}{subsection}{Warum \emph{R} lernen?}

Bisher wurde allgemein von Programmiersprachen gesprochen. In der Datenanalyse-Praxis sind viele unterschiedliche Programmiersprachen gängig, z. B. \emph{Python}, \emph{R}, \emph{SQL} und \emph{Julia}. Wir werden in den kommenden zwei Semestern mit R arbeiten. Dies hat einige Gründe:

\begin{itemize}
\tightlist
\item
  R ist eine speziell auf statistische und datenanalytische Anwendungen ausgelegte Programmiersprache (auch wenn die Anwendungsbereiche inzwischen darüber hinausgehen). Das bedeutet, dass viele gängige statistische Verfahren bereits in der Basis-Version vorhanden sind und ohne weitere Anpassungen genutzt werden können.
\item
  In der \emph{Scientific Community} ist R inzwischen sehr weit verbreitet und wird durch diese kontinuierlich weiterentwickelt. Das bedeutet auch, dass neue Verfahren, sowohl zur Datenerhebung als auch zur Datenanalyse, meist sehr schnell auch in R verfügbar sind.
\item
  Zugleich gibt es durch die weite Verbreitung auch vielzählige Hilfsangebote. In Communities wie \href{https://stackoverflow.com/}{Stack Overflow} und durch googeln werden Sie für nahezu jedes Problem, das sich Ihnen bei der Arbeit mit R stellt, schnell eine Lösung finden.
\item
  R ist komplett kostenlos und für jedes Betriebssystem verfügbar.
\item
  Mit \emph{RStudio} steht eine ebenfalls kostenfreie IDE zur Verfügung, die die ehemals hohen Einstiegshürden erheblich senkt.
\item
  R und RStudio decken durch Erweiterungen nahezu alle Schritte ab, die für die wissenschaftliche Arbeit erforderlich sind. Das reicht vom Datenabruf aus Befragungssoftware sowie der Datenerhebung durch Programmierschnittstellen oder Web Scraping über die Datenbearbeitung, -bereinigung und -analyse bis hin zur Erstellung von Manuskripten und publikationsfähigen Grafiken. Auch dieser Kurs ist komplett in RStudio erstellt.
\end{itemize}

Auch wenn sich R in einigen Aspekten von den oben genannten Programmiersprachen unterscheidet, so sind viele der Konzepte, die wir in den kommenden zwei Semestern lernen werden, auch in anderen Programmiersprachen gleich oder zumindest ähnlich umgesetzt. Ihnen wird es in Zukunft also auch leichter fallen, sich bei Bedarf in andere Programmiersprachen einzuarbeiten.

\hypertarget{hinweise-zur-nutzung-des-online-kurses}{%
\section*{Hinweise zur Nutzung des Online-Kurses}\label{hinweise-zur-nutzung-des-online-kurses}}
\addcontentsline{toc}{section}{Hinweise zur Nutzung des Online-Kurses}

\begin{itemize}
\tightlist
\item
  In der Onlineversion können Sie mit den Cursortasten \texttt{←} und \texttt{→} durch die Seiten des Kurses blättern.
\item
  In der oberen Leiste finden Sie einen Download-Knopf, mit dem Sie sich die aktuelle Version des Kurses als \emph{PDF} oder \emph{EPUB} (für E-Reader) herunterladen können. Bitte achten Sie in diesem Fall darauf, regelmäßig die aktuellste und somit vollständigste Version herunterzuladen. Oben auf dieser Seite ist angegeben, wann der Kurs zuletzt aktualisiert wurde.
\item
  Früher oder später wird etwas in Ihrem Code nicht so funktionieren, wie Sie sich das vorstellen oder wünschen. Hier greift die \href{https://twitter.com/math_rachel/status/764931533383749632}{15-Minuten-Regel}: Versuchen Sie zunächst, 15 Minuten lang das Problem selbst zu lösen - in dem Sie das Problem in kleinere Schritte zerlegen, den Code nach Tippfehlern durchsuchen, nochmals Hilfsdokumente konsultieren etc. Sind Sie nach 15 Minuten noch nicht weitergekommen, fragen Sie um Hilfe - z. B. in unseren Moodle-Foren.
\item
  Der Witz, wonach Programmieren zu 70\% aus Googeln bestehe, hat einen wahren Kern. Es ist nicht verwerflich, im Internet nach Hilfestellungen und Lösungen zu suchen und Code-Schnipsel von anderen zu verwenden - ganz im Gegenteil, gezieltes Suchen stellt einen wesentlichen Teil der Problemlösekompetenz dar. Auch wenn es jedoch verlockend und einfach erscheinen mag, Code von \href{https://stackoverflow.com/}{StackOverflow} und vergleichbaren Portalen zu kopieren, sollten Sie immer versuchen, den Code und damit die Lösung auch nachvollziehen zu können.
\end{itemize}

\begin{figure}
\centering
\includegraphics{img/horst/r_first_then.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

Beginnen wir mit der \protect\hyperlink{firststeps}{Installation von R und RStudio sowie ersten Schritten}.

\hypertarget{part-eine-kurze-einfuxfchrung-in-r}{%
\part{Eine kurze Einführung in R}\label{part-eine-kurze-einfuxfchrung-in-r}}

\hypertarget{firststeps}{%
\chapter{Installation und erste Schritte}\label{firststeps}}

In diesem Kapitel installieren wir die notwendige Software und machen uns mit der Benutzeroberfläche von RStudio vertraut.

\hypertarget{rinstallieren}{%
\section{R installieren}\label{rinstallieren}}

Zunächst benötigen wir natürlich R. Die aktuellste Version erhalten wir immer über \href{https://cran.r-project.org/}{CRAN} (\emph{C}omprehensive \emph{R} \emph{A}rchive \emph{N}etwork).

Unter ``Download and Install R'' wählen wir zunächst unser Betriebssystem. Im Falle von Windows wählen wir zusätzlich auf der folgenden Seite noch ``base'' (die Basisversion) aus. Es sollte dann ein Download-Link für die aktuellste Version erscheinen (3.6.3, Stand 9. April 2020). Der Installationsprozess selbst läuft wie bei anderer Software auch ab.

Neben einem \emph{Interpreter}, einem Programm, das Code (in diesem Fall also Code, der in R geschrieben wurde) für unseren Computer in ausführbare Befehle übersetzt, umfasst die Installation von R auch schon eine (sehr) rudimentäre grafische Benutzeroberfläche, die aber nur wenig komfortabel und nutzerfreundlich ist. Als nächstes installieren wir daher noch RStudio.

\hypertarget{rstudioinstallieren}{%
\section{RStudio installieren}\label{rstudioinstallieren}}

RStudio ist eine grafische Benutzeroberfläche für R, die die Arbeit mit der Programmiersprache deutlich erleichert. Auch RStudio ist für Privatanwender komplett kostenfrei nutzbar. Die aktuellste Version kann über \url{https://rstudio.com/products/rstudio/download/\#download} heruntergeladen werden.

Für den Rest des Kurses arbeiten wir immer mit RStudio (und nicht direkt mit der Oberfläche von R). Öffnen wir also zum ersten Mal RStudio.

\hypertarget{oberflaeche}{%
\section{Die Benutzeroberfläche von RStudio}\label{oberflaeche}}

\begin{figure}
\centering
\includegraphics{img/1/rstudio.png}
\caption{Die Benutzeroberfläche von RStudio}
\end{figure}

Nach dem Starten von RStudio sollte sich das Programm Ihnen wie oben präsentieren - mit einer Dreiteilung in drei abgetrennte Bereiche. Wir beginnen mit dem großen, aktuell noch weitestgehend leeren Bereich auf der linken Seite, der Konsole.

\hypertarget{konsole}{%
\subsection{Konsole}\label{konsole}}

Die Konsole ist zugleich das Eingabe- und das Ausgabefenster von R bzw. RStudio. Befehle, die wir hier eingeben, werden durch Druck auf die \texttt{Eingabe}/\texttt{Enter}-Taste direkt ausgeführt. Die Konsole signalisiert uns, dass sie bereit ist, einen Befehl zu empfangen, durch ein vorangestelltes \texttt{\textgreater{}}. Wir können dies mit simplen Berechnungen ausprobieren:

(Zur Darstellung in diesem Kurs: die erste hellgraue Box umfasst hier und im Folgenden jeweils die Befehle, die wir eingeben - in diesem Fall also den Befehl \texttt{1\ +\ 2}. Die zweite hellgraue Box enthält dann immer die Ausgabe in der Konsole, gekennzeichnet durch zwei vorangestellte Rautensymbole \texttt{\#\#}.)

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Die Konsole spuckt also direkt das Ergebnis aus -- in diesem Fall \texttt{3} -- und wartet auf den nächsten Befehl, wieder zu erkennen am \texttt{\textgreater{}}. Die \texttt{{[}1{]}} links neben dem Ergebnis gibt an, dass es sich hierbei um den ersten (und einzigen) Ausgabewert handelt. Wir werden aber noch zahlreiche Befehle kennenlernen, bei denen mehr als nur ein Wert ausgegeben wird.

Mit den Cursortasten \texttt{↑} und \texttt{↓} können wir in der Konsole durch bisher eingegebene Befehle schalten. Ein Druck auf \texttt{↑} sollte also den ersten und bisher einzigen Befehl - \texttt{1\ +\ 2} - anzeigen.

Ist ein Befehl noch nicht vollständig, signalisiert uns dies die Konsole durch ein vorangestelltes \texttt{+}. Wir können dies ausprobieren, in dem wir beispielsweise eine unvollständigen Additionsbefehl eingeben: \texttt{3\ +}. Die Konsole wartet nun auf den restlichen Befehl - in diesem Fall können wir eine weitere Zahl eingeben und den Befehl abschließen. Alternativ können wir den unvollständigen Befehl durch Druck der \texttt{ESC}-Taste abbrechen.

In der Praxis passiert dies vor allem, wenn in einem längeren Befehl eine Klammer \texttt{)} oder Anführungszeichen \texttt{"} fehlt. Sollte die Konsole also einmal die Arbeit verweigern, liegt das oft daran, dass noch ein unvollständiger Befehl vorhanden ist.

Prinzipiell könnten wir alle Arbeitsschritte über die Konsole ausführen. Das ist in der Praxis aber wenig sinnvoll, da wir im Normalfall längere und mehrere Befehle hintereinander ausführen und diese auch festhalten möchten. Wir arbeiten daher mit Skript-Dateien.

\hypertarget{r-skripte}{%
\subsection{R-Skripte}\label{r-skripte}}

Um eine neue Skriptdatei zu erstellen, klicken wir entweder links oben auf das Symbol mit der leeren Seite und dem grünen Plus und anschließend auf R-Script, auf \emph{File - New File - R-Script} oder drücken die Tastenkombination \texttt{Strg/Cmd\ +\ Shift\ +\ N}. Es sollte sich im links-oberen Bildschirmviertel eine leere Skriptdatei öffnen und unser RStudio-Fenster somit in ein viergeteiltes Layout übergehen:

\includegraphics{img/1/rstudio_script.png}
Hier können wir nun alle Befehle der Reihen der Reihe nach schreiben und gesammelt abspeichern. Einzelne Befehlszeilen lassen sich über die Tastenkombination \texttt{Strg/Cmd\ +\ Eingabe/Enter} ausführen. Das Ergebnis des Befehls erscheint dann in der Konsole. Wir können auch mehrere Zeilen auf einmal markieren und gemeinsam über dieselbe Tastenkombination ausführen. Schreiben wir z. B. mehrere Rechenoperationen hintereinander, so erscheinen deren Ergebnisse in der Ausführungsreihenfolge in der Konsole:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{3}
\DecValTok{12} \OperatorTok{*}\StringTok{ }\DecValTok{25}
\DecValTok{17} \OperatorTok{/}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 300
## [1] 4.25
\end{verbatim}

Längere Skriptdateien werden schnell unübersichtlich. Wir können aber an jeder Stelle Kommentare einfügen, indem wir eine Raute \texttt{\#} voran stellen - alles was in dieser Zeile \emph{hinter} dem Symbol steht, wird von R beim Ausführen ignoriert, wir können also sowohl ganze Zeilen \emph{auskommentieren} als auch hinter R-Befehlen eine kurze Erklärung hinzufügen. Außerdem können jederzeit Leerzeilen eingefügt werden, um das Skript etwas aufzulockern:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Zunächst ein wenig Addition}
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{5}
\DecValTok{6} \OperatorTok{+}\StringTok{ }\DecValTok{12}

\CommentTok{# Dann ein wenig Multiplikation}
\DecValTok{21} \OperatorTok{*}\StringTok{ }\DecValTok{35}
\DecValTok{2345} \OperatorTok{*}\StringTok{ }\FloatTok{1.6}

\CommentTok{# Und zum Schluss etwas komplexere Rechenoperationen}
\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{) }\OperatorTok{^}\StringTok{ }\DecValTok{3} \CommentTok{# Das ^ steht für Exponentiation, hier also 5 hoch 3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
## [1] 18
## [1] 735
## [1] 3752
## [1] 125
\end{verbatim}

Skriptdateien können und sollten natürlich abgespeichert werden - entweder über \emph{File - Save} oder die Tastenkombination \texttt{Strg/Cmd\ +\ S}. R-Skriptdateien erhalten die Dateiendung \texttt{.R}.

\hypertarget{environment}{%
\subsection{Environment}\label{environment}}

Im rechten oberen Bildschrimbereich öffnet sich standardmäßig das \emph{Environment} an, in dem RStudio alle derzeit angelegten und somit verfügbaren Objekte anzeigt. Mit Objekten werden in uns im nächsten Kapitel genauer auseinandersetzen.

Weitere Registerkarten in diesem Bereich sind die \emph{History} (eine Auflistung sämtlicher ausgeführter Zeilen der aktuellen Sitzung) sowie \emph{Connections} und \emph{Build}, die für uns aber vorerst keine Rolle spielen werden.

\hypertarget{files}{%
\subsection{Files}\label{files}}

Der rechte untere Bildschirmbereich zeigt standardmäßig einen Dateibrowser (\emph{Files}) an, der das aktuelle Arbeitsverzeichnis zeigt. Auch damit setzen wir uns in den kommenden Kapiteln ausführlicher auseinander.

Weitere Registerkarten in diesem Bereich sind:

\begin{itemize}
\tightlist
\item
  \emph{Plots}: hier werden Grafiken angezeigt, wenn wir diese in R erstellen.
\item
  \emph{Packages}: Eine Übersicht aller installieren Packages (kurz gesagt Sammlungen von R-Funktionen, die nicht in der Basisversion enthalten sind). Auch mit Packages beschäftigen wir uns in einem eigenen Kapitel.
\item
  \emph{Help}: Hier wird die Dokumentation einzelner Funktionen angezeigt, sobald wir diese anfordern. Diesen Bereich sehen wir uns an, sobald wir uns mit Funktionen beschäftigen.
\item
  \emph{Viewer}: Hier kann RStudio Webinhalte anzeigen, die mit R-Funktionen erstellt wurden. Dies wird vorab keine Rolle für uns spielen.
\end{itemize}

\hypertarget{anpassen}{%
\section{RStudio anpassen}\label{anpassen}}

Unter \emph{Tools - Global Options} können wir RStudio nach unseren Wünschen anpassen. Die einzelnen Einstellungsmöglichkeiten sollen hier nicht ausführlich diskutiert werden; hier jedoch einige sinnvolle Einstellungen:

\begin{figure}
\centering
\includegraphics{img/1/optionen1.png}
\caption{Global Options in RStudio}
\end{figure}

Im Bereich \emph{General} ist es sinnvoll, zwei Anpassungen vorzunehmen. Zum einen können wir unter \emph{R Sessions} ein \emph{Default working directory} (also ein standardmäßiges Arbeitsverzeichnis) einstellen. Dieses Verzeichnis öffnet R dann beim Start automatisch. Hier bietet es sich an, einen eigenen Ordner anzulegen.

Unter \emph{Workspace} entfernen Sie bitte, falls vorhanden, das Häkchen bei \emph{Restore .RData into workspace at startup} und stellen \emph{Save workspace to .RData on exit} auf \emph{Never}. Zwar mag es praktisch erscheinen, dass RStudio automatisch die zuletzt bearbeitete \emph{Session} wiederherstellt, das führt in der Praxis aber gerne zu Konflikten und Problemen -- und letztlich ist es längerfristig auch sinnvoller, sich einen Arbeitsprozess anzueignen, bei dem Skripte schnell den jeweiligen Arbeitsstand wiederherstellen.

\begin{figure}
\centering
\includegraphics{img/1/optionen2.png}
\caption{Anzeigeeinstellungen in RStudio}
\end{figure}

Eher Geschmackssache sind die Anzeigeeinstellungen, die Sie unter \emph{Appearance} vornehmen können. Hier können Sie die Schriftart und -größe im Skripteditor einstellen sowie unter verschiedenen \emph{Themes} (Farbschemata) wählen (darunter auch ``dunkle'' Themes, also solche, die hellen Text auf dunklem Hintergrund bieten). Am besten, Sie probieren hier unterschiedliche Einstellungen aus, bis Sie ein subjektiv angenehmes Anzeigebild von RStudio gefunden haben.

\hypertarget{uxfcbungsaufgaben}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben}}

Diese Aufgaben sollen Sie lediglich mit den grundlegendsten Funktionen von RStudio vertraut machen. Sie müssen daher keine Dateien abgeben.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-5}{}{\label{exr:unnamed-chunk-5} }Installieren Sie R (siehe \ref{rinstallieren}) und RStudio (\ref{rstudioinstallieren}) und nehmen Sie die Einstellungen unter \ref{anpassen} vor.
\EndKnitrBlock{exercise}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-6}{}{\label{exr:unnamed-chunk-6} }Öffnen Sie RStudio und führen Sie ein paar simple Berechnungen in der Konsole durch.
\EndKnitrBlock{exercise}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:unnamed-chunk-7}{}{\label{exr:unnamed-chunk-7} }Erstellen Sie eine neue Skriptdatei und fügen dort mindestens sechs Berechnungen hinzu. Gliedern Sie die Skriptdatei durch einige Kommentare.
\EndKnitrBlock{exercise}

\hypertarget{objekte-und-datenstrukturen}{%
\chapter{Objekte und Datenstrukturen}\label{objekte-und-datenstrukturen}}

Wir können R bzw. RStudio nun als Taschenrechner verwenden und uns arithmetische Operationen direkt in der Konsole ausgeben lassen:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \CommentTok{# Addition}
\DecValTok{1} \OperatorTok{-}\StringTok{ }\DecValTok{2} \CommentTok{# Subtraktion}
\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{2} \CommentTok{# Multiplikation}
\DecValTok{4} \OperatorTok{/}\StringTok{ }\DecValTok{2} \CommentTok{# Division}
\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{5} \CommentTok{# Exponentiation}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
## [1] -1
## [1] 4
## [1] 2
## [1] 32
\end{verbatim}

Wirklich sinnvoll ist dies aber nicht: wir wollen Ergebnisse ja auch speichern und weiterverwenden können. Hierfür benötigen wir Variablen, also Namen, denen wir (veränderliche) Werte zuordnen können.

In R lassen sich Variablen erstellen, indem wir einer Zeichenkette (zu den Benennungsregeln kommen wir gleich) einen Wert mittels \texttt{\textless{}-} zuordnen (hierfür entweder die Zeichen \texttt{\textless{}} und \texttt{-} eingeben oder die Tastenkombination \texttt{Alt/Option\ +\ -} drücken).\footnote{Es ist prinzipiell auch möglich, die Zuordnung mittels einem \texttt{=} vorzunehmen. Da das \texttt{=} aber auch in anderen Kontexten benötigt wird, erzeugt dies Verwirrung, sodass wir Objekte immer mit \texttt{\textless{}-} zuordnen sollten.} Dies erstellt ein \emph{Objekt}\footnote{Die Begriffe Variable und Objekt können für unsere Zwecke weitestgehend synonym verwendet werden. Wir werden aber gleich noch sehen, das so ziemlich alles in R ein Objekt sein kann.} mit eben diesem Namen und der entsprechenden Zuordnung:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Führen wir diesen Befehl aus, erstellen wir das Objekt \texttt{x} und ordnen den Wert \texttt{2} zu. Wir sollten diese neue Zuordnung zudem im rechten oberen \emph{Environment}-Bereich sehen können.

Wir können nun mit diesem Objekt weiterrechnen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{5}
\NormalTok{x }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 7
## [1] 1
\end{verbatim}

Um den aktuellen Wert eines Objektes anzuzeigen, können wir auch einfach das Objekt ausführen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

Generell wird bei der Zuordnung immer zunächst der Teil rechts vom \texttt{\textless{}-} ausgeführt und dann zugeordnet. Wir können also auch komplexere Befehle ausführen und diese Zuordnen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{3} \OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

Objekte sind veränderlich und können jederzeit neu zugeordnet werden - und dabei auch selbst bei der Zuordnung verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\NormalTok{x}
\NormalTok{x <-}\StringTok{ }\DecValTok{3}
\NormalTok{x}
\NormalTok{x <-}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
## [1] 3
## [1] 2
\end{verbatim}

Schauen wir uns das einmal in einem etwas komplexeren Beispiel an - welchen Wert hat \texttt{b} am Ende dieser Befehlskette?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{/}\StringTok{ }\DecValTok{2}
\NormalTok{a <-}\StringTok{ }\NormalTok{b }\OperatorTok{*}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\NormalTok{a}
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{-}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Die Antwort lautet \texttt{15}. Gehen wir das der Reihe nach durch:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zunächst ordnen wir \texttt{a} den Wert \texttt{10} zu.
\item
  Dann orden wir \texttt{b} den Wert \texttt{a\ /\ 2} zu. Da \texttt{a} in diesem Schritt \texttt{10} zugeordnet ist, wird \texttt{10\ /\ 2} gerechnet. \texttt{b} entspricht nun also dem Wert \texttt{5}.
\item
  Wir ordnen nun \texttt{a} den Wert \texttt{b\ *\ 2\ +\ a} zu. Der gesamte Teil rechts vom \texttt{\textless{}-} wird zuerst ausgeführt und dann zugeordnet, hier also \texttt{5\ *\ 2\ +\ 10}. \texttt{a} entspricht nun dem Wert \texttt{20}, b weiterhin dem Wert \texttt{5}.
\item
  Zuletzt ordnen wir \texttt{b} das Ergebnis von \texttt{a\ -\ b} zu, was vor dieser Zuordnung \texttt{20\ -\ 5} bedeutet. \texttt{b} entspricht schlussendlich also \texttt{15}.
\end{enumerate}

Nochmals die wichtigsten Punkte zusammengefasst:

\begin{itemize}
\tightlist
\item
  Mit \texttt{\textless{}-} erstellen wir Objekte und ordnen diesen Werte zu.
\item
  Alle Objekte sind veränderlich und können überschrieben werden.
\item
  Bei einer Zuordnung wird der gesamte Teil rechts vom Zuordnungspfeil \texttt{\textless{}-} zuerst ausgeführt und dann die Zuordnung vorgenommen.
\end{itemize}

\hypertarget{objektnamen}{%
\section{Objektnamen}\label{objektnamen}}

Für die obigen Beispiele haben wir nur einzelne Buchstaben für Objekte verwendet. In der Praxis können und sollten wir längere Objektnamen verwenden. Dabei gelten folgende Regeln:

\begin{itemize}
\tightlist
\item
  Objektnamen können Groß- und Kleinbuchstaben, Ziffern sowie Punkte \texttt{.} und Unterstriche \texttt{\_} beinhalten. Andere Sonderzeichen, Umlaute und Leerzeichen sind nicht gestattet.
\item
  Objektnamen können mit einem Buchstaben oder einem \texttt{.} beginnen, nicht jedoch mit Ziffern oder \texttt{\_}.
\item
  Objektnamen sind \emph{case-sensitive}, d.~h. unterscheiden zwischen Groß- und Kleinschreibung. \texttt{myVar} und \texttt{myvar} sind also unterschiedliche Objekte.
\end{itemize}

Es ist sinnvoll, Objekten ``sprechende'' Namen zu geben, sodass andere (und auch Sie zu einem späteren Zeitpunkt) nachvollziehen können, was sich dahinter verbirgt, auch ohne den gesamten Code zu lesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Gute Objektnamen}
\NormalTok{mittelwert <-}\StringTok{ }\FloatTok{2.5}
\NormalTok{mein_alter <-}\StringTok{ }\DecValTok{32}
\NormalTok{groesse_in_cm <-}\StringTok{ }\DecValTok{175}

\CommentTok{# Schlechte Objektnamen}
\NormalTok{x1 <-}\StringTok{ }\FloatTok{2.5}
\NormalTok{var2 <-}\StringTok{ }\DecValTok{32}
\NormalTok{asdasdasd <-}\StringTok{ }\DecValTok{175}
\end{Highlighting}
\end{Shaded}

Es gibt außerdem unterschiedliche Konventionen, um mehrere Wörter in Objektnamen aneinanderzuhängen. \texttt{mein\_alter} ist ein Beispiel für den sogenannten \emph{snake\_case}: Alle Wörter kleingeschrieben und durch einen Unterstrich \texttt{\_} miteinander verbunden. Einen Überblick über verbreitete Konventionen der Objektbenennung gibt folgende Illustration:

\begin{figure}
\centering
\includegraphics{img/horst/coding_cases.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

Was auch immer Sie wählen - wichtig ist vor allem, dass Sie einheitlich vorgehen.\footnote{Aufmerksamen Leser*innen dürfte zudem aufgefallen sein, dass \emph{kebab-case} in R nicht möglich ist.}

\hypertarget{objekttypen}{%
\section{Objekttypen}\label{objekttypen}}

Bisher haben wir lediglich Zahlen Objekten zugewiesen. Natürlich können Daten aber auch in anderen Formen vorliegen; wir sprechen daher von verschiedenen \emph{Objekttypen}.\footnote{Tatsächlich ist die Sache etwas komplexer: es gibt in R einige wenige Kernobjekttypen, die wiederum mit bestimmten Attributen versehen werden können, um daraus zusätzliche Objekttypen abzuleiten. So kann etwa eine Zahlenfolge mit einem zusätzlichen Attribut als Datumsangabe interpretiert werden. Für unsere Zwecke spielt diese Unterscheidung jedoch keine Rolle.}

\hypertarget{numerische-objekte}{%
\subsection{Numerische Objekte}\label{numerische-objekte}}

Zahlenwerte werden in R als \texttt{numeric} bezeichnet. Wir können hier zudem zwischen den Typen \texttt{integer} (ganze Zahlen) und \texttt{double} (Kommazahlen\footnote{Der Typenbezeichnung leitet sich von \href{https://de.wikipedia.org/wiki/Doppelte_Genauigkeit}{Gleitkommazahlen mit doppelter Genauigkeit} ab.}) unterscheiden.

Grundsätzlich ordnet R Zahlen als \texttt{double} zu, auch wenn nur ganze Zahlen zugeordnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{4}
\KeywordTok{typeof}\NormalTok{(x) }\CommentTok{# Mit dieser Funktion können wir den Objekttyp anfordern}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "double"
\end{verbatim}

Um explizit den Typ \texttt{integer} anzufordern, muss Zahlenwerten ein \texttt{L} nachgestellt werden:\footnote{Warum \texttt{L}? Hier gibt es unterschiedliche Erklärungsansätze, die beispielsweise \href{https://stackoverflow.com/questions/22191324/clarification-of-l-in-r/22192378\#22192378}{hier} nachgelesen werden können}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{4L}
\KeywordTok{typeof}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

In der Praxis macht es aber kaum einen Unterschied, ob eine ganze Zahl als \texttt{integer} oder \texttt{double} abgespeichert wird -- \texttt{integer} verbraucht weniger Speicherplatz, aber das wird erst bei \emph{sehr} großen Datensätzen relevant. Wir können die Unterscheidung also guten Gewissens ignorieren und von numerischen Objekten sprechen.

\hypertarget{textobjekte}{%
\subsection{Textobjekte}\label{textobjekte}}

Wir können Objekten auch Text zuordnen - diese Objekte haben dann den Typ \texttt{character} (Textvariablen werden zudem häufig als ``string'' bezeichnet). Um ein \texttt{character}-Objekt zu erstellen, müssen wir die Zeichenkette in einfache \texttt{\textquotesingle{}\textquotesingle{}} oder doppelte \texttt{""} Anführungszeichen setzen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text1 <-}\StringTok{ "Guten Morgen!"}
\NormalTok{text2 <-}\StringTok{ 'Einfache Anführungszeichen sind sinnvoll, wenn im "Text" ebenfalls Anführungszeichen vorkommen'}
\end{Highlighting}
\end{Shaded}

Natürlich können auch Zahlen als Text gespeichert werden - werden dann aber natürlich auch als Text behandelt, sodass man nicht mehr mit ihnen rechnen kann.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahl_als_text <-}\StringTok{ "123"}
\end{Highlighting}
\end{Shaded}

\hypertarget{logicals}{%
\subsection{Logicals (logische Objekte)}\label{logicals}}

Der dritte Kernobjekttyp heißt \texttt{logical} und kann nur zwei Werte annehmen: \texttt{TRUE} (wahr) oder \texttt{FALSE} (falsch). Logicals entstehen durch logische Vergleiche zweier Objekte, wobei u.a. folgende Operatoren verwendet werden können:

\begin{longtable}[]{@{}lll@{}}
\caption{\label{tab:logischeoperatoren} Logische Operatoren in R}\tabularnewline
\toprule
Operator & Vergleich & Beispiele\tabularnewline
\midrule
\endfirsthead
\toprule
Operator & Vergleich & Beispiele\tabularnewline
\midrule
\endhead
\texttt{==} & ist gleich & \texttt{1\ ==\ 1} (ergibt \texttt{TRUE})\texttt{"a"\ ==\ "b"} (ergibt \texttt{FALSE})\tabularnewline
\texttt{!=} & ist nicht gleich & \texttt{1\ !=\ 1} (ergibt \texttt{FALSE})\texttt{"a"\ !=\ "b"} (ergibt \texttt{TRUE})\tabularnewline
\texttt{\textless{}} & ist kleiner als & \texttt{1\ \textless{}\ 2} (ergibt \texttt{TRUE})\texttt{2\ \textless{}\ 2} (ergibt \texttt{FALSE})\tabularnewline
\texttt{\textgreater{}} & ist größer als & \texttt{2\ \textgreater{}\ 1} (ergibt \texttt{TRUE})\texttt{2\ \textgreater{}\ 2} (ergibt \texttt{FALSE})\tabularnewline
\texttt{\textless{}=} & ist kleiner gleich & \texttt{1\ \textless{}=\ 2} (ergibt \texttt{TRUE})\texttt{2\ \textless{}=\ 2} (ergibt \texttt{TRUE})\tabularnewline
\texttt{\textgreater{}=} & ist größer gleich & \texttt{2\ \textgreater{}=\ 1} (ergibt \texttt{TRUE})\texttt{2\ \textgreater{}=\ 2} (ergibt \texttt{TRUE})\tabularnewline
\bottomrule
\end{longtable}

Die Zuordnung erfolgt wie bei anderen Objekten auch:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ "a"} \OperatorTok{==}\StringTok{ "b"}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Logicals werden vor allem bei Wenn-Dann-Bedingungen benötigt, mit denen wir uns im übernächsten Kapitel auseinandersetzen werden.

\hypertarget{weitere-objekttypen}{%
\subsection{Weitere Objekttypen}\label{weitere-objekttypen}}

Diese drei Objekttypen (\texttt{numeric}, \texttt{character}, \texttt{logical}) bilden die Basis fast aller Objekte in R. Durch zusätzliche Attribute können jedoch noch zusätzliche Objekttypen erzeugen, die den Umgang mit bestimmten Daten erleichtern. Für kategoriale Variablen kennt R beispielsweise den Typ \texttt{factor}, für Datumsangaben den Typ \texttt{date}. Diese werden bei der Zuordnung nicht automatisch erkannt und müssen stattdessen durch bestimmte Funktionen erzeugt werden.

Erzeugen wir beispielsweise ein Objekt mit einer Zeichenfolge, die ein Datum repräsentiert (z. B. \texttt{date1\ \textless{}-\ "2020-05-05"}, im Format \emph{YYYY\_MM\_DD}, also Jahr-Monat-Tag), speichert R dies zunächst als \texttt{character} ab. Wir können aber R explizit sagen, dass er dies als Datum behandeln soll:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date2 <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2020-05-05"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Dies hat nun u.a. den Vorteil, dass wir im Gegensatz zu \texttt{character}-Objekten auch arithmetische Operationen durchführen können, also beispielsweise zwei Datums-Objekte voneinander subtrahieren, um die zeitliche Differenz zu berechnen.

Wir werden uns im späteren Verlauf noch ausführlicher mit diesen spezielleren Objekttypen beschäftigen -- bis jetzt nehmen Sie vor allem mit, dass sowohl kategoriale Variablen als auch Datumsangaben kein Problem für R darstellen.

\hypertarget{missingvals}{%
\subsection{Fehlende Werte}\label{missingvals}}

Fehlende Werte werden in R als \texttt{NA} angegeben. Es ist sinnvoll, fehlende Werte immer explizit als \texttt{NA} zu kennzeichnen und nicht etwa durch einen negativen Wert bei numerischen Variablen (z. B. \texttt{-9}) oder durch einen leeren String bei Textvariablen (\texttt{""}), damit sichergestellt ist, dass Funktionen den fehlenden Wert auch entsprechend als einen solchen behandeln.

\hypertarget{coercion}{%
\subsection{Objekttypen ändern}\label{coercion}}

Bisweilen wird es relevant sein, Objekttypen zu ändern - etwa weil Zahlen fälschlicherweise als Text eingelesen wurden. Hierfür bietet R Funktionen an, die allesamt nach dem Schema \texttt{as.{[}Objekttyp{]}()} aufgebaut sind: mit \texttt{as.numeric()} wandeln wir Objekte in numerische Objekte um (genauer gesagt in \texttt{double}), mit \texttt{as.character()} in Textobjekte und, wie im vorigen Abschnitt gesehen, mit \texttt{as.Date()} in ein Datumsobjekt. Der Fachbegriff hierfür lautet \emph{Coercion}, wir \emph{zwingen} R also dazu, ein Objekt als einen bestimmten Typ zu behandeln, auch wenn R automatisch einen anderen Typus bestimmt hätte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ "25"}
\NormalTok{x1}
\KeywordTok{typeof}\NormalTok{(x1)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"25"}\NormalTok{)}
\NormalTok{x2 }\CommentTok{# Beachten Sie, dass in der Ausgabe nun die Anführungszeichen fehlen}
\KeywordTok{typeof}\NormalTok{(x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "25"
## [1] "character"
## [1] 25
## [1] "double"
\end{verbatim}

Natürlich klappt das nur, solange die Umwandlung auch sinnvoll durchführbar ist -- in allen anderen Fällen wird eine Warnung ausgegeben und es werden fehlende Werte erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"Dieser Text kann nicht sinnvoll als Zahl interpretiert werden"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs durch Umwandlung erzeugt
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\hypertarget{datenstrukturen}{%
\section{Datenstrukturen}\label{datenstrukturen}}

Bisher haben wir einem Objekt immer nur einen einzigen Wert zugeordnet. Der Fachbegriff hierfür lautet \emph{Skalar} und beschreibt somit die einfachst mögliche Datenstruktur, eben dass einem Objekt nur ein einziger Wert zugeordnet wurde. Objekte können in R jedoch auch mehrere Werte enthalten und somit komplexere Datenstrukturen erzeugen.

Im Folgen betrachten wir daher die vier wichtigsten komplexeren Datenstrukturen in R. Diese unterscheiden sich zum einen in ihrer Dimensionalität (also ob sie ein- oder zweidimensional sind) und zum anderen, ob sie homogene (also nur dieselben) oder heterogene (also unterschiedliche) Objekttypen beinhalten können:

\begin{longtable}[]{@{}lll@{}}
\caption{\label{tab:datenstrukturen} Datenstrukturen in R}\tabularnewline
\toprule
Datenstruktur & Dimensionalität & Objekttypen\tabularnewline
\midrule
\endfirsthead
\toprule
Datenstruktur & Dimensionalität & Objekttypen\tabularnewline
\midrule
\endhead
Vektor & eindimensional & homogen\tabularnewline
Liste & eindimensional & heterogen\tabularnewline
Matrix & zweidimensional & homogen\tabularnewline
Dataframe & zweidimensional & heterogen\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{vectors}{%
\subsection{Vektoren}\label{vectors}}

Vektoren sind Objekte, die mehrere Werte desselben Typs beinhalten. Wir erzeugen Vektoren über die Funktion \texttt{c()} (von \emph{concatenate}, also verketten). Die einzelnen Elemente des Vektors werden durch Kommas \texttt{,} getrennt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gerade_zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\NormalTok{gerade_zahlen}
\NormalTok{ungerade_zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{ungerade_zahlen}
\NormalTok{simpsons <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Homer Simpson"}\NormalTok{, }\StringTok{"Marge Simpson"}\NormalTok{, }\StringTok{"Bart Simpson"}\NormalTok{, }\StringTok{"Lisa Simpson"}\NormalTok{, }\StringTok{"Maggie Simpson"}\NormalTok{)}
\NormalTok{simpsons}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8
## [1] 1 3 5 7 9
## [1] "Homer Simpson"  "Marge Simpson"  "Bart Simpson"   "Lisa Simpson"   "Maggie Simpson"
\end{verbatim}

Wir können auch Vektoren über \texttt{c()} mit einander verketten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(gerade_zahlen, ungerade_zahlen)}
\NormalTok{zahlen}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8 1 3 5 7 9
\end{verbatim}

Beachten Sie, dass die Verkettung immer in der angegebenen Reihenfolge erfolgt -- R sortiert die Elemente also nicht automatisch.

\hypertarget{vektorelemente-auswuxe4hlen}{%
\subsubsection{Vektorelemente auswählen}\label{vektorelemente-auswuxe4hlen}}

Um bestimmte Elemente eines Vektors auszuwählen, können wir die gewünschten Elemente in eckigen Klammern \texttt{{[}{]}} hinter einem Vektor definieren. Hier geben wir nur das zweite Element des oben erzeugten \texttt{zahlen}-Vektors aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Um mehrere Elemente eines Vektors auszugeben, benötigen wir wiederum einen Vektor mit den gewünschten Positionen -- hier geben wir uns beispielsweise das erste, dritte und fünfte Element aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 6 1
\end{verbatim}

\hypertarget{vektorelemente-benennen}{%
\subsubsection{Vektorelemente benennen}\label{vektorelemente-benennen}}

Elemente in Vektoren können benannt werden, indem beim Erstellen die Namen der Elemente mit einem \texttt{=} angegeben werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{nachname =} \StringTok{"Simpson"}\NormalTok{, }\DataTypeTok{vorname =} \StringTok{"Homer"}\NormalTok{, }\DataTypeTok{wohnort =} \StringTok{"Springfield"}\NormalTok{)}
\NormalTok{homer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      nachname       vorname       wohnort 
##     "Simpson"       "Homer" "Springfield"
\end{verbatim}

Benannte Elemente können dann auch über den Namen ausgewählt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer[}\StringTok{"wohnort"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       wohnort 
## "Springfield"
\end{verbatim}

Auch dies funktioniert mit mehreren Elementen gleichzeitig:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{homer[}\KeywordTok{c}\NormalTok{(}\StringTok{"vorname"}\NormalTok{, }\StringTok{"nachname"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   vorname  nachname 
##   "Homer" "Simpson"
\end{verbatim}

Alternativ können Elementnamen im Nachhinein über die Funktion \texttt{names()} hinzugefügt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{marge <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Simpson"}\NormalTok{, }\StringTok{"Marge"}\NormalTok{, }\StringTok{"Springfield"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(marge) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"nachname"}\NormalTok{, }\StringTok{"vorname"}\NormalTok{, }\StringTok{"wohnort"}\NormalTok{)}
\NormalTok{marge}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      nachname       vorname       wohnort 
##     "Simpson"       "Marge" "Springfield"
\end{verbatim}

\hypertarget{vectorarithmetics}{%
\subsubsection{Mit Vektoren rechnen}\label{vectorarithmetics}}

Mit numerischen Vektoren können arithmetische Berechnungen durchgeführt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{zahlen }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3  5  7  9  2  4  6  8 10
## [1]  4  8 12 16  2  6 10 14 18
\end{verbatim}

Berechnungen werden dabei der Reihe nach für jedes einzelne Vektorelement durchgeführt. Es ist auch möglich, Vektoren gleicher Länge zu addieren, subtrahieren etc. -- im Falle einer Addition wird dann das erste Element des ersten Vektors zum ersten Element des zweiten Vektors addiert, dann das zweite Element des ersten Vektors zum zweiten Element des zweiten Vektors usw.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{x1 }\OperatorTok{*}\StringTok{ }\NormalTok{x2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2  9 20
\end{verbatim}

\hypertarget{nuxfctzliche-vektorfunktionen}{%
\subsubsection{Nützliche Vektorfunktionen}\label{nuxfctzliche-vektorfunktionen}}

Abschließend einige nützliche Funktionen für den Umgang mit Vektoren:

\begin{itemize}
\tightlist
\item
  \texttt{length()} gibt die Anzahl der Elemente eines Vektors aus.
\item
  Die unter \ref{coercion} eingeführten \emph{Coercion}-Funktionen (\texttt{as.numeric()}, \texttt{as.character()} usw.) können auch auf Vektoren angewendet werden und wandeln so jedes Vektorelement um.
\item
  Für numerische Vektoren stehen zahlreiche statistische Funktionen bereit, z. B. zur Berechnung der Summe (\texttt{sum()}), des arithmetischen Mittels (\texttt{mean()}) und der Standardabweichung (\texttt{sd()})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{999}\NormalTok{)}
\KeywordTok{length}\NormalTok{(x)}
\KeywordTok{sum}\NormalTok{(x)}
\KeywordTok{mean}\NormalTok{(x)}
\KeywordTok{sd}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
## [1] 1065
## [1] 266.25
## [1] 488.5846
\end{verbatim}

Oftmals benötigen wir aufsteigende Zahlenfolgen für Vektoren, beispielsweise für laufende Nummern. Dies lässt sich über die Funktion \texttt{:} abkürzen, die einen Vektor \texttt{Startwert:Endwert} erstellt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eins_bis_zehn <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{eins_bis_zehn}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\hypertarget{listen}{%
\subsection{Listen}\label{listen}}

Listen ähneln zunächst Vektoren und werden mit der Funktion \texttt{list()} erzeugt. Auch die Benennung von Listenelementen erfolgt analog zu Vektoren entweder beim Erstellen der Liste mit \texttt{=} oder im Nachhinein mit \texttt{names()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{name =} \StringTok{"München", bundesland = "}\NormalTok{Bayern}\StringTok{", bezirk = "}\NormalTok{Oberbayern}\StringTok{")}
\StringTok{munich_facts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $name
## [1] "München"
## 
## $bundesland
## [1] "Bayern"
## 
## $bezirk
## [1] "Oberbayern"
\end{verbatim}

Wir sehen aber bereits am Konsolenoutput, dass die Darstellung von Vektoren abweicht: anstatt alle Elemente nebeneinander angezeigt zu bekommen, werden die einzelnen Elemente untereinander angezeigt.

Das rührt daher, dass Listen deutlich mächtiger und flexibler sind als Vektoren. Nicht nur können wir in den einzelnen Elementen Objekttypen mischen, wir sind auch nicht auf einzelne Werte (Skalare) als Elemente beschränkt. Tatsächlich kann so gut wie jedes Objekt ein Listenelement sein -- also auch Vektoren, ganze Datensätze und sogar Listen (die wiederum eigene Listen enthalten können -- wir können hier also Daten prinzipiell endlos verschachteln). Erweitern wir dazu die Liste von oben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{namen =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{hochdeutsch =} \StringTok{"München", englisch = "}\NormalTok{Munich}\StringTok{", bairisch = "}\NormalTok{Minga}\StringTok{"),}
\StringTok{  bundesland = "}\NormalTok{Bayern}\StringTok{",}
\StringTok{  gruendungsjahr = 1158,}
\StringTok{  daten = list(}
\StringTok{    einwohner = 1471508,}
\StringTok{    geographie = c(flaeche_in_km2 = 310.7, hoehe_NHN_in_m = 519)}
\StringTok{  )}
\StringTok{)}
\StringTok{munich_facts}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $namen
## hochdeutsch    englisch    bairisch 
##   "München"    "Munich"     "Minga" 
## 
## $bundesland
## [1] "Bayern"
## 
## $gruendungsjahr
## [1] 1158
## 
## $daten
## $daten$einwohner
## [1] 1471508
## 
## $daten$geographie
## flaeche_in_km2 hoehe_NHN_in_m 
##          310.7          519.0
\end{verbatim}

Mit ihrer Flexibilität stellen Listen in R die Basis für nahezu alle komplexeren Datenstrukturen -- auch bei Datensätze, Regressionsmodellen etc. handelt es sich um Listen, die mit bestimmten Attributen versehen wurden.

\hypertarget{listenelemente-auswuxe4hlen}{%
\subsubsection{Listenelemente auswählen}\label{listenelemente-auswuxe4hlen}}

Auch die Auswahl von Listenelementen funktioniert ähnlich wie bei Vektoren über die numerische Position oder den Elementnamen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $namen
## hochdeutsch    englisch    bairisch 
##   "München"    "Munich"     "Minga"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts[}\StringTok{"daten"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $daten
## $daten$einwohner
## [1] 1471508
## 
## $daten$geographie
## flaeche_in_km2 hoehe_NHN_in_m 
##          310.7          519.0
\end{verbatim}

Vielleicht ist Ihnen bereits das Dollarsymbol \texttt{\$} vor den Elementnamen aufgefallen -- dieses verweist auf eine Funktion, mit der Listenelemente noch komfortabler ausgewählt werden können:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts}\OperatorTok{$}\NormalTok{bundesland}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Bayern"
\end{verbatim}

Nicht nur sparen Sie sich ein paar Zeichen bei der Eingabe, RStudio macht Ihnen auch automatisch Vorschläge, sobald Sie das Dollarzeichen eingetippt haben (im Beispiel also ab \texttt{munich\_facts\$}), welche Elemente sie auswählen können. Auch tiefer verschachtelte Elemente können so ausgewählt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts}\OperatorTok{$}\NormalTok{daten}\OperatorTok{$}\NormalTok{einwohner}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1471508
\end{verbatim}

\hypertarget{nuxfctzliche-listenfunktionen}{%
\subsubsection{Nützliche Listenfunktionen}\label{nuxfctzliche-listenfunktionen}}

Auch für Listen stehen einige nützliche Funktionen zur Verfügung, die die Arbeit mit ihnen erleichtern.

\texttt{length} gibt wie auch schon bei Vektoren die Anzahl der Elemente aus (wobei auch komplexere Elemente, also z. B. Vektoren, Listen etc., jeweils als ein Element gezählt werden):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(munich_facts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Spezifisch für Listen relevant ist die Funktion \texttt{str()}, die zusätzliche Informationen über die Struktur der Liste ausgibt, was gerade bei verschachtelteren Listen den Überblick erleichtert:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(munich_facts)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 4
##  $ namen         : Named chr [1:3] "München" "Munich" "Minga"
##   ..- attr(*, "names")= chr [1:3] "hochdeutsch" "englisch" "bairisch"
##  $ bundesland    : chr "Bayern"
##  $ gruendungsjahr: num 1158
##  $ daten         :List of 2
##   ..$ einwohner : num 1471508
##   ..$ geographie: Named num [1:2] 311 519
##   .. ..- attr(*, "names")= chr [1:2] "flaeche_in_km2" "hoehe_NHN_in_m"
\end{verbatim}

Wir sehen, dass die Liste \texttt{munich\_facts} aus 4 Elementen besteht \texttt{List\ of\ 4}. Das erste Element trägt den Namen \texttt{namen} ist ein benannter \texttt{character}-Vektor (abgekürzt durch \texttt{chr}) mit 3 Elementen (Angabe \texttt{{[}1:3{]}}) usw.

Durch die komplexe Struktur sind Listen jedoch nicht so einfach zu handhaben. Mittels der Funktion \texttt{unlist()} können Listen daher in Vektoren (inkl. Elementnamen, soweit vorhanden) umgewandelt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munich_facts_vector <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(munich_facts)}
\NormalTok{munich_facts_vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##               namen.hochdeutsch                  namen.englisch                  namen.bairisch                      bundesland 
##                       "München"                        "Munich"                         "Minga"                        "Bayern" 
##                  gruendungsjahr                 daten.einwohner daten.geographie.flaeche_in_km2 daten.geographie.hoehe_NHN_in_m 
##                          "1158"                       "1471508"                         "310.7"                           "519"
\end{verbatim}

\hypertarget{matrizen}{%
\subsection{Matrizen}\label{matrizen}}

Matrizen sind Vektoren, die in eine zweidimensionale Struktur, also Zeilen und Spalten, überführt werden und können mit der Funktion \texttt{matrix()} erstellt werden. Hierzu ist zusätzlich noch die Anzahl an Zeilen, in die der Vektor aufgeteilt werden soll, nötig:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10} \CommentTok{# Zahlen von 1 bis 10 als Vektor}
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(x, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{) }\CommentTok{# Vektor in Matrix mit zwei Zeilen aufteilen}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
\end{verbatim}

Alternativ können wir mehrere Vektoren mit den Funktionen \texttt{cbind()} spaltenweise (von \emph{c}olumn) und \texttt{rbind()} zeilenweise (von \emph{r}ow) zu einer Matrix ``zusammenkleben''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{x2 <-}\StringTok{ }\DecValTok{5}\OperatorTok{:}\DecValTok{8}
\NormalTok{x3 <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{3}
\NormalTok{m <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(x1, x2, x3)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      x1 x2 x3
## [1,]  1  5  0
## [2,]  2  6  1
## [3,]  3  7  2
## [4,]  4  8  3
\end{verbatim}

\hypertarget{matrizen-benennen}{%
\subsubsection{Matrizen benennen}\label{matrizen-benennen}}

Auch Matrizen können benannt werden. Da wir nun aber eine zweidimensionale Struktur haben, können wir entsprechend auch Zeilen und Spalten einzeln benennen. Hierfür gibt es die Funktionen \texttt{rownames()} und \texttt{colnames()}, die analog zu \texttt{names()} verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"spalte_1"}\NormalTok{, }\StringTok{"spalte_2"}\NormalTok{, }\StringTok{"spalte_3"}\NormalTok{)}
\KeywordTok{rownames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"zeile_a"}\NormalTok{, }\StringTok{"zeile_b"}\NormalTok{, }\StringTok{"zeile_c"}\NormalTok{, }\StringTok{"zeile_d"}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         spalte_1 spalte_2 spalte_3
## zeile_a        1        5        0
## zeile_b        2        6        1
## zeile_c        3        7        2
## zeile_d        4        8        3
\end{verbatim}

\hypertarget{nuxfctzliche-matrixfunktionen}{%
\subsubsection{Nützliche Matrixfunktionen}\label{nuxfctzliche-matrixfunktionen}}

\texttt{length()} funktioniert auch für Matrizen und gibt die Anzahl aller Elemente an. Interessieren wir uns dagegen für die Anzahl an Zeilen und Spalten, gibt die Funktion \texttt{dim()} Aufschluss, die einen Vektor mit der Anzahl der Zeilen und der Anzahl der Spalten ausgibt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(m)}
\KeywordTok{dim}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
## [1] 4 3
\end{verbatim}

Die Funktion \texttt{t()} transponiert die Matrix, dreht die Matrix also um 90 Grad und vertauscht somit Zeilen und Spalten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{t}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          zeile_a zeile_b zeile_c zeile_d
## spalte_1       1       2       3       4
## spalte_2       5       6       7       8
## spalte_3       0       1       2       3
\end{verbatim}

\hypertarget{dataframes}{%
\subsection{Dataframes}\label{dataframes}}

Mit Matrizen kommen wir der Datensatzstruktur, wie wir sie von SPSS oder Excel kennen, schon recht nahe. Allerdings repräsentieren Matrizen Vektoren und sind daher auf einen Objekttyp beschränkt. Diese Einschränkung hebt die Datenstruktur \emph{Dataframe} auf, mit der gleich lange Vektoren unterschiedlichen Typs kombiniert werden können. Wir erstellen Dataframes mit der gleichnamigen Funktion \texttt{data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beatles_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{name =} \KeywordTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Paul"}\NormalTok{, }\StringTok{"George"}\NormalTok{, }\StringTok{"Ringo"}\NormalTok{),}
  \DataTypeTok{surname =} \KeywordTok{c}\NormalTok{(}\StringTok{"Lennon"}\NormalTok{, }\StringTok{"McCartney"}\NormalTok{, }\StringTok{"Harrison"}\NormalTok{, }\StringTok{"Starr"}\NormalTok{),}
  \DataTypeTok{born =} \KeywordTok{c}\NormalTok{(}\DecValTok{1940}\NormalTok{, }\DecValTok{1942}\NormalTok{, }\DecValTok{1943}\NormalTok{, }\DecValTok{1940}\NormalTok{)}
\NormalTok{)}
\NormalTok{beatles_data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name   surname born
## 1   John    Lennon 1940
## 2   Paul McCartney 1942
## 3 George  Harrison 1943
## 4  Ringo     Starr 1940
\end{verbatim}

Wenn wir mit tabellarischen Daten arbeiten, geschieht das also in der Regel mit Dataframes. Natürlich wäre es nicht zielführend, wenn wir diese immer von Hand erstellen müssten. Es gibt daher Funktionen, mit denen wir externe Dateien (z. B. CSV-, Excel- und sogar SPSS-Dateien) als Dataframes in R laden können. Wie wir externe Dateien laden, schauen wir uns zu einem späteren Zeitpunkt genauer an.

\hypertarget{beispiel-dataframes}{%
\subsubsection{Beispiel-Dataframes}\label{beispiel-dataframes}}

R enthält einige eingebaute Beispiel-Dataframes, mit denen Funktionen demonstriert und geübt werden können. Keiner davon hat auch nur einen geringen KW-Bezug, aber damit wir nun auch ohne große Erstellungs-Arbeit mit Dataframes arbeiten können, nutzen wir diese dennoch. Wir werden aber bald auch mit für Sie relevanteren Daten arbeiten, versprochen.

Diese Beispiel-Datensätze sind direkt als Objekte hinterlegt und können durch Eingabe des Objektnamens genutzt werden. Wir arbeiten nun mit dem Datensatz \texttt{iris}, der Blütenblatt- und Kelchblatt-Daten zu je 50 Exemplaren dreier Spezies von Schwertlilien (englisch \emph{iris}) umfasst. Wie gesagt, keinerlei KW-Bezug, aber immerhin ein Grund, um den Text kurz durch einige Blumenfotos aufzulockern.

\begin{figure}
\centering
\includegraphics{img/2/iris.png}
\caption{Drei Schwertlilien-Spezies im \texttt{iris}-Datensatz, von links nach rechts: Borsten-Schwertlilie (\emph{iris setosa}), verschiedenfarbige Schwertlilie (\emph{iris versicolor}) und Virginia-Schwertlilie (\emph{iris virginica}). Fotos: Radomił Binek, Danielle Langlois und Eric Hunt.}
\end{figure}

\hypertarget{arbeiten-mit-dataframes}{%
\subsubsection{Arbeiten mit Dataframes}\label{arbeiten-mit-dataframes}}

Dataframes basieren auf Listen und Vektoren (genau genommen ist ein Dataframe eine Liste von gleich langen Vektoren, die zweidimensional dargestellt wird). Entsprechend können wir eine Vielzahl der Funktionen, die wir bei Listen und Vektoren kennengelernt haben, auch auf Dataframes anwenden.

In der Regel haben wir Datensätze, die mehr als nur ein paar Fälle umfassen. Sie in der Konsole ausgeben zu lassen, ist daher nur bedingt sinnvoll. Besser ist es, Informationen über die Struktur des Datensatzes über Funktionen abzufragen.

Die \texttt{length()}-Funktion gibt bei Dataframes die Anzahl der Spalten zurück (wir erinnern uns: Dataframes sind Listen, deren Elemente die Spaltenvektoren sind; entsprechend ermittelt \texttt{length()} daher die Anzahl der Vektoren). Die Anzahl der Zeilen -- mithin die Anzahl der Fälle -- gibt die Funktion \texttt{nrow()} aus. Beide Werte gemeinsam können wir erneut über \texttt{dim()} ausgeben.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(iris)}
\KeywordTok{nrow}\NormalTok{(iris)}
\KeywordTok{dim}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
## [1] 150
## [1] 150   5
\end{verbatim}

Wir sehen, dass der \texttt{iris}-Datensatz 5 Spalten (= Variablen) und 150 Zeilen (= Fälle) umfasst. Für einen Überblick bietet sich wie auch schon bei Listen die \texttt{str()}-Funktion an.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    150 obs. of  5 variables:
##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
##  $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
\end{verbatim}

Der Datensatz umfasst also 4 numerische Variablen (jeweils Länge und Breite des Blüten- (\emph{sepal}) und des Kelchblattes (\emph{petal})) sowie eine kategoriale Faktorvariable mit 3 Stufen, in der die Spezies des jeweiligen Exemplars festgehalten ist.

150 Fälle à 5 Variablen wären im Konsolenoutput sehr lang und unübersichtlich. Wollen wir dennoch in unsere Daten spähen, können wir uns mittels \texttt{head()} und \texttt{tail()} die ersten bzw. letzten Zeilen des Datensatzes ausgeben. Standardmäßig werden bei beiden Funktionen 6 Fälle angezeigt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
\end{verbatim}

R bietet auch einen Viewer, mit dem der gesamte Datensatz ähnlich wie ein Tabellenblatt in Excel oder die Datenansicht in SPSS angezeigt wird. Hierzu führen wir die Funktion \texttt{View()} aus (großes \texttt{V} beachten), woraufhin in RStudio ein eigener Reiter mit der Datenansicht geöffnet wird.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{View}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{img/2/irirs-view.png}
\caption{Die Datenansicht von R}
\end{figure}

In der Datenansicht können wir den Datensatz nach Variablen sortieren oder bestimmte Wertebereiche je Variable filtern; in der Fußzeile werden Strukturinformationen (Zeilen- und Spaltenanzahl) angezeigt. Fährt man mit dem Mauszeiger über die Kopfzeilen der Variablen, werden zudem weitere Informationen (Objekttyp und Wertebereich) eingeblendet.

Um einzelne Variablen (also Spalten bzw. die dahinterliegenden Vektoren) auszuwählen, können wir wie auch bei Listen das \texttt{\$}-Zeichen nutzen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris}\OperatorTok{$}\NormalTok{Sepal.Length}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8
##  [32] 5.4 5.2 5.5 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9
##  [63] 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8
##  [94] 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3
## [125] 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9
\end{verbatim}

Das Resultat hat den Objekttyp Vektor. Wir können daher die uns bekannten Vektorfunktionen auf das Resultat anwenden. Um beispielsweise den Mittelwert der Kelchblattbreite zu erhalten, geben wir folgendes ein:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Width)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.199333
\end{verbatim}

Auch die eckigen Klammern \texttt{{[}{]}} können genutzt werden, um flexibler nur bestimmte Teile des Datensatzes anzuzeigen. Dabei ist die zweidimensionale Struktur zu beachten -- wir können zwei Werte bzw. Vektoren, getrennt durch ein \texttt{,}, übergeben, die dann die Zeilen respektive die Spalten anwählt. Um etwa die ersten zehn Zeilen der Variablen \texttt{Sepal.Length} und \texttt{Petal.Length} auszuwählen, ist folgender Code nötig:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"Sepal.Length"}\NormalTok{, }\StringTok{"Petal.Length"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Petal.Length
## 1           5.1          1.4
## 2           4.9          1.4
## 3           4.7          1.3
## 4           4.6          1.5
## 5           5.0          1.4
## 6           5.4          1.7
## 7           4.6          1.4
## 8           5.0          1.5
## 9           4.4          1.4
## 10          4.9          1.5
\end{verbatim}

Sollen lediglich Zeilen oder nur Spalten gefiltert werden, lassen wir den jeweiligen Wert vor (Zeilen) oder nach dem \texttt{,} (Spalten) leer. Folgender Code gibt die Zeilen 5-10 und alle Spalten aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris[}\DecValTok{5}\OperatorTok{:}\DecValTok{10}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
\end{verbatim}

Auch die Benennung von Dataframes läuft analog zu den bisherigen Objekttypen ab. Um etwa die Variablen einzudeutschen, können wir wieder \texttt{names()} nutzen\footnote{Da Dataframes eine zweidimensionale Struktur darstellen, können wir auch die Funktionen \texttt{colnames()} und \texttt{rownames()}, die wir von den Matrizen kennen, verwenden, um die Spalten respektive Zeilen umzubenennen. \texttt{colnames()} und \texttt{names()} sind bei Dataframes äquivalent; Zeilennamen sind eher unüblich. In der Praxis wird daher meistens lediglich \texttt{names()} verwendet.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(iris) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"bluetenblatt_laenge"}\NormalTok{, }\StringTok{"bluetenblatt_breite"}\NormalTok{, }
                 \StringTok{"kelchblatt_laenge"}\NormalTok{, }\StringTok{"kelchblatt_breite"}\NormalTok{,}
                 \StringTok{"spezies"}\NormalTok{)}
\KeywordTok{head}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   bluetenblatt_laenge bluetenblatt_breite kelchblatt_laenge kelchblatt_breite spezies
## 1                 5.1                 3.5               1.4               0.2  setosa
## 2                 4.9                 3.0               1.4               0.2  setosa
## 3                 4.7                 3.2               1.3               0.2  setosa
## 4                 4.6                 3.1               1.5               0.2  setosa
## 5                 5.0                 3.6               1.4               0.2  setosa
## 6                 5.4                 3.9               1.7               0.4  setosa
\end{verbatim}

Falls Ihnen das nun umständlich erscheint -- keine Sorge, wir werden, sobald wir uns ans richtige Datenmanagement begeben, Funktionen kennenlernen, die die obigen Schritte deutlich erleichtern. Für das Grundverständnis ist es aber wichtig, auch diese Art der Arbeit mit Dataframes kennenzulernen.

\hypertarget{uxfcbungsaufgaben-1}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-1}}

Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als \texttt{ue2\_nachname.R} ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue2-1}{}{\label{exr:ue2-1} }Objekttypen und Datenstrukturen I:
\EndKnitrBlock{exercise}

Erstellen Sie ein Objekt \texttt{myself}, das folgende Elemente enthält:

\begin{itemize}
\tightlist
\item
  \texttt{name}: Ihren Namen
\item
  \texttt{born}: Ihr Geburtsjahr
\item
  \texttt{from\_bavaria}: Sind Sie in Bayern geboren?
\end{itemize}

Welche Datenstruktur ist hierfür am sinnvollsten? Welche Objekttypen haben die einzelnen Elemente?

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue2-2}{}{\label{exr:ue2-2} }Vektorfunktionen, Objekttypen und -umwandlung:
\EndKnitrBlock{exercise}

Führen Sie folgenden Code aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{values <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{1.2}\NormalTok{, }\FloatTok{1.3}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{1.5}\NormalTok{, }\FloatTok{1.1}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.1}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{1.1}\NormalTok{)}
\NormalTok{average <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(values)}
\NormalTok{above_average <-}\StringTok{ }\NormalTok{values }\OperatorTok{>}\StringTok{ }\NormalTok{average}
\KeywordTok{sum}\NormalTok{(above_average) }\OperatorTok{/}\StringTok{ }\KeywordTok{length}\NormalTok{(values)}
\end{Highlighting}
\end{Shaded}

Beschreiben Sie in eigenen Worten, was hier in jeder Zeile passiert. Was bedeutet das Resultat der letzten Codezeile? Warum wird hier überhaupt ein Resultat ausgeben? Schauen Sie sich hierzu an, was passiert, wenn Sie \texttt{above\_average} in einen numerischen Vektor umwandeln.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue2-3}{}{\label{exr:ue2-3} }Arbeiten mit Dataframes:
\EndKnitrBlock{exercise}

Im Beispiel-Datensatz \texttt{mtcars} sind einige Daten zu verschiedenen KfZ-Modellen hinterlegt. Beantworten Sie die folgenden Fragen zum Datensatz mittels Funktionen:

\begin{itemize}
\tightlist
\item
  Wie viele Variablen und Fälle befinden sich in dem Datensatz?
\item
  Welche der drei Objekttypen (\texttt{numeric}, \texttt{character}, \texttt{logical}) kommen in dem Datensatz vor?
\item
  Wie viele Zylinder haben die enthaltenen Fahrzeuge im Durchschnitt? (Zylinder: \texttt{cyl})
\item
  Erstellen Sie einen neuen Datensatz \texttt{cars\_short}, der lediglich die Variablen \texttt{mpg} und \texttt{hp} enthält.
\end{itemize}

\hypertarget{funktionen}{%
\chapter{Funktionen}\label{funktionen}}

Wir haben bereits im vorherigen Kapitel einige Funktionen eingesetzt. Tatsächlich ist \emph{alles}, was in R ausgeführt wird, eine Funktion. Zeit also, dass wir uns etwas detaillierter mit Funktionen auseinandersetzen.

\hypertarget{funktionen-aufrufen}{%
\section{Funktionen aufrufen}\label{funktionen-aufrufen}}

In den allermeisten Fällen rufen wir Funktionen nach dem folgenden Schema auf:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{funktionsname}\NormalTok{(}\DataTypeTok{argument1 =}\NormalTok{ wert1, }\DataTypeTok{argument2 =}\NormalTok{ wert2, }\DataTypeTok{argument3 =}\NormalTok{ wert3, ...)}
\end{Highlighting}
\end{Shaded}

Der Funktionsname wird gefolgt von Klammern \texttt{()}, in die in aller Regel mindestens ein \emph{Argument} übergeben wird.\footnote{Da der Funktionsname vor den Argumenten steht, wird hierbei auch von \emph{Prefix}-Funktionen gesprochen. Wir haben im vorherigen Kapitel auch schon zwei andere Arten von Funktionen kennengelernt: \emph{Infix}-Funktionen, bei dir der Funktionsname zwischen zwei Argumenten steht (dazu zählen beispielsweise alle arithmetischen Operatoren, z. B. \texttt{+}, \texttt{-}, \texttt{*} und \texttt{/}), und \emph{Replacement}-Funktionen, die Teile eines bestehenden Objekts direkt verändern (z. B. \texttt{names(x)\ \textless{}-}). Das sind aber Spezialfälle -- im Alltag werden wir vorrangig Prefix-Funktionen verwenden.} Die Funktion gibt daraufhin ein \emph{Resultat} oder eine \emph{Fehlermeldung} zurück, wobei das Resultat jede Datenstruktur in R annehmen kann -- also sowohl einzelne Werte als auch komplexe Listen oder Dataframes.

Da Funktionen im Erfolgsfall immer exakt ein Resultat ausgeben, können wir dieses problemlos wiederum einem Objekt zuweisen und weiterverwenden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean_petal_length <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length)}
\end{Highlighting}
\end{Shaded}

\hypertarget{funktionsargumente}{%
\subsection{Funktionsargumente}\label{funktionsargumente}}

Funktionen benötigen mindestens ein Argument, oft auch mehrere Argumente, um korrekt ausgeführt zu werden. Oftmals umfassen Funktionsargumente zum einen (Daten-)Objekte, die von der Funktion verwendet werden sollen, zum anderen ``Optionen'', die die Funktion berücksichtigen soll.

Die Funktion \texttt{round()}, die numerische Werte rundet, beispielsweise hat zwei Argumente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{x}: ein numerischer Vektor, der gerundet werden soll.
\item
  \texttt{digits}: ein Integer, der angibt, auf wie viele Dezimalstellen gerundet werden soll.
\end{enumerate}

Der vollständige Funktionsaufruf läuft dementsprechend in der Form \texttt{round(x,\ digits)} ab:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{round}\NormalTok{(pi, }\DecValTok{1}\NormalTok{) }\CommentTok{# Die Kreiszahl Pi ist direkt als Objekt in R hinterlegt}
\KeywordTok{round}\NormalTok{(pi, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.1
## [1] 3.142
\end{verbatim}

\hypertarget{funktionsargumente-uxfcbergeben}{%
\subsubsection{Funktionsargumente übergeben}\label{funktionsargumente-uxfcbergeben}}

Funktionsargumente können auf zwei Arten übergeben werden: zum einen implizit, wie im obigen Beispiel, durch die Reihenfolge der Funktionsargumente; zum anderen explizit über den Namen des Funktionsarguments in der Form \texttt{argument\ =\ wert}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{round}\NormalTok{(pi, }\DecValTok{2}\NormalTok{)}
\KeywordTok{round}\NormalTok{(pi, }\DataTypeTok{digits =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.14
## [1] 3.14
\end{verbatim}

In diesem Fall macht es keinen Unterschied, ob wir explizit \texttt{digits\ =} angeben oder nicht. In der Praxis ist es jedoch üblich, maximal die ersten ein oder zwei Funktionsargumente unbenannt zu übergeben, alle anderen Argumente jedoch benannt zu übergeben. Gerade bei Funktionen mit vielen Argumenten müssen Sie so zum einen nicht die exakte Reihenfolge der Argumente einhalten, zum anderen wird ihr Code auch für andere nachvollziehbarer und lesbarer.

Schauen wir uns hierzu als zweites Beispiel die schon bekannte \texttt{mean()}-Funktion an und nutzen sie mit einigen zusätzlichen, uns noch nicht bekannten Argumenten. Was passiert wohl hier?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length, }\FloatTok{0.1}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.76
\end{verbatim}

Ohne Kenntnis der Funktionsargumente ist dieser Aufruf schwer nachzuvollziehen -- wir berechnen wohl den Mittelwert der Variablen \texttt{Petal.Length} im Datensatz \texttt{iris}, aber was bedeutet der Rest? Durchschaubarer wird es, wenn wir die beiden hinteren Argumente mit ihrem Namen übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.76
\end{verbatim}

Hier können wir anhand der Argumentnamen Vermutungen anstellen, auch ohne die genaue Funktion zu kennen. \texttt{trim} wird wohl bedeuten, dass ein bestimmter Anteil der Werte getrimmt, also abgeschnitten wird. Tatsächlich gibt \texttt{trim} den Anteil der niedrigsten und höchsten Werte an, der nicht bei der Berechnung berücksichtigt wird -- nützlich, um den Einfluss von Ausreißern auf den Mittelwert abzuschwächen. In unserem Fall, \texttt{trim\ =\ 0.1}, schließen wir also die untersten und obersten 10\% der Werte aus. Mit \texttt{na.rm\ =\ TRUE} geben wir an, dass etwaige fehlende Werte \texttt{NA} vor der Berechnung aus dem Vektor entfernt werden sollen (\texttt{rm} steht hier also für ``remove'').

Die Benennung erlaubt es uns nun auch, die Reihenfolge der Argumente im Funktionsaufruf zu tauschen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.76
\end{verbatim}

Natürlich könnten wir auch das erste Argument benennen, aber das verspricht -- auch ob des generischen Namens \texttt{x} -- keinen zusätzlichen Erkenntnisgewinn und wäre wohl eher Overkill:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ iris}\OperatorTok{$}\NormalTok{Petal.Length, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.76
\end{verbatim}

Die mittlere Variante -- implizite Übergabe des ersten Funktionsarguments, explizite Nennung der weiteren Funktionsargumente -- stellt also das gesunde Mittelmaß aus Kürze und Lesbarkeit dar.

\hypertarget{defaultvalues}{%
\subsubsection{Default-Werte von Argumenten}\label{defaultvalues}}

Wenn die \texttt{mean()}-Funktion drei Argumente besitzt, wie war es uns dann bisher möglich, sie mit nur einem Argument zu übergeben? Funktionsargumente, die eher Optionen als zwingende Voraussetzung für eine Funktion darstellen, haben in R oftmals \emph{Default}-Werte -- Standardwerte, auf die die Funktion zurückgreift, wenn diese nicht im Funktionsaufruf angegeben wurden. So ist es auch bei der \texttt{mean()}-Funktion, die wie folgt definiert ist: \texttt{mean(x,\ trim\ =\ 0,\ na.rm\ =\ FALSE)}:

\begin{itemize}
\tightlist
\item
  \texttt{x} hat keinen Default-Wert und muss daher zwingend angegeben werden. Ohne Angabe von \texttt{x} wird eine Fehlermeldung zurückgegeben.
\item
  \texttt{trim} hat einen Default-Wert von \texttt{0}, ohne Angabe von \texttt{trim} werden also keine Werte abgeschnitten.
\item
  \texttt{na.rm} hat einen Default-Wert von \texttt{FALSE}, standardmäßig werden fehlende Werte also nicht ausgeschlossen.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mean.default(): Argument "x" fehlt (ohne Standardwert)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

In der Regel haben insbesondere Argumente, die eher eine Option denn zwingende Voraussetzung für die Ausführung einer Funktion darstellen, Default-Werte, sodass diese bei der gebräuchlichsten Verwendung weggelassen werden können.

\hypertarget{hilfestellungen-zu-funktionen}{%
\subsection{Hilfestellungen zu Funktionen}\label{hilfestellungen-zu-funktionen}}

R und RStudio bieten verschiedene Möglichkeiten, Hilfestellungen zu Funktionen anzuzeigen -- also z. B. zur Verwendung der Funktion, ihren Argumenten, den zugehörigen Default-Werten usw.

Tippen Sie einen Funktionsnamen ein, so macht Ihnen R Vorschläge, welche Funktion Sie meinen könnten. Daneben wird ein Tooltip angezeigt, der die Funktion beschreibt. Geben Sie beispielsweise die Buchstaben \texttt{rou} in ein R-Skript oder die Konsole ein, sollten Sie nach kurzer Zeit eine Auswahl von Funktionen sehen, die mit eben diesen Buchstaben beginnen, darunter an erster Stelle die \texttt{round()}-Funktion. Die anderen vorgeschlagenen Funktionen können Sie mit den Cursortasten ↑ und ↓ wählen. Neben der ausgewählten Funktion wird die Funktionsbeschreibung angezeigt.

Drücken Sie nun die \texttt{tab}-Taste, wird nicht nur die Funktion inklusive Klammern \texttt{()} eingefügt; ein Tooltip zeigt Ihnen zudem noch die Argumente am. Im Falle der \texttt{round()}-Funktion sollte \texttt{round(x,\ digits\ =\ 0)} angezeigt werden. Daran sehen Sie, dass \texttt{round()} zwei Argumente annimmt -- ein Argument \texttt{x} ohne Default-Wert und ein Argument \texttt{digits} mit dem Default-Wert \texttt{0} -- ohne Angabe des \texttt{digits}-Arguments rundet \texttt{round()} also standardmäßig auf ganze Zahlen ohne Nachkommastellen.

Oftmals benötigen Sie jedoch noch mehr Informationen zu einer Funktion. In diesem Fall können Sie vor einen beliebigen Funktionsnamen ein \texttt{?} stellen und ausführen -- dieser Befehl öffnet die Dokumentationsseite der jeweiligen Funktion im Bereich rechts unten in RStudio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?}\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{img/3/mean-documentation.png}
\caption{Dokumentation der \texttt{mean()}-Funktion}
\end{figure}

Dokumentationsseiten in R sind zumeist nach demselben Schema aufgebaut:

\begin{itemize}
\tightlist
\item
  Beschriftung der Funktion. In Falle von \texttt{mean()} also ``Arithmetic Mean''.
\item
  \emph{Description}: Kurze Beschreibung der Funktion.
\item
  \emph{Usage}: Verwendung der Funktion. Anhand von \texttt{mean(x,\ trim\ =\ 0,\ na.rm\ =\ FALSE,\ ...)} können wir die Argumente und deren Default-Werte ablesen. Die \texttt{...} weisen hier auf einen Spezialfall hin, dass bestimmte Objekttypen und Datenstrukturen noch zusätzliche Argumente für die Funktion bereitstellen können -- dies braucht uns an dieser Stelle aber nicht weiter zu kümmern.
\item
  \emph{Arguments}: Hier werden alle Argumente der Funktion aufgelistet und ausführlicher beschrieben. Wir erfahren im Falle von \texttt{mean()} beispielsweise, welche Objekttypen für \texttt{x} unterstützt werden, was \texttt{trim} bedeutet etc.
\item
  \emph{Value}: Hier wird das Resultat, das die Funktion ausgibt, beschrieben.
\end{itemize}

Außerdem können Funktionsdokumentationen noch weitere Abschnitte, beispielsweise Verwendungsbeispiele oder Literaturverweise, enthalten. Es ist daher immer sinnvoll, vor der ersten Verwendung einer Funktion die zugehörige Dokumentation zu konsultieren.

\hypertarget{eigene-funktionen-erstellen}{%
\section{Eigene Funktionen erstellen}\label{eigene-funktionen-erstellen}}

Wir wissen nun einiges über Funktionen; tatsächlich reicht unser Wissen sogar schon aus, um eigene Funktionen zu \emph{programmieren}. Wir beschäftigen uns daher abschließend in diesem Kapitel mit der Frage, warum und wann wir eigene Funktionen schreiben sollten, und schauen uns an, wie wir unseren Code in Funktionen übersetzen und so weiterverwertbar machen.

\hypertarget{funktionen-erstellen-wann-und-warum}{%
\subsection{Funktionen erstellen: wann und warum?}\label{funktionen-erstellen-wann-und-warum}}

Viele Schritte in der Datenaufbereitung und -analye wiederholen sich: oft müssen wir mehrere Variablen transformieren, meistens führen wir zur Deskription die gleichen oder zumindest ähnliche Schritte durch, interessieren uns bei Auswertungsverfahren immer wieder für die gleichen Kennwerte.

Funktionen sind das zentrale Element des Programmierens. Im Prinzip handelt es sich bei Funktionen um Code-Fragmente oder Skripte, die durch die Verwendung von ``Platzhaltern'' (= Variablen, Argumente) so angepasst werden, dass sie immer wieder auf vergleichbare Problemstellungen angewendet werden können.

Nehmen wir das Beispiel der Variablendeskription. Wenn wir Daten erhoben haben, sind wir bei metrischen Variablen in der Regel zunächst an den selben Kennwerten interessiert: der Anzahl der Werte, dem arithmetischen Mittel, der Standardabweichung, dem Minimum und Maximum, eventuell noch dem Median oder anderen Perzentilen. Mit unserem bisherigen Wissen (und drei neuer, aber ebenso einfacher Funktionen) können wir diese Kennwerte einzeln anfordern, zum Beispiel für die Variable \texttt{Sepal.Length} im Beispiel-Datensatz \texttt{iris}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Anzahl Werte}
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Arithmetisches Mittel}
\KeywordTok{sd}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Standardabweichung}
\KeywordTok{min}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Minimum}
\KeywordTok{max}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Maximum}
\KeywordTok{median}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length) }\CommentTok{# Median}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 150
## [1] 5.843333
## [1] 0.8280661
## [1] 4.3
## [1] 7.9
## [1] 5.8
\end{verbatim}

Die Ausgabe ist jedoch etwas unübersichtlich. Schöner wird es, wenn wir alle Werte in einem benannten Vektor ablegen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sepal_length_descriptives <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\NormalTok{)}

\NormalTok{sepal_length_descriptives}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           n           M          SD     Minimum     Maximum      Median 
## 150.0000000   5.8433333   0.8280661   4.3000000   7.9000000   5.8000000
\end{verbatim}

Das sieht doch gleich übersichtlicher aus -- in einem Vektor haben wir alle relevanten Werte gespeichert und können diese auf einen Schlag anzeigen.

Nun haben wir im \texttt{iris}-Datensatz aber noch weitere Variablen, die wir ebenfalls auf diese Art beschreiben möchten (ganz zu schweigen von zukünftigen Datensätzen, für deren Variablen diese Beschreibung ebenfalls relevant ist). Wir könnten natürlich den obigen Code für jede weitere Variablen kopieren und den Variablennamen austauschen; das würde aber unser Skript unnötig aufblähen und unübersichtlicher machen.

Sobald Sie Code(-Fragmente) mehrfach verwenden möchten, ist daher der Zeitpunkt gekommen, darübernachzudenken, ob es nicht sinnvoll ist, ihn in eine Funktion umzuwandeln. Dies hat einige entscheidende Vorteile:

\begin{itemize}
\tightlist
\item
  Code ist einfacher wiederzuverwenden. Anstatt mehrerer Codezeilen ist in Zukunft für dasselbe Ergebnis dann nur noch eine Codezeile -- der Funktionsaufruf -- erforderlich.
\item
  Skripte werden weniger redundant und dadurch übersichtlicher.
\item
  Fehlerkorrekturen und Anpassungen werden vereinfacht -- möchten wir im obigen Beispiel etwa noch einen weiteren Kennwert (z. B. die Spannweite) ergänzen, müssten wir den Code für jede einzelne Variable erneut anpassen; hätten wir eine entsprechende Funktion, wäre die Anpassung nur einmal im Funktionscode nötig.
\end{itemize}

Schauen wir uns also an, wie wir aus obigen Code eine Funktion erstellen können.

\hypertarget{aufbau-und-erstellung-von-funktionen}{%
\subsection{Aufbau und Erstellung von Funktionen}\label{aufbau-und-erstellung-von-funktionen}}

Funktionen in R sind ebenfalls Objekte und werden dementsprechend erstellt: indem einem Objektnamen durch den Zuweisungs-Operator \texttt{\textless{}-} die Funktion zugewiesen wird. Neben dem Namen haben Funktionen zwei zentrale Komponenten:

\begin{itemize}
\tightlist
\item
  die Funktionsargumente, wie wir sie auch schon vom Aufruf von eingebauten Funktionen kennen
\item
  den \emph{Body} der Funktion, der den Code enthält, den die Funktion ausführt
\end{itemize}

Die Erstellung von Funktionen läuft dabei nach folgendem Schema ab:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funktionsname <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(argument_}\DecValTok{1}\NormalTok{, argument_}\DecValTok{2}\NormalTok{) \{}
  \CommentTok{# Body: Code, der ausgeführt wird}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir weisen also einem Objektnamen ein Funktionsobjekt zu; dies geschieht mit der Funktion \texttt{function()}, wobei wir innerhalb der Klammern die \emph{Argumente} definieren, die wir im Code der Funktion verwenden möchten. Zwischen zwei geschweiften Klammern \texttt{\{\}} steht dann der Code, den wir ausführen wollen.

Sehen wir uns nochmals unser obiges Beispiel an:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sepal_length_descriptives <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length),}
  \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Um den Code auf eine andere Variable anzuwenden, müssten wir jeweils \texttt{iris\$Sepal.Length} ersetzen -- z. B. durch \texttt{iris\$Sepal.Width}, \texttt{iris\$Petal.Length} oder eine Variable aus einem anderen Datensatz. Wir möchten diesen Teil also durch einen Platzhalter ersetzen, den wir dann als Funktionsargument übergeben können. Mit einem generischen Platzhalter, den wir der Einfachheit halber (und vollkommen willkürlich!) als \texttt{x} bezeichnen, sähe der Code also wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
  \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x),}
  \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x),}
  \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x),}
  \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x),}
  \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Zuletzt müssen wir diesen Code nun nur noch als Funktion einem Objekt zuweisen -- und dabei unserer Funktionen einen treffenden Namen geben, z. B. \texttt{descriptives}, und dabei \texttt{x} als Funktionsargument definieren:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{ }\CommentTok{# Wir definieren 'x' als Argument}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x),}
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Einmal ausgeführt, taucht unsere neue Funktion nun in unserer Arbeitsumgebung auf (siehe den Bereich \emph{Environment} rechts oben in RStudio, in dem \texttt{descriptives} nun unter \emph{Functions} erscheinen sollte) und wir können Sie auf beliebige Vektoren anwenden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\end{Highlighting}
\end{Shaded}

Nur warum sehen wir keine Ausgabe? Das liegt daran, dass wir noch nicht definiert haben, was die Funktion zurückgeben soll. Wir erstellen derzeit lediglich den Vektor \texttt{descriptives\_vector}, machen aber noch nichts mit ihm -- ähnlich, wie uns die Konsole noch keine Ausgabe anzeigt wenn wir ein Objekt lediglich zuweisen.

\hypertarget{ruxfcckgabe-werte}{%
\subsubsection{Rückgabe-Werte}\label{ruxfcckgabe-werte}}

Es gibt zwei Möglichkeiten, die Ausgabe einer Funktion zu definieren:

\begin{itemize}
\tightlist
\item
  generell wird das zuletzt im Funktionscode ausgegebene Objekt zurückgegeben. Wir könnten also im Funktionscode ganz am Ende noch eine Zeile hinzufügen, in der unser neu erstellter Vektor ausgeben wird, in dem wir einfach den Objektnamen tippen \texttt{descriptives\_vector}.
\item
  mit der speziellen Funktion \texttt{return()} können wir im Funktionscode explizit ein im Funktionscode erstelltes Objekt angeben, das zurückgegeben werden soll.
\end{itemize}

Wir müssen also noch eine kleine Anpassung vornehmen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x),}
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x)}
\NormalTok{  )}
  
  \KeywordTok{return}\NormalTok{(descriptives_vector) }\CommentTok{# Oder alternativ: lediglich 'descriptives_vector'}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Unsere Funktion ist nun flexibel für numerische Vektoren einsetzbar:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           n           M          SD     Minimum     Maximum      Median 
## 150.0000000   5.8433333   0.8280661   4.3000000   7.9000000   5.8000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          n          M         SD    Minimum    Maximum     Median 
## 150.000000   3.758000   1.765298   1.000000   6.900000   4.350000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        n        M       SD  Minimum  Maximum   Median 
## 6.000000 3.500000 1.870829 1.000000 6.000000 3.500000
\end{verbatim}

\hypertarget{fargsdef}{%
\subsubsection{Funktionsargumente und Default-Werte}\label{fargsdef}}

Unsere Funktion funktioniert also schon ganz gut; im nächsten Schritt möchten wir sie aber noch verbessern, um auch Problemfälle abzudecken. Schauen wir uns einmal an, was passiert, wenn wir einen numerischen Vektor mit fehlenden Werten übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       n       M      SD Minimum Maximum  Median 
##       5      NA      NA      NA      NA      NA
\end{verbatim}

Wir sehen, dass alle Kennwerte (außer der Anzahl der Werte) ebenfalls \texttt{NA} sind. Wir erinnern uns, dass Funktionen wie \texttt{mean()} oder \texttt{sd()} bei vorhandenen fehlenden Werten auch einen fehlenden Wert zurückgeben -- es sei denn, wir übergeben zusätzlich das Argument \texttt{na.rm\ =\ TRUE}, sodass fehlende Werte vor der Berechnung gelöscht werden. Wir möchten dieses Argument nun auch in unserer Funktion nutzen.

Hierzu benötigen wir ein weiteres Funktionsargument, das wir dann als Platzhalter für das \texttt{na.rm}-Argument der jeweiligen Kennwert-Funktionen verwenden können. Aus Konsistenzgründen nennen wir es ebenfalls \texttt{na.rm}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, na.rm) \{ }\CommentTok{# Wir fügen ein weiteres Argument 'na.rm' hinzu...}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),      }\CommentTok{# ... und übergeben dessen Wert an }
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),       }\CommentTok{# das jeweilige 'na.rm'-Argument der}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm), }\CommentTok{# Kennwert-Funktionen}
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm)}
\NormalTok{  )}
  
  \KeywordTok{return}\NormalTok{(descriptives_vector)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir können unsere Funktion nun auch für Vektoren mit fehlenden Werten verwenden, indem wir analog zu \texttt{mean()}, \texttt{sd()} usw. das Argument \texttt{na.rm\ =\ TRUE} übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        n        M       SD  Minimum  Maximum   Median 
## 5.000000 2.500000 1.290994 1.000000 4.000000 2.500000
\end{verbatim}

Allerdings ist unsere Funktion nun weniger komfortabel einzusetzen, wenn wir dieses Argument weglassen möchten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mean(x, na.rm = na.rm): Argument "na.rm" fehlt (ohne Standardwert)
\end{verbatim}

Wie wir unter \ref{defaultvalues} gesehen haben, haben viele Funktionsargumente, die eher optionalen Charakter aufweisen, Default-Werte. Wir können diese ganz einfach bei der Erstellung definieren, indem wir den Default-Wert per \texttt{=} dem jeweiligen Funktionsargument zuweisen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{FALSE}\NormalTok{) \{ }\CommentTok{# Default-Wert für 'na.rm' = FALSE}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm), }
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm)}
\NormalTok{  )}
  
  \KeywordTok{return}\NormalTok{(descriptives_vector)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dieser Default-Wert wird nun also immer verwendet, wenn wir das Argument nicht angegeben haben. Unsere Funktion ist somit noch flexibler geworden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Width)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           n           M          SD     Minimum     Maximum      Median 
## 150.0000000   1.1993333   0.7622377   0.1000000   2.5000000   1.3000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       n       M      SD Minimum Maximum  Median 
##       5      NA      NA      NA      NA      NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        n        M       SD  Minimum  Maximum   Median 
## 5.000000 2.500000 1.290994 1.000000 4.000000 2.500000
\end{verbatim}

\hypertarget{uxfcbungsaufgaben-2}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-2}}

Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als \texttt{ue3\_nachname.R} ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue3-1}{}{\label{exr:ue3-1} }Funktionen aufrufen und Dokumentation konsultieren:
\EndKnitrBlock{exercise}

Die Funktion \texttt{seq()} kann verwendet werden, um Zahlenfolgen zu erstellen. Lesen Sie sich die Dokumentationsseite der Funktion durch. Wie müssen Sie die Funktion aufrufen (und welche Argumente benötigen Sie dafür), um eine Zahlenfolge von \texttt{0} bis \texttt{100} in 5er-Schritten zu erzeugen?

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue3-2}{}{\label{exr:ue3-2} }Funktionen erstellen:
\EndKnitrBlock{exercise}

Erstellen Sie eine Funktion \texttt{fahrenheit\_to\_celsius}, die eine Temperaturangabe in Grad Fahrenheit (als numerischen Wert, also z. B. \texttt{80}) in Grad Celsius umrechnet und diesen Wert zurückgibt.

Die Formel zur Umrechnung von Fahrenheit in Celsius lautet \(°C = (°F − 32) × 5/9\).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue3-3}{}{\label{exr:ue3-3} }Funktionen erstellen für Fortgeschrittene:
\EndKnitrBlock{exercise}

\emph{Käpseles-Aufgabe} (optional)

Erweitern Sie die in Kapitel \ref{fargsdef} erstellte Funktion \texttt{descriptives} um folgende Features:

\begin{itemize}
\tightlist
\item
  Die Kennwerte sollen um die Anzahl der fehlenden Werte ergänzt werden (dieses Element soll den Namen \texttt{missing} tragen). Hierfür benötigen Sie die Funktion \texttt{is.na()}, die für jeden Wert eines Vektors prüft, ob es sich dabei um \texttt{NA} handelt oder nicht und entsprechend \texttt{TRUE} oder \texttt{FALSE} zurückgibt.
\item
  Die Funktion soll alle Kennwerte einheitlich auf eine gewünschte Anzahl an Nachkommastellen, standardmäßig auf 2 Nachkommastellen runden.
\end{itemize}

Hier nochmals der bisherige Funktionscode:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{FALSE}\NormalTok{) \{}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm), }
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm)}
\NormalTok{  )}
  
  \KeywordTok{return}\NormalTok{(descriptives_vector)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{kontrollstrukturen}{%
\chapter{Kontrollstrukturen}\label{kontrollstrukturen}}

Mittels \emph{Kontrollstrukturen} können wir definieren, ob und wie oft Code ausgeführt wird; unterschieden wird hierbei vorrangig zwischen \emph{Bedingungen} -- d.~h. Code, der nur ausgeführt wird, wenn eine bestimmte Bedingung erfüllt ist -- und \emph{Iterationen} (wiederholtes ausführen von Code, auch als \emph{Schleifen} bezeichnet).

Bedingungen und Iterationen sind Konzepte, die ebenso wie Funktionen in quasi allen Programmiersprachen zu finden sind. Ziel dieses Kapitels ist es, ein Grundverständnis beider Konzepte zu erlangen; relevant werden diese spätestens, wenn wir über APIs oder Webscraping Daten erheben werden.

\hypertarget{conditions}{%
\section{Bedingungen}\label{conditions}}

Bedingungen führen Code abhängig davon aus, ob eine definierte Bedingung \texttt{TRUE} oder \texttt{FALSE} ist.

\hypertarget{if-bedingungen}{%
\subsection{\texorpdfstring{\texttt{if}-Bedingungen}{if-Bedingungen}}\label{if-bedingungen}}

Bedingungen werden in R -- ebenso wie in vielen anderen Programmiersprachen -- über das Schlüsselwort \texttt{if} umgesetzt, dem eine in runde Klammern \texttt{()} gesetzte, logische Bedingung folgt. Wie auch bei Funktionen wird der bedingt auszuführende Code in geschweifte Klammern gesetzt \texttt{\{\}}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (bedingung) \{}
  \CommentTok{# Code der ausgeführt wird, wenn bedingung = TRUE ist}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die \texttt{bedingung} muss dabei in dem Objekttypen \texttt{logical} (also \texttt{TRUE} oder \texttt{FALSE}, siehe Kapitel \ref{logicals}) resultieren; in den meisten Fällen wird daher ein logischer Vergleich in den Klammern \texttt{()} durchgeführt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\NormalTok{aktion <-}\StringTok{ "verdoppeln"}

\ControlFlowTok{if}\NormalTok{ (aktion }\OperatorTok{==}\StringTok{ "verdoppeln"}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}

\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\hypertarget{if-else-bedingungen}{%
\subsection{\texorpdfstring{\texttt{if}-\texttt{else}-Bedingungen}{if-else-Bedingungen}}\label{if-else-bedingungen}}

Mit dem Schlüsselwort \texttt{else} können wir anschließend einen Codeblock definieren, der ausgeführt werden soll, wenn die Bedingung nicht zutrifft:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{punktzahl <-}\StringTok{ }\DecValTok{45}

\ControlFlowTok{if}\NormalTok{ (punktzahl }\OperatorTok{>}\StringTok{ }\DecValTok{50}\NormalTok{) \{}
\NormalTok{  status <-}\StringTok{ "bestanden"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  status <-}\StringTok{ "nicht bestanden"}
\NormalTok{\}}

\NormalTok{status}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "nicht bestanden"
\end{verbatim}

\hypertarget{bedingungen-verketten}{%
\subsection{Bedingungen verketten}\label{bedingungen-verketten}}

Durch die Kombination von \texttt{else} und \texttt{if} können wir auch beliebig viele Bedingungen hintereinander prüfen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{steak_temperatur <-}\StringTok{ }\DecValTok{56}

\ControlFlowTok{if}\NormalTok{ (steak_temperatur }\OperatorTok{<}\StringTok{ }\DecValTok{45}\NormalTok{) \{}
\NormalTok{  garstufe <-}\StringTok{ "raw"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (steak_temperatur }\OperatorTok{<}\StringTok{ }\DecValTok{53}\NormalTok{) \{}
\NormalTok{  garstufe <-}\StringTok{ "rare"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (steak_temperatur }\OperatorTok{<}\StringTok{ }\DecValTok{57}\NormalTok{) \{}
\NormalTok{  garstufe <-}\StringTok{ "medium rare"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (steak_temperatur }\OperatorTok{<}\StringTok{ }\DecValTok{63}\NormalTok{) \{}
\NormalTok{  garstufe <-}\StringTok{ "medium"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  garstufe <-}\StringTok{ "well done"}
\NormalTok{\}}

\NormalTok{garstufe}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "medium rare"
\end{verbatim}

\hypertarget{mehrere-bedingungen}{%
\subsection{Mehrere Bedingungen}\label{mehrere-bedingungen}}

Mittels \href{https://de.wikipedia.org/wiki/Boolescher_Operator}{Boolescher Operatoren} können wir mehrere Bedingungen miteinander verknüpfen, um etwa zu prüfen ob alle Bedingungen zutreffen (\texttt{UND}-Verknüpfung), mindestens eine Bedinung zutrifft (\texttt{ODER}-Verknüpfung), oder das Gegenteil einer Bedingung zutrifft (\texttt{NICHT}-Verknüpfung). Die gebräuchlichsten Operatoren sind:

\begin{longtable}[]{@{}ccc@{}}
\caption{\label{tab:boolescheoperatoren} Boolesche Operatoren in R}\tabularnewline
\toprule
\begin{minipage}[b]{0.08\columnwidth}\centering
Operator\strut
\end{minipage} & \begin{minipage}[b]{0.10\columnwidth}\centering
Verknüpfung\strut
\end{minipage} & \begin{minipage}[b]{0.73\columnwidth}\centering
Beispiele\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.08\columnwidth}\centering
Operator\strut
\end{minipage} & \begin{minipage}[b]{0.10\columnwidth}\centering
Verknüpfung\strut
\end{minipage} & \begin{minipage}[b]{0.73\columnwidth}\centering
Beispiele\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.08\columnwidth}\centering
\texttt{\&}\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\centering
und\strut
\end{minipage} & \begin{minipage}[t]{0.73\columnwidth}\centering
\texttt{1\ ==\ 1\ \&\ 2\ ==\ 2} ergibt \texttt{TRUE}\texttt{1\ ==\ 1\ \&\ 1\ ==\ 3} ergibt \texttt{FALSE}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.08\columnwidth}\centering
\texttt{\textbar{}}\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\centering
oder\strut
\end{minipage} & \begin{minipage}[t]{0.73\columnwidth}\centering
\texttt{1\ ==\ 1\ \textbar{}\ 2\ ==\ 2} ergibt \texttt{TRUE}\texttt{1\ ==\ 1\ \textbar{}\ 1\ ==\ 3} ergibt \texttt{TRUE}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.08\columnwidth}\centering
\texttt{!}\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\centering
nicht\strut
\end{minipage} & \begin{minipage}[t]{0.73\columnwidth}\centering
\texttt{!(1\ ==\ 1)} ergibt \texttt{FALSE} (\texttt{!} wird der Bedingung vorangestellt)\texttt{!(1\ ==\ 3)} ergibt \texttt{TRUE}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Als Beispiel verknüpfen wir die Bedingungen für ein Schaltjahr. Damit ein Jahr ein Schaltjahr ist, müssen folgende Bedingungen erfüllt sein:

\begin{itemize}
\tightlist
\item
  Die Jahreszahl ist durch \texttt{400} teilbar \texttt{ODER}
\item
  Die Jahreszahl ist durch \texttt{4} teilbar \texttt{UND} ist gleichzeitig \texttt{NICHT} durch \texttt{100} teilbar.
\end{itemize}

Ob eine Zahl durch eine andere Zahl teilbar ist, können wir mit dem Modulo-Operator \texttt{\%\%} prüfen, der den ganzzahligen Rest der Division ausgibt -- mit anderen Worten: wenn das Ergebnis der Modulo-Operation \texttt{0} ist, dann ist Zahl 1 durch Zahl 2 teilbar, ansonsten nicht.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{year <-}\StringTok{ }\DecValTok{2020}

\NormalTok{year }\OperatorTok{%%}\StringTok{ }\DecValTok{400} \OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{|}\StringTok{ }\NormalTok{(year }\OperatorTok{%%}\StringTok{ }\DecValTok{4} \OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{&}\StringTok{ }\OperatorTok{!}\NormalTok{(year }\OperatorTok{%%}\StringTok{ }\DecValTok{100} \OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{))}
\CommentTok{# Natürlich könnten wir hinten auch prüfen, ob year %% 100 != 0 ist und}
\CommentTok{# nur die UND-Verknüpfung nutzen, aber ich wollte alle drei Booleschen }
\CommentTok{# Operatoren in einer Prüfung unterbringen}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Oder als Funktion verpackt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_leap_year <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(year) \{}
\NormalTok{  year }\OperatorTok{%%}\StringTok{ }\DecValTok{400} \OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{|}\StringTok{ }\NormalTok{(year }\OperatorTok{%%}\StringTok{ }\DecValTok{4} \OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{&}\StringTok{ }\OperatorTok{!}\NormalTok{(year }\OperatorTok{%%}\StringTok{ }\DecValTok{100} \OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{is_leap_year}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1900}\NormalTok{, }\DecValTok{2000}\NormalTok{, }\DecValTok{2016}\NormalTok{, }\DecValTok{2018}\NormalTok{, }\DecValTok{2020}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE  TRUE FALSE  TRUE
\end{verbatim}

\hypertarget{mehrere-pruxfcfwerte}{%
\subsection{Mehrere Prüfwerte}\label{mehrere-pruxfcfwerte}}

Oft wollen wir prüfen, ob ein Wert zu einer Reihe an Werten gehört -- beispielsweise wenn wir Werte kategorisieren möchten. Wir können dies mit einer \texttt{ODER}-Verknüpfung erreichen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{food <-}\StringTok{ "Banane"}

\ControlFlowTok{if}\NormalTok{ (food }\OperatorTok{==}\StringTok{ "Apfel"} \OperatorTok{|}\StringTok{ }\NormalTok{food }\OperatorTok{==}\StringTok{ "Orange"} \OperatorTok{|}\StringTok{ }\NormalTok{food }\OperatorTok{==}\StringTok{ "Banane"}\NormalTok{) \{}
\NormalTok{  food_category <-}\StringTok{ "Obst"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Allerdings wird diese Verknüpfung schnell umständlich, wenn wir viele Prüfwerte haben, im Beispiel also nicht nur 3 Obstsorten, sondern 5, 10 oder 123. Hier hilft uns der Operator \texttt{\%in\%}, der testet, ob ein Wert in einem Vektor an Werten vorhanden ist:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Banane"} \OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Apfel"}\NormalTok{, }\StringTok{"Orange"}\NormalTok{, }\StringTok{"Banane"}\NormalTok{, }\StringTok{"Zitrone"}\NormalTok{, }\StringTok{"Mango"}\NormalTok{, }\StringTok{"Kumquat"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Das funktioniert auch mit mehreren Werten auf der linken Seite der Prüfung:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"Banane"}\NormalTok{, }\StringTok{"Mango"}\NormalTok{, }\StringTok{"Leberkäse"}\NormalTok{) }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Apfel"}\NormalTok{, }\StringTok{"Orange"}\NormalTok{, }\StringTok{"Banane"}\NormalTok{, }\StringTok{"Zitrone"}\NormalTok{, }\StringTok{"Mango"}\NormalTok{, }\StringTok{"Kumquat"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE FALSE
\end{verbatim}

Und natürlich können wir den Prüfvektor vorab zuweisen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{obstsorten <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Apfel"}\NormalTok{, }\StringTok{"Orange"}\NormalTok{, }\StringTok{"Banane"}\NormalTok{, }\StringTok{"Zitrone"}\NormalTok{, }\StringTok{"Mango"}\NormalTok{, }\StringTok{"Kumquat"}\NormalTok{)}
\NormalTok{food <-}\StringTok{ "Kumquat"}

\ControlFlowTok{if}\NormalTok{ (food }\OperatorTok{%in%}\StringTok{ }\NormalTok{obstsorten) \{}
\NormalTok{  food_category <-}\StringTok{ "Obst"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  food_category <-}\StringTok{ "Kein Obst"}
\NormalTok{\}}

\NormalTok{food_category}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Obst"
\end{verbatim}

\hypertarget{iterationen}{%
\section{Iterationen}\label{iterationen}}

Mittels Iterationen führen wir ein Code-Fragment wiederholt für verschiedene Input-Objekte aus. R bietet viele unterschiedliche Möglichkeiten für Iterationen -- für den Anfang genügen wir uns mit vektorisierten Funktionen, \texttt{for}-Loops und \texttt{while}-Loops:

\hypertarget{vektorisierte-funktionen}{%
\subsection{Vektorisierte Funktionen}\label{vektorisierte-funktionen}}

Tatsächlich haben wir unbewusst bereits mehrfach mit Iterationen gearbeitet, indem wir \emph{vektorisierte} Funktionen eingesetzt haben -- Funktionen, die automatisch auf jedes Element eines Vektors angewendet werden. Dazu zählen beispielsweise alle arithmetischen Operatoren und nahezu alle Funktionen in der Basis-Version von R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{42}\NormalTok{)}
\NormalTok{zahlen }\OperatorTok{-}\StringTok{ }\DecValTok{10}
\NormalTok{zahlen }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{log}\NormalTok{(zahlen) }\CommentTok{# Berechnet den natürlichen Logarithmus}
\KeywordTok{tolower}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Text 1"}\NormalTok{, }\StringTok{"TEXT 2"}\NormalTok{, }\StringTok{"TEXT DREI"}\NormalTok{)) }\CommentTok{# wandelt Text in Kleinbuchstaben um}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -5  0 32
## [1]  15  30 126
## [1] 1.609438 2.302585 3.737670
## [1] "text 1"    "text 2"    "text drei"
\end{verbatim}

Wir haben außerdem in Kapitel \ref{vectorarithmetics} gesehen, dass wir so auch mit zwei gleichlangen Vektoren effizient rechnen können:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 15 40
\end{verbatim}

Was passiert, wenn beide Vektoren nicht gleichlang sind? Hier tritt eine Eigenschaft von R zu Tage, die sich \emph{Recycling} nennt: Ist der längere Vektor durch den kürzeren Vektor teilbar, wiederholt R den kürzeren Vektor einfach entsprechend oft:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 12 10 40
\end{verbatim}

Ist das nicht der Fall, produziert R hingegen eine Fehlermeldung:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{) }\OperatorTok{*}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in c(2, 4) * c(2, 3, 5): Länge des längeren Objektes
##       ist kein Vielfaches der Länge des kürzeren Objektes
\end{verbatim}

\begin{verbatim}
## [1]  4 12 10
\end{verbatim}

\hypertarget{forloops}{%
\subsection{\texorpdfstring{\texttt{for}-Loops}{for-Loops}}\label{forloops}}

\texttt{for}-Loops führen (beliebig viele Zeilen) Code für jedes Element eines Vektors durch. Die Grundform eines \texttt{for}-Loops sieht wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (element }\ControlFlowTok{in}\NormalTok{ vektor) \{}
  \CommentTok{# Body: Code, der ausgeführt wird}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{element} ist hierbei ein Objekt, dem nach jeder Ausführung des Codes in den geschweiften Klammern \texttt{\{\}} das nächste Element aus dem angegebenen Vektor zugewiesen wird. Wir können dem Element einen beliebigen Objektnamen geben und es dann ähnlich wie in Funktionen als Platzhalter im Loop-Code verwenden. Für einfache Loops wird meistens der Objektname \texttt{i} verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ zahlen) \{}
\NormalTok{  neue_zahl <-}\StringTok{ }\NormalTok{i }\OperatorTok{*}\StringTok{ }\NormalTok{i }\OperatorTok{-}\StringTok{ }\DecValTok{1}
  \KeywordTok{print}\NormalTok{(neue_zahl) }\CommentTok{# print() schreibt ein Objekt in den Konsolenoutput}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
## [1] 3
## [1] 8
## [1] 15
## [1] 24
\end{verbatim}

Nutzen wir ein etwas anwendungsbezogeneres Beispiel. Nehmen wir an, wir möchten den Mittelwert aller (numerischen) Variablen in einem Datensatz ausgeben. Wir könnten die \texttt{mean()}-Funktion natürlich einfach händisch für jede Variable anfordern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Width)}
\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Petal.Length)}
\CommentTok{# usw.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.843333
## [1] 3.057333
## [1] 3.758
\end{verbatim}

Im Falle von \texttt{iris} bei nur vier numerischen Variablen wäre das noch problemlos möglich, bei längeren Datensätzen hätten wir aber schnell sehr viel zu tun -- und in allen Fällen produzieren wir sehr viel redundanten Code. Eleganter lösen wir das mit einem \texttt{for}-Loop und einem Vektor, der alle uns interessierenden Variablennamen enthält:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variablen <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Sepal.Length"}\NormalTok{, }\StringTok{"Sepal.Width"}\NormalTok{, }\StringTok{"Petal.Length"}\NormalTok{, }\StringTok{"Petal.Width"}\NormalTok{)}

\NormalTok{mittelwerte <-}\StringTok{ }\KeywordTok{c}\NormalTok{()}

\ControlFlowTok{for}\NormalTok{ (variable }\ControlFlowTok{in}\NormalTok{ variablen) \{}
\NormalTok{ mittelwerte[variable] <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(iris[[variable]])}
\NormalTok{\}}

\NormalTok{mittelwerte}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
##     5.843333     3.057333     3.758000     1.199333
\end{verbatim}

Was passiert hier?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Wir erstellen einen Vektor mit den uns interessierenden Variablen \texttt{variablen} sowie einen leeren Vektor \texttt{mittelwerte}.
\item
  Der \texttt{for}-Loop beginnt: \texttt{variable} bekommt das erste Element aus \texttt{variablen}, also \texttt{"Sepal.Length"} zugewiesen. Dann wird der Code in den geschweiften Klammern \texttt{\{\}} ausgeführt:

  \begin{itemize}
  \tightlist
  \item
    \texttt{iris{[}{[}variable{]}{]}} extrahiert aus dem \texttt{iris}-Datensatz die Spalte mit dem Namen, der in \texttt{variable} gespeichert ist -- aktuell also \texttt{"Sepal.Length"}. (Wir kennen bisher nur einfache eckige Klammern \texttt{{[}{]}} zur Extraktion; dabei wird der Objekttyp \texttt{data.frame} beibehalten und wir können auch mehrere Variablen extrahieren. Mit den doppelten eckigen Klammern \texttt{{[}{[}{]}{]}} wird hingegen nur eine einzige Variable extrahiert und in den Objekttyp \texttt{vector} umgewandelt. Diesen Objekttypen benötigen wir für die \texttt{mean()}-Funktion.)
  \item
    Wir berechnen davon den Mittelwert mittels \texttt{mean()}.
  \item
    Der Vektor \texttt{mittelwerte} erhält ein Element mit dem Namen, der in \texttt{variable} gespeichert ist -- aktuell also ebenfalls \texttt{"Sepal.Length"}. Diesem Element weisen wir den berechneten Mittelwert zu.
  \end{itemize}
\item
  Der Loop ist nun einmal durchlaufen und beginnt von vorne. Dabei wird \texttt{variable} nun das zweite Element von \texttt{variablen}, ``Sepal.Width'', zugewiesen. Dann wird der Code in den geschweiften Klammern erneut ausgeführt.
\item
  Diese Schritte werden so oft wiederholt, bis wir am Ende von \texttt{variablen} angekommen sind und jedes Element aus \texttt{variablen} einmal \texttt{variable} zugewiesen wurde.
\item
  Als Resultat erhalten wir einen benannten Vektor \texttt{mittelwerte}, der alle Mittelwerte enthält.
\end{enumerate}

Mittels \texttt{for}-Loops können wir also sehr schnell Teile unseres Codes automatisieren und als Grundprinzip finden sich \texttt{for}-Loops in nahezu allen Programmiersprachen. Wir werden jedoch in Kürze noch Funktionen kennenlernen, die uns Iterationen nochmals deutlich komfortabler gestalten.

\hypertarget{while-loops}{%
\subsection{\texorpdfstring{\texttt{while}-Loops}{while-Loops}}\label{while-loops}}

Bei \texttt{for}-Loops wissen wir vorab, wie oft der Loop ausgeführt wird -- nämlich für jedes Element, das der Vektor, über den wir loopen, enthält. Manchmal ist es uns aber nicht vorab bewusst, wie oft ein Loop ausgeführt werden soll. In diesem Fall können wir \texttt{while}-Loops verwenden, die so lange ausgeführt werden, wie eine Bedingung als \texttt{TRUE} erfüllt ist:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{ (bedingung) \{}
  \CommentTok{# Body: Code, der ausgeführt wird}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Entsprechend benötigen wir eine Bedingung, die bei jeder Iteration wieder überprüft wird. Das Prüfkriterium sollten wir also im Body des Loops auch anpassen, da der Loop sonst unendlich läuft.

Als Beispiel schreiben wir einen Loop, der in 5er-Schritten von \texttt{50} bis \texttt{100} zählt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{50}

\ControlFlowTok{while}\NormalTok{ (x }\OperatorTok{<=}\StringTok{ }\DecValTok{100}\NormalTok{) \{}
  \KeywordTok{print}\NormalTok{(x)}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{5}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 50
## [1] 55
## [1] 60
## [1] 65
## [1] 70
## [1] 75
## [1] 80
## [1] 85
## [1] 90
## [1] 95
## [1] 100
\end{verbatim}

Was passiert hier?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Wir weisen \texttt{x} den Ausgangswert \texttt{50} zu.
\item
  Der \texttt{while}-Loop beginnt. Wir prüfen zunächst ob \texttt{x} kleiner gleich \texttt{100}, was aktuell der Fall ist. Dann wird der Code ausgeführt:

  \begin{itemize}
  \tightlist
  \item
    Wir schreiben zunächst den aktuellen Wert von \texttt{x} in die Konsole.
  \item
    Dann addieren wir \texttt{5} zu \texttt{x}. \texttt{x} ist nun \texttt{55}.
  \end{itemize}
\item
  Der Loop ist nun einmal durchlaufen und beginnt von vorne. Erneut wird geprüft, ob \texttt{x} kleiner gleich \texttt{100} ist. Dies ist weiterhin der Fall, der Code wird also erneut ausgeführt.
\item
  Dies wird so lange wiederholt, bis die Bedingung nicht mehr erfüllt ist. Dies geschieht, nachdem \texttt{100} in die Konsole geschrieben wurde, da danach auf \texttt{x} nochmals \texttt{5} addiert werden und \texttt{x} am Ende des Loops folglich \texttt{105} ist. Die nächste Prüfung \texttt{105\ \textless{}=\ 100} resultiert in \texttt{FALSE}, der Loop wird abgebrochen.
\end{enumerate}

Einen häufigen Anwendungsfall für \texttt{while}-Loops lernen wir kennen, sobald wir mit APIs arbeiten. Wollen wir etwa Tweets zu einem bestimmten Hashtag herunterladen, wissen wir vorab nicht, um wie viele Tweets es sich handelt. Mit einem \texttt{while}-Loop könnten wir daher festlegen, dass wir den Code zum Tweets-aus-der-API-ziehen ausführen, bis diese keine weiteren zurückgibt.

Herzlichen Glückwunsch, Sie beherrschen nun die zentralen Grundlagen von R (und fast jeder anderen Programmiersprache) und könnten theoretisch alle weiteren Funktionen von Hand schreiben. In der Praxis wurde aber vermutlich so gut wie jedes Problem, das Ihnen im datenanalytischen Kontext begegnet, schon von jemand anderem gelöst. Wir schauen uns also als nächstes an, wie wir auf Funktionen von anderen in Form von Packages zugreifen können.

\hypertarget{uxfcbungsaufgaben-3}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-3}}

Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei und speichern diese als \texttt{ue4\_nachname.R} ab. Antworten auf Fragen können Sie direkt als Kommentare in das Skript einfügen.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue4-1}{}{\label{exr:ue4-1} }Bedingungen:
\EndKnitrBlock{exercise}

Wir haben in einer Studie das Nachrichtennutzungsverhalten erhoben und möchten dieses nun basierend auf zwei Variablen in einer neuen Variablen \texttt{news\_category} kategorisieren:

\begin{itemize}
\tightlist
\item
  Falls in der Variable \texttt{news\_channel} nicht \texttt{"Internet"} angeben wurde, soll die neue Variable \texttt{news\_category} den Wert \texttt{"Offline"} lauten.
\item
  Falls dort ``\texttt{Internet}'' angegeben wurde, steht eine weitere Unterteilung an:

  \begin{itemize}
  \tightlist
  \item
    Falls in \texttt{news\_website} die Werte \texttt{"Twitter"}, \texttt{"Facebook"} oder \texttt{"Instagram"} angegeben wurden, soll \texttt{news\_category} den Wert \texttt{"Online:\ SNS"} haben.
  \item
    Bei allen anderen Werten von \texttt{news\_website} soll \texttt{news\_category} den Wert \texttt{"Online:\ Sonstige"} bekommen
  \end{itemize}
\end{itemize}

Bilden Sie im folgenden Codebeispiel diesen Entscheidungsbaum mit Bedingungen nach:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{news_channel <-}\StringTok{ "Internet"}
\NormalTok{news_website <-}\StringTok{ "Facebook"}

\CommentTok{#       Ihr Code hier}
\CommentTok{#}
\CommentTok{#  _._     _,-'""`-._}
\CommentTok{# (,-.`._,'(       |\textbackslash{}`-/|}
\CommentTok{#     `-.-' \textbackslash{} )-`( , o o)}
\CommentTok{#           `-    \textbackslash{}`_`"'-}
\CommentTok{#}
\CommentTok{# (Diese Katze sieht in R kopiert besser aus als hier in der Webansicht)}

\NormalTok{news_category }\CommentTok{# Wenn alles geklappt hat, sollte "Online: SNS" herauskommen}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue4-2}{}{\label{exr:ue4-2} }Iterationen:
\EndKnitrBlock{exercise}

Vervollständigen Sie in der folgenden Funktion alle Platzhalter \texttt{\_\_\_}, sodass diese für alle numerischen Variablen eines Datensatzes Mittelwert und Standardabweichung ausgibt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numeric_summary <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data) \{}
  
  \CommentTok{# Alle Variablennamen in Vektor speichern}
\NormalTok{  variables <-}\StringTok{ }\KeywordTok{names}\NormalTok{(data)}
  
  \CommentTok{# Leere Liste für Ausgabe vorbereiten}
\NormalTok{  summary_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  
  \CommentTok{# Über alle Variablen iterieren}
  \KeywordTok{___}\NormalTok{ (___) \{ }\CommentTok{# Hier die ___ ersetzen}
\NormalTok{    variable_vector <-}\StringTok{ }\NormalTok{data[[___]] }\CommentTok{# Und hier ebenfalls}
    
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.numeric}\NormalTok{(variable_vector)) \{ }\CommentTok{# Prüfen ob die Variable numerisch ist}
      
      \CommentTok{# Mittelwert und Standardabweichung dieser Variablen der summary_list hinzufügen}
\NormalTok{      summary_list[[___]] <-}\StringTok{ }\KeywordTok{c}\NormalTok{( }\CommentTok{# Hier wieder die ___ ersetzen}
        \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(variable_vector),   }
        \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(variable_vector)}
\NormalTok{      )}
\NormalTok{    \}}
    
\NormalTok{  \}}
  
  \CommentTok{# Summary List ausgeben}
  \KeywordTok{return}\NormalTok{(summary_list)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Testen Sie die fertige Version mit den \texttt{iris}- und \texttt{mtcars}-Datensätzen.

\hypertarget{packages}{%
\chapter{Packages}\label{packages}}

Bereits mit der Basisversion von R kommen wir schon recht weit. Der Erfolg von R geht aber nicht zuletzt darauf zurück, dass sich die Basisversion sehr einfach durch \emph{Packages} erweitern lässt. Dabei handelt es sich um Sammlungen von Funktionen, deren Dokumentation und Zusatzinhalten (z. B. Beispieldaten), die R beispielsweise um neue Analyse- und Erhebungsverfahren erweitern oder bestehende Funktionalitäten vereinfachen.

Auf \href{https://cran.r-project.org/}{CRAN}, dem \emph{C}omprehensive \emph{R} \emph{A}rchive \emph{N}etwork -- Sie erinnern sich, von dort haben Sie auch R installiert --, stehen aktuell rund 15.500 Packages zur Verfügung, die so ziemlich jede Funktionalität abdecken, die man sich wünschen kann.

\hypertarget{packages-installieren}{%
\section{Packages installieren}\label{packages-installieren}}

Packages lassen von sich von CRAN sehr einfach direkt in R bzw. RStudio über die Funktion \texttt{install.packages("package\_name")} installieren. Mit folgendem Befehl installieren wir beispielsweise das Paket \texttt{tibble}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"tibble"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R lädt automatisch die benötigten Dateien (und Packages, sollte das gewünschte Package andere Packages voraussetzen) herunter und installiert diese, sodass Sie meist nach wenigen Sekunden mit dem Package arbeiten können. Einmal installierte Packages bleiben Ihnen erhalten, bis Sie den Computer wechseln oder zu einer neuen R-Version (siehe nächstes Kapitel) wechseln.

\hypertarget{usepackages}{%
\section{Packages nutzen}\label{usepackages}}

Packages werden über die Funktion \texttt{library(package\_name)} für die aktuelle R-Session geladen, sodass Sie auf die enthaltenen Funktionen zugreifen können. Es bietet sich daher an, die \texttt{library()}-Befehle immer ganz oben in ein R-Skript zu schreiben, da von ihnen dann die Funktionalität des restlichen Skripts abhängig ist.

Laden wir einmal das \texttt{tibble}-Package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tibble)}
\end{Highlighting}
\end{Shaded}

Was kann dieses Package nun? In der Regel haben wir davon natürlich schon eine Vorstellung, da wir das neue Package vermutlich über eine Google-Suche nach dessen Funktionalität gefunden haben (ganz allgemein funktioniert eine Suche nach \emph{``R + {[}Name des gesuchten Verfahrens{]}''} meist gut). Wie auch bei den Basis-Funktionen können wir auch bei Funktionen aus Packages über ein vorangestelltes \texttt{?} die Dokumentationsseite der jeweiligen Funktion anzeigen.

Viele Packages kommen zudem mit einer oder mehreren \emph{Vignetten}, längeren Dokumentationen, die die Funktionen eines Packages genauer erläutern, oft mit Anwendungsbeispielen. Wir können diese Vignetten über den Befehl \texttt{vignette()} öffnen, wobei wir dafür den Namen der Vignette kennen müssen -- viele Packages bieten daher eine Vignette an, die nach dem Package selbst benannt ist. Alternativ öffnet sich über \texttt{browseVignettes("package\_name")} in einem Webbrowser eine Übersicht über alle Vignetten, die zu einem bestimmten Package gehören.

Öffnen wir einmal die Vignette unseres neues Packages \texttt{tibble}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{vignette}\NormalTok{(}\StringTok{"tibble"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Wir erfahren also, dass das \texttt{tibble}-Package einen ``modern take on data frames'' einführt. Neben einigen technischen Details zeichnen sich ``Tibbles'' vor allem durch eine schickere Darstellung in der R-Konsole aus. Schauen wir uns das doch einmal an -- die Funktion, um einen Dataframe in ein Tibble umzuwandeln lautet \texttt{as\_tibble()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_tibble}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows
\end{verbatim}

Im Gegensatz zu Dataframes sehen wir auf den ersten Blick folgende Unterschiede:

\begin{itemize}
\tightlist
\item
  Wir erhalten zunächst eine Zeile mit den Dimensionen des Datensatzes: \texttt{A\ tibble:\ 150\ x\ 5}
\item
  Unter der Kopfzeile sind die Objekttypen der jeweiligen Spalten aufgelistet, hier also \texttt{dbl} (für \texttt{double}) und \texttt{fct} (für \texttt{factr}).
\item
  Standardmäßig werden nur die ersten 10 Zeilen des Datensatzes angezeigt, sodass uns bei langen Datensätzen nicht die Konsole vollläuft.
\item
  hier nicht sichtbar: negative Zahlen und fehlende Werte werden farbig hervorgehoben
\end{itemize}

Wir werden zukünftig viel mit Tibbles arbeiten, doch nun erst einmal zurück zur Package-Nutzung: Bisweilen lohnt es sich nicht, das gesamte Package zu laden, da Sie nur einmal eine einzige Funktion daraus benötigen. In diesem Fall lassen sich die Funktionen installierter Packages auch ohne \texttt{library()} nutzen, indem die Funktion über das Format \texttt{package\_name::funktionsname()} aufgerufen wird:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tibble}\OperatorTok{::}\KeywordTok{as_tibble}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows
\end{verbatim}

Dies ist vor allem dann sinnvoll, wenn Sie in einem Skript viele verschiedene Packages nutzen: Da es durchaus vorkommen kann, dass mehrere Packages denselben Funktionsnamen nutzen, kann das Laden vieler unterschiedlicher Packages dazu führen, dass die eigentlich gewünschte Funktion aus Package 1 durch eine gleichnamige Funktion aus Package 2 ``überschrieben'' wird -- eine häufige Fehlerquelle.

\hypertarget{workflow}{%
\chapter{Workflow}\label{workflow}}

Zum Abschluss der Einführung in die Grundlagen von R schauen wir uns noch einige Möglichkeiten an, effizient(er) mit R und RStudio arbeiten zu können.

\hypertarget{arbeitsverzeichnisse}{%
\section{Arbeitsverzeichnisse}\label{arbeitsverzeichnisse}}

Abgesehen von den Skripten für die Übungsaufgaben haben wir bisher noch nicht mit Dateien gearbeitet. In Zukunft sieht dies natürlich anders aus: wir laden Datensätze auf unserer Festplatte, erstellen Skripte und speichern unsere Ergebnisse, z. B. in Form von Tabellen oder Abbildungen.

Sobald wir daher mit Dateien arbeiten, wird das Konzept des Arbeitsverzeichnisses relevant, da R basierend auf diesem nach Dateien sucht. Unser aktuelles Arbeitsverzeichnis können wir mit dem Befehl \texttt{getwd()} (für \emph{w}orking \emph{d}irectory) anzeigen.

Nehmen wir einmal an, unser Arbeitsverzeichnis lautet \texttt{C:/Projekte/R}. R wird nun Pfadangaben zu Dateien \emph{relativ} zu diesem Verzeichnis betrachten. Eine Datensatz-Datei \texttt{beispiel.csv}, die in diesem Verzeichnis liegt (deren gesamter Dateipfad also \texttt{C:/Projekte/R/beispiel.csv} ist), könnten wir mit der Funktion \texttt{read.csv()}, die zum Einlesen von CSV-Dateien verwendet wird, daher über \texttt{read.csv("beispiel.csv")} laden. Läge die Datei in einem Unterordner \texttt{data} (wäre der vollständige Dateipfad also \texttt{C:/Projekte/R/data/beispiel.csv}), müssten wir entsprechend \texttt{read.csv("data/beispiel.csv")} angeben. Gleiches gilt auch für Dateien, die wir mit R erstellen -- geben wir keinen weiteren Pfad an, so landen diese im Hauptordner des aktuellen Arbeitsverzeichnisses.

Umgekehrt bedeutet dies auch, dass es umständlich wird, Dateien zu laden, die außerhalb unseres Arbeitsverzeichnisses (also im Beispiel in einem anderen Ordner auf \texttt{C:}) liegen. Zwar kann immer auch der gesamte Dateipfad angegeben werden (z. B. \texttt{read.csv("C:/Projekte/R/data/beispiel.csv")}), das hat aber die Nachteile, dass Sie immer sehr viel tippen müssen und vor allem, dass Ihre Skripte nur noch auf Ihrem eigenen Rechner laufen, da Sie auf anderen Rechnern mit hoher Wahrscheinlichkeit auch eine andere Ordnerstruktur haben.

Es ist daher wichtig, sich a) eine sinnvolle Ordnerstruktur zu überlegen und b) sicherzustellen, dass R auch das korrekte Arbeitsverzeichnis nutzt. Das Arbeitsverzeichnis kann mit der Funktion \texttt{setwd()} festgelegt bzw. geändert werden -- allerdings bietet R-Studio noch eine Funktionalität, die das nochmals deutlich erleichert:

\hypertarget{rprojects}{%
\section{Projekte und Ordnerstrukturen}\label{rprojects}}

RStudio bietet mittels Projekten eine einfache Möglichkeit, alle relevanten Projektdateien zusammenzuhalten und das Arbeitsverzeichnis automatisch zu setzen. Projektdateien (Dateieindung \texttt{.rproj}) sind prinzipiell nichts weiter als ``Markierungen'' für RStudio, dass es sich bei einen Ordner auf der Festplatte (und den darin enthaltenen Dateien) um ein Analyseprojekt mit R handelt.

Erstellen wir also unser erstes R-Projekt für diesen Kurs: Klicken Sie in RStudio auf \emph{File - New Project} und wählen Sie im sich nun öffnenden Fenster \emph{New Directory} und anschließend \emph{New Project} aus. Im folgenden Fenster können Sie Ihrem Projekt einen sinnvollen Namen (z. B. ``R-Kurs'') geben und das Verzeichnis auswählen, in dem Ihr Projekt erstellt werden soll (RStudio erzeugt darin einen Unterordner mit dem Namen des Projekts):

\includegraphics{img/6/proj1.png}
\includegraphics{img/6/proj2.png}
\includegraphics{img/6/proj3.png}

Schließen Sie nun RStudio und navigieren zu dem Projektordner auf Ihrer Festplatte. Durch einen Doppelklick auf die \texttt{.rproj}-Datei öffnet sich RStudio mit diesem Projekt; das Arbeitsverzeichnis wird automatisch auf den Hauptordner des Projektes gesetzt, der \emph{Files}-Browser im rechten unteren Bildschirmbereich zeigt ebenfalls dieses an.

Am rechten oberen Bildschirmrand wird Ihnen außerdem das aktuelle Projekt angezeigt -- bearbeiten Sie mehrere Projekte gleichzeitig, können Sie hier auch direkt von einem Projekt in ein anderes wechseln (oder sogar mehrere gleichzeitig in unterschiedlichen RStudio-Sessions öffnen).

\begin{figure}
\centering
\includegraphics{img/6/projects.png}
\caption{Auswahl von Projekten in RStudio}
\end{figure}

Schließlich ist nun auch ein guter Zeitpunkt, sich eine Ordnerstruktur zu überlegen. Ich persönlich lege (nummerierte) Skriptdateien meist direkt im Hauptordner des Projektes ab, speichere alle relevanten Datensätze in einem Unterordner \texttt{data}, und alle Ergbnisse in entsprechend benannten Unterordnern (z. B. \texttt{tables} und \texttt{figures}). Finden Sie hier vor allem eine Struktur, in der Sie sich -- und im besten Falle auch andere, wenn Sie Daten aus einem Projekt anderen zur Verfügung stellen -- intuitiv zurechtfinden.

\begin{figure}
\centering
\includegraphics{img/6/wd.png}
\caption{Ein -- besonders für meine Verhältnisse -- gut aufgeräumter Projektordner}
\end{figure}

\hypertarget{r-markdown}{%
\section{R Markdown}\label{r-markdown}}

\emph{R Markdown} ist ein Dateiformat (Endung: \texttt{.Rmd}) von RStudio, das es erlaubt, Code, Ergebnisse und freien Text in nur einem Dokument zu kombinieren. Es ist dementsprechend gut geeignet, um Analyseschritte und die dahinterstehenden Entscheidungen und Gedanken festzuhalten. Zudem können solche Dokumente schnell in andere Dokumenttypen -- z. B. HTML-Websiten, PDF-Dateien oder Word-Dokumente -- umgewandelt werden.

\begin{figure}
\centering
\includegraphics{img/6/rmd.png}
\caption{Ein R Markdown-Dokument mit Text, Code und Ergebnissen -- in diesem Fall -- Grafiken}
\end{figure}

\begin{figure}
\centering
\includegraphics{img/6/rmd-knitted.png}
\caption{\ldots und dasselbe Dokument als HTML-Seite konvertiert}
\end{figure}

Wir erstellen R-Markdown-Dokumente über \emph{File - New File - R Markdown}. Im folgenden Fenster können wir einen Dokumenttitel, Ausgabeformat usw. einstellen -- all dies lässt sich aber auch später noch bearbeiten, sodass Sie fürs erste die Standardeinstellungen übernehmen können. Die erzeugte Datei ist bereits mit etwas Beispieltext gefüllt und besteht aus drei Komponenten:

\hypertarget{yaml-header}{%
\subsection{YAML-Header}\label{yaml-header}}

Ganz oben steht ein (optionaler) Block in der Auszeichnungssprache \emph{YAML} (für \emph{Y}et \emph{A}nother \emph{M}arkdown \emph{L}anguage), abgetrennt durch \texttt{-\/-\/-}, der die Outputoptionen festlegt.

\begin{verbatim}
---
title: "Auswertung"
author: "Julian Unkel"
date: "4/29/2020"
output: html_document
---
\end{verbatim}

Je nach Ausgabeformat können hier noch weitere Optionen angegeben werden, beispielsweise ob automatisch ein Inhaltsverzeichnis erzeugt werden soll. Auch hier reichen die Standardeinstellungen fürs erste jedoch vollkommen aus.

\hypertarget{freitext-in-markdown}{%
\subsection{Freitext in Markdown}\label{freitext-in-markdown}}

Freier Text kann jeder Stelle in das Dokument eingefügt werden. Dabei nutzt das Format die Formatierungssyntax \emph{Markdown} (daher auch der Dateiformatname), mit der sich Text schnell mittels bestimmter Symbole formatieren lässt. Die Grundidee dahinter ist, dass man sich beim Schreiben auf das Schreiben konzentriert und alle wesentlichen Formatierungen im Nachhinein automatisiert auf Basis von Vorlagen erfolgen. Einige Formatierungsoptionen sind:

\begin{longtable}[]{@{}ll@{}}
\caption{\label{tab:rmarkdown} Einige Formatierungsoptionen in R Markdown}\tabularnewline
\toprule
\begin{minipage}[b]{0.34\columnwidth}\raggedright
Syntax\strut
\end{minipage} & \begin{minipage}[b]{0.60\columnwidth}\raggedright
Erzeugt\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.34\columnwidth}\raggedright
Syntax\strut
\end{minipage} & \begin{minipage}[b]{0.60\columnwidth}\raggedright
Erzeugt\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.34\columnwidth}\raggedright
Klartext\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
Klartext\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.34\columnwidth}\raggedright
\texttt{\_kursiv\_}\texttt{*kursiv*}\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
\emph{kursiv}\emph{kursiv}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.34\columnwidth}\raggedright
\texttt{\_\_fett\_\_}\texttt{**fett**}\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
\textbf{fett}\textbf{fett}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.34\columnwidth}\raggedright
\texttt{\#\ Überschrift}\texttt{\#\#\ Überschrift}\texttt{\#\#\#\ Überschrift}\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
Überschrift erster EbeneÜberschrift zweiter EbeneÜberschrift dritter Ebene\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.34\columnwidth}\raggedright
\texttt{-\ Listenpunkt\ 1}\texttt{-\ Listenpunkt\ 2}\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
- Listenpunkt 1- Listenpunkt 2\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.34\columnwidth}\raggedright
\texttt{1.\ nummerierte\ Liste}\texttt{2.\ Listenpunkt\ 2}\strut
\end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright
1. nummerierte Liste2. Listenpunkt 2\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Ein gelungener Spickzettel für R Markdown findet sich zudem \href{https://rstudio.com/wp-content/uploads/2015/06/rmarkdown-german.pdf}{hier}.

\hypertarget{code-chunks}{%
\subsection{Code Chunks}\label{code-chunks}}

R-Code kann in speziellen Blöcken hinzugefügt werden, die durch \texttt{\textasciigrave{}\textasciigrave{}\textasciigrave{}\{r\}} (und einem optionalen Namen hinter \texttt{r}) eingeleitet werden und abschließend \texttt{\textasciigrave{}\textasciigrave{}\textasciigrave{}} begrenzt werden. Alles innerhalb dieser Blöcke (``Chunks'') wird als R-Code interpretiert. Einfacher können R-Code-Chunks mit der Tastenkombination \texttt{Strg/Cmd\ +\ Alt\ +\ I} eingefügt werden.

Einzelne Codezeilen können wie gehabt mit \texttt{Strg/Cmd\ +\ Enter/Return} ausgeführt werden; mittels \texttt{Strg/Cmd\ +\ Shift\ +\ Enter/Return} oder durch Klick auf den grünen ``Play''-Knopf am rechten oberen Ende des Chunks wird der gesamte Code des Chunks auf einmal ausgeführt. Die Besonderheit dabei ist, dass das Ergebnis direkt unter dem Chunk -- und nicht in der Konsole -- angezeigt wird, sodass Sie Code damit auch sehr schön gliedern können. Die Codebeispiele in der erzeugten R-Markdown-Datei verdeutlichen dies -- einzelne Werte, Tabellen und auch Grafiken können so direkt in dem Dokument angezeigt werden.

\hypertarget{ausgabedateien-erzeugen}{%
\subsection{Ausgabedateien erzeugen}\label{ausgabedateien-erzeugen}}

Mit einem Klick auf den ``Knit''-Knopf (mit Stricksymbol) am oberen Rand wird die im Header definierte Ausgabedatei erzeugt -- standardmäßig also eine HTML-Datei, die im Arbeitsverzeichnis abgelegt wird und mit jedem Browser geöffnet werden kann. Auch dies können Sie einmal mit dem Beispielcode ausprobieren.

Diese Einführung kann nicht alle Ausgabeformate in Detail ansprechen -- hier gibt es aber inzwischen vielfältige Möglichkeiten, die quasi den gesamten wissenschaftlichen Prozess abdecken, aber natürlich auch etwas Einarbeitung erfordern: mittels spezieller Packages lassen sich so unter anderem Präsentationen, PDF-Berichte (inklusive Literaturverwaltung und automatischer Formatierung von Ergebnistabellen nach gängigen wissenschaftlichen Standards) oder ganze Webseiten erstellen (auch dieser Kurs bzw. diese Website ist komplett in R Markdown erstellt).

Übungsaufgaben können Sie zukünftig sowohl als R-Skript (\texttt{.R}) als auch als R Markdown (\texttt{.Rmd}) abgeben.

\begin{figure}
\centering
\includegraphics{img/horst/rmarkdown_wizards.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

\hypertarget{r-aktuell-halten}{%
\section{R aktuell halten}\label{r-aktuell-halten}}

Wie bei jeder anderen Software auch sollte die Arbeitsumgebung in R durch regelmäßige Updates aktuell gehalten werden, um neue Features, Fehlerkorrekturen, Performance-Verbesserungen und Beseitigungen von Sicherheitslücken zu erhalten. Da wir mit unterschiedlichen Komponenten -- R, RStudio und jeder Menge Packages -- arbeiten, müssen all diese Komponenten auch getrennt geupdated werden.

\hypertarget{packages-aktualisieren}{%
\subsection{Packages aktualisieren}\label{packages-aktualisieren}}

Am häufigsten sollten Sie Ihre installierten Packages aktualisieren. Dies geht in RStudio sehr komfortabel über \emph{Tools - Check for Package Updates}, wodurch alle Packages angezeigt werden, für die Updates bereitstehen. Nach einer Auswahl der gewünschten Packages können Updates gesammelt über den Button \emph{Install Updates} heruntergeladen und installiert werden.

Um nur ein einzelnes Packages zu aktualisieren, kann dieses auch einfach über die Funktion \texttt{install.packages("package\_name")} mit der aktuellsten Version neu installiert werden.

\hypertarget{rstudio-aktualisieren}{%
\subsection{RStudio aktualisieren}\label{rstudio-aktualisieren}}

Auch RStudio kann direkt aus dem Programm heraus aktualisiert werden. Hier empfiehlt es sich, regelmäßig unter \emph{Help - Check for Updates} zu überprüfen, ob eine Aktualisierung bereitsteht.

\hypertarget{r-aktualisieren}{%
\subsection{R aktualisieren}\label{r-aktualisieren}}

Etwas unkomfortabler ist es, R selbst zu aktualisieren. Dass eine neue Version bereitsteht, erfährt man häufig dadurch, dass Packages beim Laden darauf aufmerksam machen, dass Sie mit einer aktuelleren Version von R als der aktuell installierten erstellt wurden. Das liest sich in der Konsole dann so:

\begin{verbatim}
Warning message:
package ‘package_name’ was built under R version x.x.x
\end{verbatim}

Das Updaten funktioniert dabei ebenso wie eine Neuinstallation, wie sie in Kapitel \ref{rinstallieren} beschrieben wurde -- RStudio sollte die neue R-Version dann automatisch erkennen (die aktuell installierte R-Version wird stets beim Starten von R/RStudio in der Konsole angezeigt). Dabei ist zu beachten, dass installierte Packages nicht von einer R-Version zur nächsten kopiert werden; es ist also entweder manuelles Kopieren oder eine Neuinstallation der Packages nötig.

Unter Windows kann zudem das Paket \texttt{installr} genutzt werden, dessen Funktion \texttt{updateR()} prüft, ob eine neue R-Version bereitsteht, diese herunterlädt und installiert sowie die Möglichkeit bietet, automatisch Packages der alten Installation für die neue Installation zu kopieren (was nicht immer auch funktioniert). Allerdings wird empfohlen, diese Funktion nicht in RStudio, sondern direkt in R zu nutzen.

Da vorige Woche eine neue Hauptversion von R erschienen ist (\texttt{R\ 4.0.0}) und wir aktuell noch kaum Packages installiert haben, die wir durch ein Update verlieren könnten, ist nun ein guter Zeitpunkt, um diese Version zu installieren. Falls Sie einen Mac nutzen, führen Sie also eine Neuinstallation von R wie unter Kapitel \ref{rinstallieren} beschrieben durch.

Auch unter Windows können Sie diesen Weg wählen -- oder Sie probieren das \texttt{installr}-Package aus. Hierzu installieren Sie das Package zunächst über \texttt{install.packages("installr")}. Schließen Sie dann RStudio und öffnen R (Sie finden R in der Regel im Startmenü unter R; das gibt Ihnen auch die Gelegenheit, wertzuschätzen, wie viel komfortabler RStudio ist). In die Konsole können Sie nun \texttt{installr::updateR()} ein und folgen den Anweisungen des Installationsprogramms.

In beiden Fällen sollte beim nächsten Start von RStudio in der ersten Konsolenzeile die neue R-Version angezeigt werden:

\begin{verbatim}
R version 4.0.0 (2020-04-24) -- "Arbor Day"
\end{verbatim}

\hypertarget{part-datenhandling-in-r}{%
\part{Datenhandling in R}\label{part-datenhandling-in-r}}

\hypertarget{datahandling-intro}{%
\chapter{Einführung in das Datenhandling}\label{datahandling-intro}}

Das \href{https://de.wikipedia.org/wiki/Paretoprinzip}{Paretoprinzip} -- 80\% der Ergebnisse werden mit 20\% des Aufwands, 20\% der Ergebnisse mit 80\% des Aufwands erreicht -- behält auch im datenanalytischen Kontext seine Gültigkeit: einen Großteil der Arbeitszeit wird darauf verwendet, Daten zu finden, zu importieren, zu säubern, zu transformieren, zu modifizieren und zu explorieren; die tatsächliche Analyse der Daten hingegen ist dann verhältnismäßig schnell erledigt. Wir fassen diese Schritte unter dem Begriff des \emph{Datenhandlings} zusammen.

\hypertarget{daten--und-dateiformate-tabellarischer-daten}{%
\section{Daten- und Dateiformate tabellarischer Daten}\label{daten--und-dateiformate-tabellarischer-daten}}

Wenn wir von Datensätzen sprechen, denken wir zumeist direkt an tabellarische Daten. In den kommenden Kapiteln werden wir auch zunächst lediglich mit tabellarischen Daten arbeiten. Daten können und werden aber auch in anderen Datenformaten repräsentiert, zum Beispiel als verschachtelte und hierarchisch strukturierte Daten (dieses Datenformat wird uns u.a. bei der Arbeit mit APIs begegnen) oder als unstrukturierte Textdokumente -- dazu an gegegeber Stelle mehr.

\hypertarget{tidy-data}{%
\subsection{Tidy data}\label{tidy-data}}

Dieselben Daten können in Tabellen unterschiedlich repräsentiert werden. Schauen wir uns dazu einen Datensatz an -- was könnten hier Probleme sein?

\begin{verbatim}
## # A tibble: 8 x 3
##   name             variable value
##   <chr>            <chr>    <dbl>
## 1 Anakin Skywalker height     188
## 2 Anakin Skywalker mass        84
## 3 Leia Organa      height     150
## 4 Leia Organa      mass        49
## 5 Luke Skywalker   height     172
## 6 Luke Skywalker   mass        77
## 7 Obi-Wan Kenobi   height     182
## 8 Obi-Wan Kenobi   mass        77
\end{verbatim}

Diese Datenanordnung ist in dreierlei Hinsicht nicht optimal, wobei alle Probleme miteinander verbunden sind:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zwei Variablen sind in einer Spalte hinterlegt: \texttt{value} enthält sowohl Werte, die sich auf die Körpergröße als auch auf das Gewicht beziehen.
\item
  Entsprechend ist die Spalte \texttt{value} abhängig von der Spalte \texttt{variable} -- allein anhand der Werte \texttt{188}, \texttt{84}, \texttt{150} etc. wissen wir nicht, ob diese sich auf die Größe \texttt{height} oder das Gewicht \texttt{mass} beziehen.
\item
  Daraus folgt, dass wir Probleme mit vektorisierten Funktionen -- wir erinnern uns, in R sind Spalten in Datensätzen Vektoren -- bekommen: wir können beispielsweise nicht einfach die \texttt{mean()}-Funktion auf die Spalte \texttt{value} anwenden, um das Durchschnittsgewicht der Star-Wars-Charaktere zu berechnen, da dort auch die Werte für die Körpergröße enthalten wären.
\end{enumerate}

Schauen wir uns eine zweite Version derselben Daten an:

\begin{verbatim}
## # A tibble: 4 x 2
##   name             height_and_mass
##   <chr>            <chr>          
## 1 Anakin Skywalker 188;84         
## 2 Leia Organa      150;49         
## 3 Luke Skywalker   172;77         
## 4 Obi-Wan Kenobi   182;77
\end{verbatim}

Auch hier ergeben sich zwei miteinander verbundene Probleme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In einer Zelle stehen zwei Werte, die je eine unterschiedliche Variable abbilden.
\item
  Sowohl bei Körpergröße als auch Gewicht handelt es sich um numerische Werte, sie werden aber hier als \texttt{character} gespeichert, wodurch wir keine Berechnungen durchführen können.
\end{enumerate}

Dieselben Daten können wir jedoch auch besser tabellarisch abbilden:

\begin{verbatim}
## # A tibble: 4 x 3
##   name             height  mass
##   <chr>             <int> <dbl>
## 1 Anakin Skywalker    188    84
## 2 Leia Organa         150    49
## 3 Luke Skywalker      172    77
## 4 Obi-Wan Kenobi      182    77
\end{verbatim}

Daten, die so aufbereitet, werden als \emph{tidy data} bezeichnet. Sie befolgen drei Regeln:

\begin{itemize}
\tightlist
\item
  Jede Variable steht in einer eigenen Spalte
\item
  Jede Beobachtung/jeder Fall steht in einer eigenen Zeile
\item
  Jeder Wert steht in einer Zelle
\end{itemize}

\begin{figure}
\centering
\includegraphics{img/7/tidy.png}
\caption{Tidy data (Quelle: \href{https://r4ds.had.co.nz/tidy-data.html}{R for Data Science})}
\end{figure}

Im Umkehrschluss bedeutet dies, dass Daten die nicht diesen Regeln folgen, als \emph{messy data} vorliegen und entsprechend aufbereitet werden sollten. Tidy data hat zwei entscheidende Vorteile:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Konsistent aufbereitete Daten sind leichter zu lesen, zu verarbeiten, zu laden und zu speichern.
\item
  Viele Verfahren (bzw. die zugehörigen Funktionen) in R setzen diese Art der Daten voraus.
\end{enumerate}

Wenn Sie bisher vor allem mit Daten aus Befragungssoftware o.ä. gearbeitet haben, dann werden Ihnen diese Grundprinzipien bereits vertraut sein, da der Datenexport aus Befragungssoftware in der Regel diesen Prinzipien folgt. Tatsächlich liegen in der ``Realität'' Daten aber häufig nicht in dieser Form vor, beispielsweise weil die Eingabe oder Speicherung der Daten anderen Prinzipien als einer möglichst einfachen Analyse folgt (z. B. möglichst einfache Dateneingabe; Abruf von bestimmten Werten).

\hypertarget{dateiformate}{%
\subsection{Dateiformate}\label{dateiformate}}

Sie kennen vermutlich bereits eine Vielzahl an Dateiformaten, in denen tabellarische Daten gespeichert werden können. Einige Beispiel sind Excel-Dateien mit den Endungen \texttt{.xls} bzw. \texttt{.xlsx} oder SPSS-Dateien mit der Endung \texttt{.sav}. Hierbei handelt es sich um sogenannte \emph{proprietäre} Dateiformate, sich im Eigentum von Unternehmen befindlichen und oft softwarespezifischen Dateiformaten. Ein Vorteil dieser Formate ist es, dass oft relevante Zusatzinformationen für die jeweilige Software mitgespeichert wird, etwa Formatierungen in Excel oder Wertebeschriftungen in SPSS. Zugleich entsteht hierbei der große Nachteil, dass der Austausch der Daten zwischen verschiedenen Programmen oft recht kompliziert, durch Zusatzpakete oder Zwischenschritte möglich ist.

Ein \emph{offenes} und sehr simples Dateiformat ist \texttt{.csv} (für \emph{c}omma-\emph{s}eparated \emph{v}alues), das tabellarische Daten als Klartext abspeichert, von so gut wie jedem Programm auf jedem Computer der Welt gelesen werden kann und daher das Standardformat für tabellarische Daten ist. Dabei werden Kommas zu Trennung von Spalten und Zeilenumbrüche zur Trennung von Zeilen genutzt, wobei in der ersten Zeile optional Spaltenüberschriften stehen können. Die Daten aus obigen Beispiel sähen als \texttt{.csv} also so aus:

\begin{verbatim}
name,height,mass
Anakin Skywalker,188,84
Leia Organa,150,49
Luke Skywalker,172,77
Obi-Wan Kenobi,182,77
\end{verbatim}

Soll das Trennzeichen in den einzelnen Text-Werten vorkommen (beispielsweise als Komma in einem Satz), werden Textbegrenzungszeichen, häufig doppelte Anführungszeichen \texttt{"} verwendet:

\begin{verbatim}
name,height,mass
"Skywalker, Anakin",188,84
"Organa, Leia",150,49
"Skywalker, Luke",172,77
"Kenobi, Obi-Wan",182,77
\end{verbatim}

In verallgemeinerter Form kann letztlich jedes Zeichen als Trennzeichen genutzt werden; im deutschsprachigen Raum wird in \texttt{.csv}-Dateien häufig ein Semikolon \texttt{;} statt einem Komma genutzt \texttt{,} (z. B. wenn Sie Daten aus SPSS oder Excel als \texttt{.csv} exportieren):

\begin{verbatim}
name;height;mass
Anakin Skywalker;188;84
Leia Organa;150;49
Luke Skywalker;172;77
Obi-Wan Kenobi;182;77
\end{verbatim}

Zwar kann R mittels unterschiedlicher Packages inzwischen auch relativ komfortabel Excel- und SPSS-Dateien einlesen; aus oben genannten Gründen werden wir zum Laden und Speichern jedoch vorrangig \texttt{.csv}-Dateien nutzen.

\hypertarget{willkommen-im-tidyverse}{%
\section{Willkommen im Tidyverse}\label{willkommen-im-tidyverse}}

Die Idee, Datenhandling komplett codebasiert durchzuführen, erscheint zunächst vielleicht wenig komfortabel -- vor allem wenn wir daran denken, dass das Auswählen und Verarbeiten von Dataframes bisher wenig intuitiv ablief (oder wissen Sie auf Anhieb noch, was der Unterschied zwischen \texttt{iris{[},\ "Sepal.Width"{]}}, \texttt{iris\$Sepal.Width} und \texttt{iris{[}{[}"Sepal.Width"{]}{]}} ist?).\footnote{Die erste Variante resultiert in einem Dataframe, der lediglich \texttt{Sepal.Width} enthält, Varianten zwei und drei extrahieren diese Spalte als Vektor.}

Seit einigen Jahren hat sich jedoch das \href{https://www.tidyverse.org/}{Tidyverse} als Standard des Datenhandlings in R durchgesetzt, was die mit dem Datenhandling verbundenen Schritte deutlich vereinfacht. Dabei handelt es sich um ein sogenanntes Meta-Package, also eine Sammlung von verschiedenen Packages, die allesamt den gleichen Designprinzipien folgen, um Datenhandling zu vereinfachen und den zugehörigen Code möglichst lesbar (für Menschen) zu machen. So haben beispielsweise Funktionen im Tidyverse in der Regel Verben als Namen, die genau das beschreiben, was die Funktion macht.

\begin{quote}
The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.
\end{quote}

Das Tidyverse umfasst hierzu unter anderem Pakete für:

\begin{itemize}
\tightlist
\item
  Datenstrukturen (\texttt{tibble})
\item
  Einlesen von Daten (z. B. \texttt{readr} für CSV, \texttt{haven} für SPSS, Stata und SAS, \texttt{readxl} für Excel)
\item
  Datentransformation und -modifikation (\texttt{tidyr}, \texttt{dplyr})
\item
  Spezielle Objekttypen (z. B. \texttt{stringr} für die Arbeit mit Textobjekten, \texttt{forcats} für Faktoren, \texttt{lubridate} für Zeitdaten)
\item
  Programmieren mit R (\texttt{purrr})
\item
  Grafik-/Diagrammerstellung (\texttt{ggplot2})
\end{itemize}

Alle Pakete lassen sich gesammelt installieren und laden\footnote{\texttt{library(tidyverse)} lädt dabei genauer gesagt die Kernpakete des Tidyverse, die die alltäglich am häufigsten genutzten Funktionen bereitstellen. Tidyverse-Packages für eher spezifische Anwendungsgebiete -- z. B. \texttt{lubridate} für Zeitdaten oder \texttt{haven} für SPSS-Datensätze -- müssen einzeln über den \texttt{library()}-Befehl geladen werden.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{) }\CommentTok{# Dies muss natürlich nur einmal ausgeführt werden}
\KeywordTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

Die Standard-Datenstruktur des Tidyverse ist das Tibble, das wir bereits aus Kapitel \ref{usepackages} kennen. Zur Erinnerung, dabei handelt es sich im Wesentlichen um Dataframes mit einigen technischen und kosmetischen Verbesserungen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_tibble}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows
\end{verbatim}

Im folgenden Kapitel werden wir uns nun ansehen, wie wir mittels Tidyverse-Funktionen Datensätze laden und modifizieren können.

\hypertarget{workingwithdata}{%
\chapter{Daten laden, modifizieren und speichern}\label{workingwithdata}}

In diesem Kapitel sehen wir uns grundlegende Arbeitsschritte und Funktionen des Datenhandlings: das Einlesen von Daten, einfaches Modifizieren von Datensätzen und das Abspeichern der Ergebnisse. Für all diese Schritte arbeiten wir mit Funktionen aus dem Tidyverse -- falls noch nicht geschehen, sollten Sie das Package jetzt also installieren.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Und dann laden wir das Package zu Beginn unseres Auswertungsskripts:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

\hypertarget{daten-laden}{%
\section{Daten laden}\label{daten-laden}}

Wir sprechen von \emph{lokalen} Daten, wenn wir diese in Form einer Datei auf unserer Festplatte gespeichert haben. \emph{Externe} Daten liegen beispielsweise auf Webservern oder sind in Packages enthalten. Zunächst laden wir nur lokale Daten.

\hypertarget{csv-dateien-einlesen}{%
\subsection{CSV-Dateien einlesen}\label{csv-dateien-einlesen}}

Wenn Sie den Schritten in Kapitel \ref{rprojects} gefolgt sind, haben Sie ein R-Projektverzeichnis auf des Festplatte. Auf Moodle finden Sie den Datensatz \texttt{facebook\_europawahl.csv}, der Informatationen zu Facebook-Posts der deutschen Parteien im Vorfeld der Europawahl 2019 enthält.\footnote{Vielen Dank an den Kollegen Jörg Haßler!} Speichern Sie diesen Datensatz in Ihrem Projektverzeichnis ab -- im Beispiel liegt der Datensatz im Unterordner \texttt{data}.

Funktionen zum Einlesen von Daten folgen im Tidyverse dem Namensschema \texttt{read\_}, wobei nach dem Unterstrich der Dateityp folgt. Für CSV-Dateien sind zwei Funktionen relevant:

\begin{itemize}
\tightlist
\item
  \texttt{read\_csv()} liest CSV-Dateien, die ein Komma \texttt{,} als Spalten- und einen Punkt \texttt{.} als Dezimaltrennzeichen verwenden
\item
  \texttt{read\_csv2()} liest CSV-Dateien, die ein Semikolon \texttt{;} als Spalten- und das Komma \texttt{,} als Dezimaltrennzeichen verwenden
\end{itemize}

Bei beiden Funktionen handelt es sich um spezifische Varianten der Funktion \texttt{read\_delim()}, bei der Trennzeichen etc. einzeln definiert werden können. In der Regel sollten aber die beiden oben genannten Funktionen ausreichen. Im Zweifelsfall können CSV-Dateien durch anklicken im \emph{Files}-Bereich in RStudio geöffnet werden, sodass ersichtlich wird, wie diese aufgebaut sind und welches Trennzeichen verwendet wird.

Alle Funktionen aus der \texttt{read\_}-Familie benötigen als erstes (und oft auch einziges) Argument den Dateipfad (relativ zum Arbeitsverzeichnis) als Textobjekt. Da unser Datensatz im Unterordner \texttt{data} liegt, lautet der gesamte Dateipfad also \texttt{"data/facebook\_europawahl.csv"}. Natürlich sollten wir das Resultat der Funktion einem treffend benannten Objekt zuweisen.\footnote{Häufig verwendete Objektnamen für Datensätze sind \texttt{df} und \texttt{data}, aber es schadet auch nicht, etwas spezifischere Namen zu vergeben, besonders wenn mit mehreren Datensätzen gearbeitet wird.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_fb_eu <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/facebook_europawahl.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Parsed with column specification:
## cols(
##   id = col_double(),
##   URL = col_character(),
##   party = col_character(),
##   timestamp = col_datetime(format = ""),
##   type = col_character(),
##   message = col_character(),
##   link = col_character(),
##   comments_count = col_double(),
##   shares_count = col_double(),
##   reactions_count = col_double(),
##   like_count = col_double(),
##   love_count = col_double(),
##   wow_count = col_double(),
##   haha_count = col_double(),
##   sad_count = col_double(),
##   angry_count = col_double()
## )
\end{verbatim}

Die Funktion teilt uns direkt mit, welche Objekttypen für welche Variable verwendet wurden, sodass wir hier auch direkt sehen können, ob z. B. eine numerische Variable als Text eingelesen wurde. Zudem ist der eingelesene Datensatz direkt ein \emph{Tibble}, wir müssen also nicht mehr durch \texttt{as\_tibble()} konvertieren.\footnote{Auch die Basisversion von R bietet Funktionen zum Einlesen von CSV-Dateien, die \texttt{read.csv()}, \texttt{read.csv2()} etc. heißen. Diese erzeugen einen Dataframe und sind weniger gut für große Dateien optimiert, sodass ich empfehle, immer direkt die Tidyverse-Funktionen zu nutzen. Generell erkennen Sie Tidyverse-Varianten von Funktionen der R-Basisversion daran, dass diese einen Unterstrich anstatt eines Punkts zur Worttrennung nutzen.}

Schauen wir uns unseren gerade geladenen Datensatz einmal an -- da unser Datensatz als Tibble vorliegt, erhalten wir die wichtigsten Informationen zu Struktur und einen Einblick in die Daten direkt in Konsole, wenn wir das Datensatz-Objekt aufrufen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_fb_eu}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 16
##       id URL   party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <dbl> <chr> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1     1 http~ oedp~ 2019-04-28 09:00:00 video "Guido~ http~              0            4               9          9          0
##  2     2 http~ tier~ 2019-04-28 13:57:00 photo "Aus u~ http~             17          130             395        354         23
##  3     3 http~ B90D~ 2019-04-28 06:00:01 video "Beim ~ http~             70           28             215        174         14
##  4     4 http~ FDP   2019-04-28 11:49:59 photo "Unser~ http~             16            9             262        254          7
##  5     5 http~ tier~ 2019-04-28 08:24:15 link  "Eine ~ http~              6           46             145        129         14
##  6     6 http~ CDU   2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8
##  7     7 http~ SPD   2019-04-28 13:06:09 photo "Katar~ http~            180           54             699        576         34
##  8     8 http~ Pira~ 2019-04-28 17:36:30 video "Unser~ http~              0           NA               7          6          0
##  9     9 http~ DieP~ 2019-04-28 07:44:28 link  "Der a~ http~             35           76             612        509         49
## 10    10 http~ CSU   2019-04-28 08:21:00 photo "#Klar~ http~            174           61             458        334          3
## # ... with 892 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

Wir haben also einen Datensatz mit 902 Zeilen bzw. Fällen -- im diesen Falle also Facebook-Posts -- und 16 Spalten bzw. Variablen. Darunter sind:

\begin{itemize}
\tightlist
\item
  eine numerische \texttt{id}, die \texttt{URL} und ein Zeitstempel (\texttt{timestamp}) des Posts
\item
  Die Parteiseite \texttt{party} von der der Post abgesetzt wurde
\item
  Der Typ (\texttt{type}) des Posts (Video, Photo, Link oder Status)
\item
  Der Text (\texttt{message}) des Posts und ein etwaiger enthaltener \texttt{link}
\item
  Die Anzahl verschiedener Facebook-Metriken, darunter Kommentare, Shares sowie Reactions gesamt und getrennt in einzelne Typen, allesamt auf \texttt{\_count} endend
\end{itemize}

\hypertarget{andere-dateiformate}{%
\subsection{Andere Dateiformate}\label{andere-dateiformate}}

Andere Dateiformate funktionieren analog -- in der Regel reicht es, die korrekte Funktion zu verwenden und den Dateipfad anzugeben. Allerdings müssen für proprietäre Dateiformate erst die -- mit dem Tidyverse bereits installierten -- Packages geladen werden:

\begin{itemize}
\tightlist
\item
  das Paket \texttt{readxl} bietet Funktionen zum Import von Excel-Dateien, z. B. \texttt{readxl::read\_xlsx()}
\item
  das Paket \texttt{haven} deckt den Import von Datensätzen aus anderer Statistiksoftware (SAS, Stata, SPSS) ab, z. B. \texttt{haven::read\_sav()} für SPSS-Datensätze
\end{itemize}

\hypertarget{daten-modifizieren}{%
\section{Daten modifizieren}\label{daten-modifizieren}}

Zur Datenmodifikation betrachten wir sechs zentrale Funktionen (+ einige zugehörige Hilfsfunktionen bzw. Variationen davon), die das Tidyverse -- genauer gesagt das Teilpaket \texttt{dplyr}\footnote{Wobei umstritten ist, ob man das Paket \emph{dee\_plier} oder \emph{deeply\_ar} ausspricht.} -- zur Verfügung stellt:

\begin{itemize}
\tightlist
\item
  \texttt{select()} zum Auswählen von Variablen (spaltenweise)
\item
  \texttt{filter()} zum Filtern von Variablen (zeilenweise)
\item
  \texttt{arrange()} zum Sortieren des Datensatzes
\item
  \texttt{mutate()} zum Erzeugen neuer Variablen
\item
  \texttt{summarize()} zum Zusammenfassen von Variablen
\item
  \texttt{group\_by} zum Gruppieren von Variablen
\end{itemize}

Alle Funktionen haben dabei gemeinsam (und das trifft auf nahezu alle Funktionen des Tidyverse zu), dass das erste Argument der Datensatz selbst (als Tibble) ist und auch das Resultat der Funktion wiederum ein Tibble ist.

\begin{figure}
\centering
\includegraphics{img/horst/dplyr_wrangling.png}
\caption{Illustration von @allison\_horst: \url{https://twitter.com/allison_horst}}
\end{figure}

\hypertarget{variablen-spaltenweise-auswuxe4hlen-mit-select}{%
\subsection{\texorpdfstring{Variablen spaltenweise auswählen mit \texttt{select()}}{Variablen spaltenweise auswählen mit select()}}\label{variablen-spaltenweise-auswuxe4hlen-mit-select}}

Mit \texttt{select()} können wir bestimmte Spalten eines Datensatzes auswählen. Hierzu übergeben wir nach dem Datensatz einfach alle Variablen, die wir benötigen, direkt als Objektnamen -- in unserem Beispiel \texttt{id}, \texttt{URL}, \texttt{party} usw. -- ohne Anführungszeichen durch Kommas getrennt:\footnote{Und natürlich müssen wir das Resultat der Funktionen immer einem Objekt zuweisen, wenn wir damit weiterarbeiten wollen -- zu Demonstrationszwecken reicht aber der reine Aufruf der Funktion.}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wähle nur die Variablen id, party und timestamp aus}
\KeywordTok{select}\NormalTok{(df_fb_eu, id, party, timestamp) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 3
##       id party            timestamp          
##    <dbl> <chr>            <dttm>             
##  1     1 oedp.de          2019-04-28 09:00:00
##  2     2 tierschutzpartei 2019-04-28 13:57:00
##  3     3 B90DieGruenen    2019-04-28 06:00:01
##  4     4 FDP              2019-04-28 11:49:59
##  5     5 tierschutzpartei 2019-04-28 08:24:15
##  6     6 CDU              2019-04-28 09:12:19
##  7     7 SPD              2019-04-28 13:06:09
##  8     8 Piratenpartei    2019-04-28 17:36:30
##  9     9 DiePARTEI        2019-04-28 07:44:28
## 10    10 CSU              2019-04-28 08:21:00
## # ... with 892 more rows
\end{verbatim}

Durch ein vorangstelltes \texttt{-} werden Variablen ausgeschlossen:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Entferne die id und die URL-Variable}
\KeywordTok{select}\NormalTok{(df_fb_eu, }\OperatorTok{-}\NormalTok{id, }\OperatorTok{-}\NormalTok{URL)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 14
##    party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count wow_count
##    <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>     <dbl>
##  1 oedp~ 2019-04-28 09:00:00 video "Guido~ http~              0            4               9          9          0         0
##  2 tier~ 2019-04-28 13:57:00 photo "Aus u~ http~             17          130             395        354         23         3
##  3 B90D~ 2019-04-28 06:00:01 video "Beim ~ http~             70           28             215        174         14         3
##  4 FDP   2019-04-28 11:49:59 photo "Unser~ http~             16            9             262        254          7         0
##  5 tier~ 2019-04-28 08:24:15 link  "Eine ~ http~              6           46             145        129         14         2
##  6 CDU   2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8         0
##  7 SPD   2019-04-28 13:06:09 photo "Katar~ http~            180           54             699        576         34         4
##  8 Pira~ 2019-04-28 17:36:30 video "Unser~ http~              0           NA               7          6          0         1
##  9 DieP~ 2019-04-28 07:44:28 link  "Der a~ http~             35           76             612        509         49         0
## 10 CSU   2019-04-28 08:21:00 photo "#Klar~ http~            174           61             458        334          3         5
## # ... with 892 more rows, and 3 more variables: haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

Durch ein vorangestelltes \texttt{neuer\_objektname\ =} können wir Variablen beim Auswählen auch direkt umbenennen:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Benenne party und message beim Auswählen um in partei respektive inhalt}
\KeywordTok{select}\NormalTok{(df_fb_eu, }\DataTypeTok{partei =}\NormalTok{ party, }\DataTypeTok{inhalt =}\NormalTok{ message)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 2
##    partei          inhalt                                                                                                        
##    <chr>           <chr>                                                                                                         
##  1 oedp.de         "Guido #Klamt aus #Ludwigsburg, Listenplatz 5 auf der Kandidatenliste der #ÖDP zur #Europawahl, stellt sich u~
##  2 tierschutzpart~ "Aus unserem Europawahlprogramm, Kapitel 7: Gesundheits- und Sozialpolitik:  Bezahlbarer Wohnraum ist wesentl~
##  3 B90DieGruenen   "Beim Wahlkampf-Camp in Berlin waren gestern hunderte Freiwillige, die sich im Tür-zu-Tür-Wahlkampf, beim Mob~
##  4 FDP             "Unser neuer Bundesvorstand \U0001f389\U0001f38a\U0001f388 #ChancenNutzen \U0001f680#BPT19"                   
##  5 tierschutzpart~ "Eine neue Studie der Universität Oxford zeigt, dass eine vegane Ernährung der wahrscheinlich größte Hebel is~
##  6 CDU             "Freiheit ist nicht selbstverständlich. #UnserEuropa steht für freiheitliche Werte, Vertrauen und gute Partne~
##  7 SPD             "Katarina Barley sagt: Eine weitere Koalition mit der #EVP will ich nicht - wir sagen: gut so! Wir wollen ein~
##  8 Piratenpartei   "Unser Spitzenkandidat Patrick Breyer mit einem Update zum EU19 Workshop in Koblenz:"                         
##  9 DiePARTEI       "Der absolut härteste „Martin-Sonneborn-Moment“ kommt für Watson.de nach der Machtübernahme... Smiley!"       
## 10 CSU             "#Klartext von Bayerns Ministerpräsident und CSU-Chef Markus Söder in der \"Welt am Sonntag\":  Ohne schwarz ~
## # ... with 892 more rows
\end{verbatim}

Um Variablen basierend auf Namensbestandteilen auszuwählen, sind einige Hilfsfunktionen - z. B. \texttt{starts\_with()}, \texttt{ends\_with()} und \texttt{contains()} - verfügbar. Da in unserem Beispiel alle Facebook-Metriken auf \texttt{\_count} enden, können wir diese gesammelt mit \texttt{ends\_with("count")} auswählen:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wähle party und alle Facebook-Metriken aus}
\KeywordTok{select}\NormalTok{(df_fb_eu, party, }\KeywordTok{ends_with}\NormalTok{(}\StringTok{"count"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 10
##    party            comments_count shares_count reactions_count like_count love_count wow_count haha_count sad_count angry_count
##    <chr>                     <dbl>        <dbl>           <dbl>      <dbl>      <dbl>     <dbl>      <dbl>     <dbl>       <dbl>
##  1 oedp.de                       0            4               9          9          0         0          0         0           0
##  2 tierschutzpartei             17          130             395        354         23         3         11         2           2
##  3 B90DieGruenen                70           28             215        174         14         3         16         0           8
##  4 FDP                          16            9             262        254          7         0          1         0           0
##  5 tierschutzpartei              6           46             145        129         14         2          0         0           0
##  6 CDU                         239          136             398        292          8         0         58         2          38
##  7 SPD                         180           54             699        576         34         4         79         1           5
##  8 Piratenpartei                 0           NA               7          6          0         1          0         0           0
##  9 DiePARTEI                    35           76             612        509         49         0         54         0           0
## 10 CSU                         174           61             458        334          3         5         90         2          24
## # ... with 892 more rows
\end{verbatim}

Schließlich kann die Hilfsfunktion \texttt{everything()} (ohne Argumente) genutzt werden, um sämtliche nicht zuvor angegebenen Variablen auswählen -- das ist hilfreiche, wenn nur bestimmte Variablen z. B. umbenannt oder an den Anfang des Datensatzes gestellt werden sollen, aber man nicht alle anderen Variablen von Hand tippen möchte:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Stelle party umbenannt in Partei an den Anfang und hänge alle verbleibenden Variablen an}
\KeywordTok{select}\NormalTok{(df_fb_eu, }\DataTypeTok{Partei =}\NormalTok{ party, }\KeywordTok{everything}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 16
##    Partei    id URL   timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <chr>  <dbl> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1 oedp.~     1 http~ 2019-04-28 09:00:00 video "Guido~ http~              0            4               9          9          0
##  2 tiers~     2 http~ 2019-04-28 13:57:00 photo "Aus u~ http~             17          130             395        354         23
##  3 B90Di~     3 http~ 2019-04-28 06:00:01 video "Beim ~ http~             70           28             215        174         14
##  4 FDP        4 http~ 2019-04-28 11:49:59 photo "Unser~ http~             16            9             262        254          7
##  5 tiers~     5 http~ 2019-04-28 08:24:15 link  "Eine ~ http~              6           46             145        129         14
##  6 CDU        6 http~ 2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8
##  7 SPD        7 http~ 2019-04-28 13:06:09 photo "Katar~ http~            180           54             699        576         34
##  8 Pirat~     8 http~ 2019-04-28 17:36:30 video "Unser~ http~              0           NA               7          6          0
##  9 DiePA~     9 http~ 2019-04-28 07:44:28 link  "Der a~ http~             35           76             612        509         49
## 10 CSU       10 http~ 2019-04-28 08:21:00 photo "#Klar~ http~            174           61             458        334          3
## # ... with 892 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

\hypertarget{variablen-zeilenweise-filtern-mit-filter}{%
\subsection{\texorpdfstring{Variablen zeilenweise filtern mit \texttt{filter()}}{Variablen zeilenweise filtern mit filter()}}\label{variablen-zeilenweise-filtern-mit-filter}}

Um nur bestimmte Zeilen auswählen, können wir mittels \texttt{filter()} eine oder mehrere Bedingungen übergeben, die analog zu den \texttt{if}-Bedingungen in Kapitel \ref{conditions} angegeben werden. Zuerst wird erneut der Datensatz übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wähle alle Facebookposts mit mindestens einem Kommentar}
\KeywordTok{filter}\NormalTok{(df_fb_eu, comments_count }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{# Achten Sie in der Ausgabe auf die veränderte Zeilenanzahl}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 832 x 16
##       id URL   party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <dbl> <chr> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1     2 http~ tier~ 2019-04-28 13:57:00 photo "Aus u~ http~             17          130             395        354         23
##  2     3 http~ B90D~ 2019-04-28 06:00:01 video "Beim ~ http~             70           28             215        174         14
##  3     4 http~ FDP   2019-04-28 11:49:59 photo "Unser~ http~             16            9             262        254          7
##  4     5 http~ tier~ 2019-04-28 08:24:15 link  "Eine ~ http~              6           46             145        129         14
##  5     6 http~ CDU   2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8
##  6     7 http~ SPD   2019-04-28 13:06:09 photo "Katar~ http~            180           54             699        576         34
##  7     9 http~ DieP~ 2019-04-28 07:44:28 link  "Der a~ http~             35           76             612        509         49
##  8    10 http~ CSU   2019-04-28 08:21:00 photo "#Klar~ http~            174           61             458        334          3
##  9    11 http~ DieP~ 2019-04-28 08:11:28 video "Anste~ http~             61          312            1601       1344         77
## 10    12 http~ alte~ 2019-04-28 14:55:00 link  "++ Ha~ http~           1163         1499            3944        540          4
## # ... with 822 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

Natürlich können auch Boolesche Operatoren (\texttt{!} für \texttt{NICHT}, \texttt{\&} für \texttt{UND}, \texttt{\textbar{}} für \texttt{ODER}) verwendet werden. Mehrere Bedingungen können auch per \texttt{,} getrennt werden (\texttt{UND}-Verknüpfung):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wähle nur Video-Posts der großen Koalition, die keine fehlenden Werte bei den Shares haben}
\KeywordTok{filter}\NormalTok{(df_fb_eu, party }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"CDU"}\NormalTok{, }\StringTok{"CSU"}\NormalTok{, }\StringTok{"SPD"}\NormalTok{), type }\OperatorTok{==}\StringTok{ "video"}\NormalTok{, }\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(shares_count))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 62 x 16
##       id URL   party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <dbl> <chr> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1     6 http~ CDU   2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8
##  2    18 http~ CDU   2019-04-29 11:38:01 video "Live:~ http~            140           17             190        131          4
##  3    26 http~ SPD   2019-04-29 09:02:51 video "Press~ http~            174           67             312        239         30
##  4    31 http~ CDU   2019-04-29 09:58:45 video "Da st~ http~            274           76             448        302         14
##  5    93 http~ CDU   2019-05-01 09:00:47 video "Heute~ http~            305          113             513        308         17
##  6   122 http~ CDU   2019-05-02 18:00:01 video "Heute~ http~            122           97             296        243         12
##  7   141 http~ CDU   2019-05-03 14:06:29 video "Anneg~ http~            158           65             247        157          0
##  8   152 http~ SPD   2019-05-03 14:00:10 video "Jetzt~ http~            515          114             747        572         48
##  9   178 http~ CSU   2019-05-05 08:30:00 video "Die E~ http~            153           55             245        124          0
## 10   197 http~ CSU   2019-05-06 11:04:28 video "Press~ http~             98           23             198        136         11
## # ... with 52 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

\hypertarget{daten-sortieren-mit-arrange}{%
\subsection{\texorpdfstring{Daten sortieren mit \texttt{arrange()}}{Daten sortieren mit arrange()}}\label{daten-sortieren-mit-arrange}}

Um den Datensatz für die Ansicht umzusortieren, wird die Funktion \texttt{arrange()} genutzt, die aufsteigend nach den angegebenen Variablen sortiert:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sortiere aufsteigend nach Datum}
\KeywordTok{arrange}\NormalTok{(df_fb_eu, timestamp)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 16
##       id URL   party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <dbl> <chr> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1     3 http~ B90D~ 2019-04-28 06:00:01 video "Beim ~ http~             70           28             215        174         14
##  2    13 http~ FDP   2019-04-28 06:18:18 photo "Wir w~ http~             47          110             622        589         24
##  3     9 http~ DieP~ 2019-04-28 07:44:28 link  "Der a~ http~             35           76             612        509         49
##  4    11 http~ DieP~ 2019-04-28 08:11:28 video "Anste~ http~             61          312            1601       1344         77
##  5    10 http~ CSU   2019-04-28 08:21:00 photo "#Klar~ http~            174           61             458        334          3
##  6     5 http~ tier~ 2019-04-28 08:24:15 link  "Eine ~ http~              6           46             145        129         14
##  7     1 http~ oedp~ 2019-04-28 09:00:00 video "Guido~ http~              0            4               9          9          0
##  8     6 http~ CDU   2019-04-28 09:12:19 video "Freih~ http~            239          136             398        292          8
##  9    15 http~ FDP   2019-04-28 10:40:57 photo "Weil ~ http~             14           19             226        210         12
## 10     4 http~ FDP   2019-04-28 11:49:59 photo "Unser~ http~             16            9             262        254          7
## # ... with 892 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

Werden mehrere Variablen angegeben, wird zunächst nach der ersten Variablen, dann innerhalb der ersten Variablen nach der zweiten Variablen usw. sortiert. Soll eine Variable stattdessen absteigend sortiert werden, wird der Variablenname in die Hilfsfunktion \texttt{desc()} gepackt:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sortiere alphabetisch aufsteigend nach Partei}
\CommentTok{# und innerhalb von Parteien absteigend nach Kommentaranzahl}
\KeywordTok{arrange}\NormalTok{(df_fb_eu, party, }\KeywordTok{desc}\NormalTok{(comments_count))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 16
##       id URL   party timestamp           type  message link  comments_count shares_count reactions_count like_count love_count
##    <dbl> <chr> <chr> <dttm>              <chr> <chr>   <chr>          <dbl>        <dbl>           <dbl>      <dbl>      <dbl>
##  1   870 http~ alte~ 2019-05-26 15:50:19 video "+++ H~ http~           4829          804            6472       5036       1319
##  2   752 http~ alte~ 2019-05-23 17:24:43 video "+++ E~ http~           3294          992            4469       3730        688
##  3   616 http~ alte~ 2019-05-20 09:49:00 photo "++ Me~ http~           3100        11719           10163       3857         19
##  4   802 http~ alte~ 2019-05-24 17:01:12 video "+++ S~ http~           2874          589            3164       2566        547
##  5    44 http~ alte~ 2019-04-30 19:02:07 video "2. Te~ http~           2862          846            2781       2279        450
##  6   335 http~ alte~ 2019-05-10 17:27:58 video "+++ H~ http~           2425          717            2695       2195        456
##  7   343 http~ alte~ 2019-05-11 13:12:00 photo "++ Di~ http~           2363         5842            7225       1742         14
##  8    50 http~ alte~ 2019-04-30 17:18:13 video "+++ H~ http~           2246          635            2692       2218        433
##  9   198 http~ alte~ 2019-05-06 09:15:00 photo "++ Tä~ http~           1947         4037            8411       1319         11
## 10   868 http~ alte~ 2019-05-26 11:19:19 photo "++ Wi~ http~           1744         1281           11277      10662        498
## # ... with 892 more rows, and 4 more variables: wow_count <dbl>, haha_count <dbl>, sad_count <dbl>, angry_count <dbl>
\end{verbatim}

\hypertarget{neue-variablen-hinzufuxfcgen-mit-mutate}{%
\subsection{\texorpdfstring{Neue Variablen hinzufügen mit \texttt{mutate()}}{Neue Variablen hinzufügen mit mutate()}}\label{neue-variablen-hinzufuxfcgen-mit-mutate}}

Mit \texttt{mutate()}, dem vielleicht einzigen nicht selbsterklärenden Funktionsnamen der sechs diskutierten Funktione, können wir Datensätzen neue Variablen hinzufügen (oder alte überschreiben). Hierzu geben wir den neuen Variablennamen an, gefolgt von einem \texttt{=} und der Berechnung bzw. Konstruktion der neuen Variablen. Wird als Variablenname ein schon im Datensatz bestehender Variablenname verwendet, so wird diese Variable überschrieben. Mit Kommas getrennt können auch mehrere neue Variablen erstellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wir erstellen eine neue Variable comments_centered,}
\CommentTok{# die die Kommentarzahl am allgemeinen Mittelwert zentriert}
\CommentTok{# indem wir von jedem Wert den Mittelwert der Kommentarzahl abziehen}
\CommentTok{# und wandeln die bestehende Variable message in Kleinschreibung}
\CommentTok{# mittels der Funktion tolower() um.}
\CommentTok{#}
\CommentTok{# Zur Darstellung werden die beiden 'mutierten' Variablen }
\CommentTok{# anschließend mit select() ausgewählt}

\NormalTok{df_mutated <-}\StringTok{ }\KeywordTok{mutate}\NormalTok{(df_fb_eu,}
       \DataTypeTok{comments_centered =}\NormalTok{ comments_count }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
       \DataTypeTok{message =} \KeywordTok{tolower}\NormalTok{(message))}

\KeywordTok{select}\NormalTok{(df_mutated, comments_centered, message)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 2
##    comments_centered message                                                                                                     
##                <dbl> <chr>                                                                                                       
##  1            -159.  "guido #klamt aus #ludwigsburg, listenplatz 5 auf der kandidatenliste der #ödp zur #europawahl, stellt sich~
##  2            -142.  "aus unserem europawahlprogramm, kapitel 7: gesundheits- und sozialpolitik:  bezahlbarer wohnraum ist wesen~
##  3             -89.2 "beim wahlkampf-camp in berlin waren gestern hunderte freiwillige, die sich im tür-zu-tür-wahlkampf, beim m~
##  4            -143.  "unser neuer bundesvorstand \U0001f389\U0001f38a\U0001f388 #chancennutzen \U0001f680#bpt19"                 
##  5            -153.  "eine neue studie der universität oxford zeigt, dass eine vegane ernährung der wahrscheinlich größte hebel ~
##  6              79.8 "freiheit ist nicht selbstverständlich. #unsereuropa steht für freiheitliche werte, vertrauen und gute part~
##  7              20.8 "katarina barley sagt: eine weitere koalition mit der #evp will ich nicht - wir sagen: gut so! wir wollen e~
##  8            -159.  "unser spitzenkandidat patrick breyer mit einem update zum eu19 workshop in koblenz:"                       
##  9            -124.  "der absolut härteste „martin-sonneborn-moment“ kommt für watson.de nach der machtübernahme... smiley!"     
## 10              14.8 "#klartext von bayerns ministerpräsident und csu-chef markus söder in der \"welt am sonntag\":  ohne schwar~
## # ... with 892 more rows
\end{verbatim}

\hypertarget{variablen-zusammenfassen-mit-summarize}{%
\subsection{\texorpdfstring{Variablen zusammenfassen mit \texttt{summarize()}}{Variablen zusammenfassen mit summarize()}}\label{variablen-zusammenfassen-mit-summarize}}

Mit \texttt{summarize()}\footnote{Wer \emph{the King's English} bevorzugt: \texttt{summarise()} funktioniert auch.} fassen wir Variablen zusammen, indem wir Funktionen auf eine Variable anwenden. Das Resultat ist ein neues Tibble, das die zusammengefassten Variablen als Spalten enthält. Die Funktionsweise ist ähnlich wie bei \texttt{mutate()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Mittelwert der drei zentralen Facebook-Metriken berechen}
\KeywordTok{summarize}\NormalTok{(df_fb_eu, }
          \DataTypeTok{mean_comments =} \KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_shares =} \KeywordTok{mean}\NormalTok{(shares_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_reactions =} \KeywordTok{mean}\NormalTok{(reactions_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1 x 3
##   mean_comments mean_shares mean_reactions
##           <dbl>       <dbl>          <dbl>
## 1          159.        249.           846.
\end{verbatim}

\hypertarget{variablen-gruppieren-mit-group_by}{%
\subsection{\texorpdfstring{Variablen gruppieren mit \texttt{group\_by()}}{Variablen gruppieren mit group\_by()}}\label{variablen-gruppieren-mit-group_by}}

Mittels \texttt{group\_by()} können wir unseren Datensatz nach einer oder mehrerer Variablen gruppieren. Das Resultat ist erstmal ein Tibble, das nicht weiter von unserem Ausgangs-Tibble unterscheidet. Die Gruppierung wird dann jedoch bei folgenden Funktionen wie \texttt{mutate()} oder \texttt{summarize()} berücksichtig.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wir berechnen erneut die zentralen Facebook-Metriken}
\CommentTok{# mit summarize(), gruppieren aber zuvor nach Partei}

\NormalTok{grouped_df <-}\StringTok{ }\KeywordTok{group_by}\NormalTok{(df_fb_eu, party)}

\KeywordTok{summarize}\NormalTok{(grouped_df, }\DataTypeTok{mean_comments =} \KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_shares =} \KeywordTok{mean}\NormalTok{(shares_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_reactions =} \KeywordTok{mean}\NormalTok{(reactions_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 14 x 4
##    party                           mean_comments mean_shares mean_reactions
##    <chr>                                   <dbl>       <dbl>          <dbl>
##  1 alternativefuerde                     863.         1796.          4032. 
##  2 B90DieGruenen                         106.          184.           660. 
##  3 CDU                                   349.           87.1          628. 
##  4 CSU                                   136.           57.1          499. 
##  5 DiePARTEI                              60.4         160.          1343. 
##  6 FamilienParteiDeutschlands              0.633        16.0           10.5
##  7 FDP                                    70            67.3          447. 
##  8 freie.waehler.bundesvereinigung        25.3          43.1          141. 
##  9 linkspartei                           116.          218.           935. 
## 10 oedp.de                                 6.58         29.5          110. 
## 11 Piratenpartei                          11.4          42.5          124. 
## 12 SPD                                   220.          149.           719. 
## 13 tierschutzpartei                       67.4         391.           979. 
## 14 VoltDeutschland                        15.6          39.8          230.
\end{verbatim}

Analog wird auch bei \texttt{mutate()} die Gruppierung in den Berechnungen berücksichtigt. Wenden wir die oben durchgeführte Mittelwert-Zentrierung der Kommentaranzahl auf unseren gruppierten Datensatz an, wird durch die \texttt{mean()}-Funktion der Mittelwert \emph{innerhalb} der Gruppen (hier also der Parteien) berechnet. Im Ergebnis bekommen wir also für jeden Facebook-Post einen Wert, wie dieser von der durchschnittlichen Kommentaranzahl auf dieser Parteienseite abweicht:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mutated_df <-}\StringTok{ }\KeywordTok{mutate}\NormalTok{(grouped_df, }
                     \DataTypeTok{comments_group_centered =}\NormalTok{ comments_count }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}

\KeywordTok{select}\NormalTok{(mutated_df, party, comments_group_centered, comments_count)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 902 x 3
## # Groups:   party [14]
##    party            comments_group_centered comments_count
##    <chr>                              <dbl>          <dbl>
##  1 oedp.de                            -6.58              0
##  2 tierschutzpartei                  -50.4              17
##  3 B90DieGruenen                     -35.5              70
##  4 FDP                               -54                16
##  5 tierschutzpartei                  -61.4               6
##  6 CDU                              -110.              239
##  7 SPD                               -40.4             180
##  8 Piratenpartei                     -11.4               0
##  9 DiePARTEI                         -25.4              35
## 10 CSU                                37.7             174
## # ... with 892 more rows
\end{verbatim}

Wir können auch nach mehreren Variablen gruppieren:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wir berechnen erneut die zentralen Facebook-Metriken}
\CommentTok{# mit summarize(), gruppieren aber zuvor nach Partei UND Post-Typ}

\NormalTok{grouped_df <-}\StringTok{ }\KeywordTok{group_by}\NormalTok{(df_fb_eu, party, type)}

\KeywordTok{summarize}\NormalTok{(grouped_df, }\DataTypeTok{mean_comments =} \KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_shares =} \KeywordTok{mean}\NormalTok{(shares_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
          \DataTypeTok{mean_reactions =} \KeywordTok{mean}\NormalTok{(reactions_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 46 x 5
## # Groups:   party [14]
##    party             type   mean_comments mean_shares mean_reactions
##    <chr>             <chr>          <dbl>       <dbl>          <dbl>
##  1 alternativefuerde link           826.       1341.           2953 
##  2 alternativefuerde photo          860.       2466.           5269.
##  3 alternativefuerde video          875.        847.           2340.
##  4 B90DieGruenen     photo          134.        183.            902.
##  5 B90DieGruenen     video           77.9       184.            425.
##  6 CDU               photo          394.        114.            810.
##  7 CDU               video          293.         53.0           400.
##  8 CSU               link            25          11             132.
##  9 CSU               photo          143.         63.8           566.
## 10 CSU               status         416.        112.           1106 
## # ... with 36 more rows
\end{verbatim}

Gruppierungen können (und sollten) im Anschluss mittels \texttt{ungroup()} wieder entfernt werden (auch hier wir der Datensatz als Argument übergeben).

Eine besondere Variante von \texttt{group\_by()} ist \texttt{rowwise()}, die den Datensatz zeilenweise gruppiert; dies ermöglicht zeilenweise Berechnungen mit Funktionen über mehrere Variablen hinweg, z. B. die Erstellung von Mittelwerts-Indizes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Gruppiere den Datensatz zeilenweise, um für jeden Post}
\CommentTok{# den Mittelwert der einzelnen Reactions (Like, Love etc.)}
\CommentTok{# zu berechnen}

\NormalTok{rowwise_df <-}\StringTok{ }\KeywordTok{rowwise}\NormalTok{(df_fb_eu)}

\NormalTok{mutated_df <-}\StringTok{ }\KeywordTok{mutate}\NormalTok{(rowwise_df, }
                     \DataTypeTok{mean_reactions =} \KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(like_count, love_count, wow_count, haha_count, sad_count, angry_count),}
                                           \DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}

\KeywordTok{select}\NormalTok{(mutated_df, mean_reactions)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Source: local data frame [902 x 1]
## Groups: <by row>
## 
## # A tibble: 902 x 1
##    mean_reactions
##             <dbl>
##  1           1.5 
##  2          65.8 
##  3          35.8 
##  4          43.7 
##  5          24.2 
##  6          66.3 
##  7         116.  
##  8           1.17
##  9         102   
## 10          76.3 
## # ... with 892 more rows
\end{verbatim}

Eine Funktion, die einen häufigen Anwendungsfall von \texttt{group\_by()}, \texttt{summarize()} und \texttt{ungroup()} kombiniert, ist \texttt{count()}, die die Fallzahl einer oder mehrerer Gruppierungsvariablen ausgibt:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Zähle Posts pro Partei}
\KeywordTok{count}\NormalTok{(df_fb_eu, party)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 14 x 2
##    party                               n
##    <chr>                           <int>
##  1 alternativefuerde                  79
##  2 B90DieGruenen                      67
##  3 CDU                                64
##  4 CSU                               103
##  5 DiePARTEI                          96
##  6 FamilienParteiDeutschlands         30
##  7 FDP                                94
##  8 freie.waehler.bundesvereinigung    30
##  9 linkspartei                        38
## 10 oedp.de                            71
## 11 Piratenpartei                      73
## 12 SPD                                49
## 13 tierschutzpartei                   33
## 14 VoltDeutschland                    75
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Zähle Posts pro Partei und Post-Typ}
\KeywordTok{count}\NormalTok{(df_fb_eu, party, type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 46 x 3
##    party             type       n
##    <chr>             <chr>  <int>
##  1 alternativefuerde link       7
##  2 alternativefuerde photo     45
##  3 alternativefuerde video     27
##  4 B90DieGruenen     photo     32
##  5 B90DieGruenen     video     35
##  6 CDU               photo     35
##  7 CDU               video     29
##  8 CSU               link       3
##  9 CSU               photo     76
## 10 CSU               status     2
## # ... with 36 more rows
\end{verbatim}

\hypertarget{daten-speichern}{%
\section{Daten speichern}\label{daten-speichern}}

Wenn wir unsere Dateien modifiziert haben, möchten wir diese wohl auch speichern bzw. exportieren.

\hypertarget{tabellarische-daten-exportieren}{%
\subsection{Tabellarische Daten exportieren}\label{tabellarische-daten-exportieren}}

Analog zu den \texttt{read\_}-Funktionen stehen daher Exportfunktionen nach dem Schema \texttt{write\_} zur Verfügung. Als Argumente werden dabei der Datensatz, der gespeichert werden soll, sowie der Dateipfad der zu speichernden Datei übergeben. Haben wir durch Modifikation beispielsweise das Tibble \texttt{df\_modified} erstellt und möchten es in der Datei \texttt{datensatz\_modifiziert.csv} im Unterordner \texttt{data} abspeichern, führen wir die \texttt{write\_csv()}-Funktion aus:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write_csv}\NormalTok{(df_modified, }\StringTok{"data/datensatz_modifiziert.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{write\_csv()} nutzt dabei das Komma \texttt{,} als Spalten- und einen Punkt \texttt{.} als Dezimaltrennzeichen. Möchten wir stattdessen das in Deutschland gebräuchliche Format mit Semikolon \texttt{;} als Spalten- und Komma \texttt{,} als Dezimaltrennzeichen haben, verwenden wir analog zu \texttt{read\_csv2()} \texttt{write\_csv2()}.

Da Excel öfters Probleme mit dem Einlesen von CSV-Dateien hat, können, soll die Datei danach in Excel betrachtet werden, auch die Funktionen \texttt{write\_excel\_csv()} bzw. \texttt{write\_excel\_csv2()} verwendet werden. Dies fügt ein spezielles Zeichen hinzu, das Excel den Datenimport erleichert.

\hypertarget{r-objekte-exportieren}{%
\subsection{R-Objekte exportieren}\label{r-objekte-exportieren}}

Beim Export als CSV gehen unweigerlich auch Informationen verloren -- bei unserem Datensatz beispielsweise die Objekttypen, die R den jeweiligen Variablen zugeordnet hat. Wollen wir R-Objekte daher für die zukünftige Verwendung in R abspeichern, lohnt es sich, direkt das jeweilige R-Objekt zu exportieren. Hierfür steht das Dateiformat \texttt{.rds} zur Verfügung, mit dem beliebige R-Objekte -- neben Datensätzen also auch Vektoren, Listen, statistische Modelle etc. - gespeichert werden können.

Die zugehörige Funktion lautet \texttt{saveRDS()} und wird analog zu den \texttt{write\_}-Funktionen verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{saveRDS}\NormalTok{(df_modified, }\StringTok{"data/datensatz_modifiziert.rds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

RDS-Dateien können dann jederzeit mit der Funktion \texttt{readRDS()} wieder geladen werden.

Sollen mehrere R-Objekte exportiert werden -- also beispielsweise ein Ausgangsdatensatz, ein modifizierter Arbeitsdatensatz und zugehörige statistische Modelle -- kann das Dateiformat \texttt{.RData} und die Funktion \texttt{save()} verwendet werden. Dabei werden alle zu speichernden Objekte gefolgt von dem benannten Argument \texttt{file\ =}, das den Dateipfad angibt, in dem Funktionsaufruf genannt:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{save}\NormalTok{(df_fb_eu, df_modified, }\StringTok{"data/eu_file.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

So exportiere Objekte können dann gesammelt über die \texttt{load()}-Funktion, die den Dateipfad als Argument benötigt, wieder geladen werden, was sehr praktisch ist, um direkt den gesamten Arbeitsstand wiederherzustellen.

\hypertarget{uxfcbungsaufgaben-4}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-4}}

Erstellen Sie für die folgenden Übungsaufgaben eine eigene Skriptdatei oder eine R-Markdown-Datei und speichern diese als \texttt{ue8\_nachname.R} bzw. \texttt{ue8\_nachname.Rmd} ab.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue8-1}{}{\label{exr:ue8-1} }Daten laden:
\EndKnitrBlock{exercise}

Laden Sie die Datei \texttt{facebook\_europawahl.csv} aus Moodle in Ihr Projektverzeichnis herunter und laden Sie den Datensatz.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue8-2}{}{\label{exr:ue8-2} }Daten modifizieren und speichern:
\EndKnitrBlock{exercise}

Erstellen Sie einen Teildatensatz, der:

\begin{itemize}
\tightlist
\item
  nur Posts der aktuell im Bundestag vertretenen Parteien enthält (CDU, CSU, SPD, FDP, Linke, Grüne, AfD); Tipp: Betrachten Sie vorab die Schreibweise der Parteien (bzw. deren Facebook-Accounts)
\item
  nur die Variablen \texttt{party}, \texttt{timestamp}, \texttt{type} sowie alle Facebook-Metriken enthält
\item
  eine neue Variable \texttt{total\_count} enthält, in der für jeden Post die Gesamtzahl der Kommentare, Shares und Reactions angegeben ist
\end{itemize}

Speichern Sie diesen Teildatensatz sowohl als CSV- als auch als RDS-Datei.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue8-3}{}{\label{exr:ue8-3} }Daten modifizieren und zusammenfassen:
\EndKnitrBlock{exercise}

Nutzen Sie die oben vorgestellten Funktionen, um Mittelwert und Standardabweichung der drei Facebook-Metriken (Kommentare, Shares, Reactions) aller Posts zu berechnen, die in der Woche vor der Wahl (also nach dem 19.05.2019) erschienen sind.

Tipp: Logische Operatoren funktionieren auch mit Datums- und Zeitvariablen; Text, der wie ein Datum aussieht, wir dabei automatisch in ein Datum bzw. eine Zeitangabe konvertiert.

\hypertarget{der-pipe-operator}{%
\chapter{\texorpdfstring{Der Pipe-Operator \texttt{\%\textgreater{}\%}}{Der Pipe-Operator \%\textgreater\%}}\label{der-pipe-operator}}

Neben vielen praktischen Funktionen und der Datenstruktur Tibbles führt das Tidyverse auch ein neuens Syntax-Konzept in R ein: den sogenannten Pipe-Operator \texttt{\%\textgreater{}\%}, mit dem Argumente auf eine andere Art und Weise an Funktionen übergeben werden.\footnote{Das Konzept ist aus anderen Programmiersprachen entlehnt und wurde ursprünglich durch das Package \texttt{magrittr} in R eingeführt; soll der Pipe-Operator \texttt{\%\textgreater{}\%} ohne das Tidyverse-Package genutzt werden, kann also dieses Package geladen werden: \texttt{library(magrittr)}.}

\hypertarget{lesbarkeit-verschachtelter-funktionen}{%
\section{Lesbarkeit verschachtelter Funktionen}\label{lesbarkeit-verschachtelter-funktionen}}

Hierzu rufen wir uns zunächst noch einmal in Erinnerung, wie Funktionen in R grundsätzlich aufgerufen werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{funktionsname}\NormalTok{(}\DataTypeTok{argument1 =}\NormalTok{ wert1, }\DataTypeTok{argument2 =}\NormalTok{ wert2, }\DataTypeTok{argument3 =}\NormalTok{ wert3, ...)}
\end{Highlighting}
\end{Shaded}

Wir haben außerdem bereits gesehen, dass wir Funktionen ineinander verschachteln können, wenn wir mehrere Funktionen hintereinander aufrufen möchten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{round}\NormalTok{(}\KeywordTok{mean}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length), }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.84
\end{verbatim}

Das wird jedoch irgendwann sehr unübersichtlich und anfällig für Fehler -- bereits bei diesem Beispiel müssen wir darauf achten, dass die Klammern zur richtigen Zeit geöffnet und vor allem wieder geschlossen werden, und wir müssen ``Klammern zählen'', wenn wir wissen wollen, zu welcher der aufgerufenen Funktionen das Argument \texttt{2} gehört. Zusätzlich ergibt sich durch die Verschachtelung die unnatürliche Lesereihenfolge von innen nach außen, was komplexeren Code schwer nachvollziehbar macht.

\hypertarget{ein-beispiel-in-pseudo-code}{%
\section{Ein Beispiel in Pseudo-Code}\label{ein-beispiel-in-pseudo-code}}

Um dies zu verdeutlichen, stellen wir uns einmal vor, eine typische Morgenroutine bestünde aus ``Funktionen'', die wir der Reihe nach ``aufrufen'':

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufstehen
\item
  Frühstücken
\item
  Zähne putzen
\item
  Duschen
\item
  Anziehen
\end{enumerate}

In R-Code ausgedrückt würde das also wie folgt aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einsatzbereit <-}\StringTok{ }\KeywordTok{anziehen}\NormalTok{(}\KeywordTok{duschen}\NormalTok{(}\KeywordTok{zaehne_putzen}\NormalTok{(}\KeywordTok{fruehstuecken}\NormalTok{(}\KeywordTok{aufstehen}\NormalTok{(ich), }\DataTypeTok{food =} \StringTok{"muesli"}\NormalTok{)), }\DataTypeTok{wasser_temperatur =} \StringTok{"warm"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Wir könnten das ganze durch Einrückungen zumindest etwas lesbarer gestalten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einsatzbereit <-}\StringTok{ }\KeywordTok{anziehen}\NormalTok{(}
  \KeywordTok{duschen}\NormalTok{(}
    \KeywordTok{zaehne_putzen}\NormalTok{(}
      \KeywordTok{fruehstuecken}\NormalTok{(}
        \KeywordTok{aufstehen}\NormalTok{(ich), }
        \DataTypeTok{food =} \StringTok{"muesli"}\NormalTok{)}
\NormalTok{      ), }\DataTypeTok{wasser_temperatur =} \StringTok{"warm"}\NormalTok{)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Das ist schon etwas besser, aber immer noch nicht sonderlich intuitiv zu lesen -- und schließen wir nur eine Klammer an der falschen Stelle oder vergessen sie gar ganz, fliegt uns der gesamte Code um die Ohren.

Natürlich könnten wir die Schritte der Morgenroutine auch einzeln durchgehen und jeweils einem neuen ``Objekt'' zuweisen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wach <-}\StringTok{ }\KeywordTok{aufstehen}\NormalTok{(ich)}
\NormalTok{satt <-}\StringTok{ }\KeywordTok{fruehstuecken}\NormalTok{(wach, }\DataTypeTok{food =} \StringTok{"muesli"}\NormalTok{)}
\NormalTok{sauber1 <-}\StringTok{ }\KeywordTok{zaehe_putzen}\NormalTok{(satt)}
\NormalTok{sauber2 <-}\StringTok{ }\KeywordTok{duschen}\NormalTok{(sauber1, }\DataTypeTok{wasser_temperatur =} \StringTok{"warm"}\NormalTok{)}
\NormalTok{einsatzbereit <-}\StringTok{ }\KeywordTok{anziehen}\NormalTok{(sauber2)}
\end{Highlighting}
\end{Shaded}

Das erzeugt aber viele Objekte, die wir gar nicht weiter benötigen, da wir nur an \texttt{einsatzbereit} interessiert sind. Wir könnten natürlich auch immer das gleiche Objekt wieder und wieder überschreiben, darunter leidet dann aber erneut die Lesbarkeit.

Mit dem Pipe-Operator \texttt{\%\textgreater{}\%} können wir diese Schritte in einer logischen Lesereihenfolge ohne die Erstellung von redundaten Objekten durchführen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einsatzbereit <-}\StringTok{ }\NormalTok{ich }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{aufstehen}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{fruehstuecken}\NormalTok{(}\DataTypeTok{food =} \StringTok{"muesli"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{zaehne_putzen}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{duschen}\NormalTok{(}\DataTypeTok{wasser_temperatur =} \StringTok{"warm"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{anziehen}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{formale-definition}{%
\section{Formale Definition}\label{formale-definition}}

Formal ausgedrückt übergibt der Pipe-Operator \texttt{\%\textgreater{}\%} das links von ihm stehende Objekt als erstes Argument an die rechts von ihm stehende Funktion:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Die folgenden beiden Zeilen sind analog}
\KeywordTok{f}\NormalTok{(x)}
\NormalTok{x }\OperatorTok{%>%}\StringTok{ }\KeywordTok{f}\NormalTok{()}

\CommentTok{# Oder anhand einer echten Funktion}
\KeywordTok{mean}\NormalTok{(x) }\CommentTok{# ist analog zu}
\NormalTok{x }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Weitere Funktionsargumente können regulär entweder positional oder explizit durch Namensnennung an die Funktion übergeben werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Die folgenden beiden Zeilen sind wiederum analog}
\KeywordTok{f}\NormalTok{(x, y, z)}
\NormalTok{x }\OperatorTok{%>%}\StringTok{ }\KeywordTok{f}\NormalTok{(y, z)}

\CommentTok{# Und wieder am Beispiel der mean()-Funktion}
\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{) }\CommentTok{# ist analog zu}
\NormalTok{x }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{einsatz-von-pipes-im-tidyverse}{%
\section{Einsatz von Pipes im Tidyverse}\label{einsatz-von-pipes-im-tidyverse}}

Besonders sinnvoll sind \emph{Pipes} dann, wenn wir viele Funktionen hintereinander am gleichen Ausgangsobjekt aufrufen wollen, z. B. wenn wir unterschiedliche Schritte der Datenmodifikation an einem Datensatz vornehmen möchten. Bei den Tidyverse-Funktionen wissen wir, dass

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  das erste Argument immer der Datensatz, also ein Tibble, ist und
\item
  das Resultat der Funktion auch immer ein Datensatz, also ein Tibble ist.
\end{enumerate}

Daher können wir diese Schritte schnell aneinanderreihen. Nutzen wir als Beispiel nochmals den Datensatz aus Kapitel \ref{workingwithdata}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Wir laden den Datensatz}
\NormalTok{df_fb_eu <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/facebook_europawahl.csv"}\NormalTok{)}

\CommentTok{# Wir erstellen einen modifizierten Datensatz, indem wir:}
\CommentTok{# 1. nur die Video-Posts auswählen}
\CommentTok{# 2. nur die Variablen id, party und comment_count auswählen}
\CommentTok{# 3. Nach Partei gruppieren}
\CommentTok{# 4. Eine neue Variable erstellen, die für jeden Post angibt,}
\CommentTok{#    welchen Anteil dieser an allen Kommentaren unter Post der}
\CommentTok{#    jeweiligen Datei hatte}
\CommentTok{# 5. heben die Gruppierung wieder auf und}
\CommentTok{# 6. weisen das Resultat dieser 'Pipe' dem Objekt modified_df zu}

\NormalTok{modified_df <-}\StringTok{ }\NormalTok{df_fb_eu }\OperatorTok{%>%}\StringTok{ }\CommentTok{# Wir definieren die Zuweisung und übergeben df_fb_eu an}
\StringTok{  }\KeywordTok{filter}\NormalTok{(type }\OperatorTok{==}\StringTok{ "video"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# die filter()-Funktion; der resultierende Datensatz wird an}
\StringTok{  }\KeywordTok{select}\NormalTok{(id, party, comments_count) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# select() übergeben; das Resultat wiederum wird}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(party) }\OperatorTok{%>%}\StringTok{                   }\CommentTok{# gruppiert etc.}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{comment_percentage =}\NormalTok{ comments_count }\OperatorTok{/}\StringTok{ }\KeywordTok{sum}\NormalTok{(comments_count)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ungroup}\NormalTok{()}

\NormalTok{modified_df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 272 x 4
##       id party         comments_count comment_percentage
##    <dbl> <chr>                  <dbl>              <dbl>
##  1     1 oedp.de                    0           NA      
##  2     3 B90DieGruenen             70           NA      
##  3     6 CDU                      239           NA      
##  4     8 Piratenpartei              0            0      
##  5    11 DiePARTEI                 61            0.0371 
##  6    14 FDP                      358            0.117  
##  7    16 DiePARTEI                 15            0.00912
##  8    18 CDU                      140           NA      
##  9    26 SPD                      174            0.0599 
## 10    31 CDU                      274           NA      
## # ... with 262 more rows
\end{verbatim}

Auch für schnelle deskriptive Auswertungen können wir Pipes gut nutzen -- z. B. um uns schnell die Mittelwerte bestimmter Variablen gruppiert nach anderen Variablen anzuzeigen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_fb_eu }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(party, type) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{mean_comments =} \KeywordTok{mean}\NormalTok{(comments_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
            \DataTypeTok{mean_shares =} \KeywordTok{mean}\NormalTok{(shares_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{), }
            \DataTypeTok{mean_reactions =} \KeywordTok{mean}\NormalTok{(reactions_count, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 46 x 5
## # Groups:   party [14]
##    party             type   mean_comments mean_shares mean_reactions
##    <chr>             <chr>          <dbl>       <dbl>          <dbl>
##  1 alternativefuerde link           826.       1341.           2953 
##  2 alternativefuerde photo          860.       2466.           5269.
##  3 alternativefuerde video          875.        847.           2340.
##  4 B90DieGruenen     photo          134.        183.            902.
##  5 B90DieGruenen     video           77.9       184.            425.
##  6 CDU               photo          394.        114.            810.
##  7 CDU               video          293.         53.0           400.
##  8 CSU               link            25          11             132.
##  9 CSU               photo          143.         63.8           566.
## 10 CSU               status         416.        112.           1106 
## # ... with 36 more rows
\end{verbatim}

Praktisch, oder? Bleibt noch die eine Hürde, dass \texttt{\%\textgreater{}\%} eher kompliziert zu tippen ist -- dankenswerterweise stellt RStudio aber auch hier eine Tastenkombination zur Verfügung: \texttt{Strg/Cmd\ +\ Shift\ +\ M} fügt den gesamten Operator ein.

\hypertarget{uxfcbungsaufgaben-5}{%
\section{Übungsaufgaben}\label{uxfcbungsaufgaben-5}}

Erstellen Sie für die folgende Übungsaufgabe eine eigene Skriptdatei oder eine R-Markdown-Datei und speichern diese als \texttt{ue9\_nachname.R} bzw. \texttt{ue9\_nachname.Rmd} ab.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\BeginKnitrBlock{exercise}
\protect\hypertarget{exr:ue9-1}{}{\label{exr:ue9-1} }Pipes:
\EndKnitrBlock{exercise}

Lösen Sie die Übungsaufgaben \ref{exr:ue8-2} und \ref{exr:ue8-3} erneut, aber verwenden Sie Pipes, um den Code lesbarer und mit weniger redundanten Zwischenobjekten zu gestalten. An welchen Stellen ist es sinnvoll bzw. weniger sinnvoll, Pipes zu verwenden?

\hypertarget{appendix-anhang}{%
\appendix}


\hypertarget{loesungen}{%
\chapter{Lösungen der Übungsaufgaben}\label{loesungen}}

\hypertarget{kapitel-2-objekte-und-datenstrukturen}{%
\section*{Kapitel 2: Objekte und Datenstrukturen}\label{kapitel-2-objekte-und-datenstrukturen}}
\addcontentsline{toc}{section}{Kapitel 2: Objekte und Datenstrukturen}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue2-1}}:

Am sinnvollsten ist eine Liste \texttt{list()}, da diese heterogene Objekttypen beinhalten kann. Ein Dataframe lohnt sich bei nur einem Fall eher nicht.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myself <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{name =} \StringTok{"Julian"}\NormalTok{, }\CommentTok{# Texte als character}
  \DataTypeTok{year =}\NormalTok{ 1988L, }\CommentTok{# Jahr als numeric - oder noch präziser als Integer}
  \DataTypeTok{from_bavaria =} \OtherTok{FALSE} \CommentTok{# Binäre Entscheidung als logical}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Auch wenn wir hier alle Werte z. B. als Text repräsentieren könnten, ist es immer sinnvoll, den Objekttypen zu verwenden, der am besten zu den Werten passt -- numerische (\texttt{year}) und logische Objekte (\texttt{from\_bavaria}) ermöglichen uns mehr Rechenoptionen, einfacheres Filtern von Datensätzen etc.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue2-2}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{values <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{1.2}\NormalTok{, }\FloatTok{1.3}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{1.5}\NormalTok{, }\FloatTok{1.1}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.1}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{1.1}\NormalTok{)}
\NormalTok{average <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(values)}
\NormalTok{above_average <-}\StringTok{ }\NormalTok{values }\OperatorTok{>}\StringTok{ }\NormalTok{average}
\KeywordTok{sum}\NormalTok{(above_average) }\OperatorTok{/}\StringTok{ }\KeywordTok{length}\NormalTok{(values)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6363636
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In der ersten Zeile ordnen wir \texttt{values} einen numerischen Vektor aus einigen Zahlen zu
\item
  In der zweiten Zeile berechnen wir den Mittelwert von \texttt{values} und weisen diesen \texttt{average} zu.
\item
  \texttt{values\ \textgreater{}\ average} prüft nun für jeden Wert in \texttt{values}, ob dieser größer als der Mittelwert (gespeichert in \texttt{average} ist). Dies erzeugt einen \texttt{logical}-Vektor, den wir \texttt{above\_average} zuweisen.
\item
  \texttt{sum(above\_average)} zählt, wie viele \texttt{TRUE}-Werte in dem Vektor sind. Das ist darauf zurückzuführen, dass \texttt{TRUE} die numerische Entsprechung \texttt{1}, \texttt{FALSE} die numerische Entsprechung \texttt{0} hat; \texttt{sum()} wandelt den logischen Vektor automatisch in einen numerischen um. Wir teilen dies durch die Anzahl der Werte in \texttt{values} und bekommen als Ergebnis, dass 63.6 \% der Werte in \texttt{values} über dem Mittelwert liegen. (Etwas schneller hätten wir dieses Ergebnis auch bekommen, wenn wir die letzte Zeile durch \texttt{mean(above\_average)} ersetzen.)
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue2-3}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    32 obs. of  11 variables:
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
##  $ disp: num  160 160 108 258 360 ...
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
##  $ qsec: num  16.5 17 18.6 19.4 17 ...
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
\end{verbatim}

\texttt{mtcars} enthält 11 Variablen, allesamt \texttt{numeric}, und 32 Fälle.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.1875
\end{verbatim}

Im Durchschnitt haben die Fahrzeuge ca. 6.2 Zylinder.

Um einen Teildatensatz \texttt{cars\_short}, der lediglich die Variablen \texttt{mpg} und \texttt{hp} enthält, zu erstellen, führen viele Wege zum Ziel, z. B.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cars_short <-}\StringTok{ }\NormalTok{mtcars[, }\KeywordTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, }\StringTok{"hp"}\NormalTok{)]}
\NormalTok{cars_short <-}\StringTok{ }\NormalTok{mtcars[}\KeywordTok{c}\NormalTok{(}\StringTok{"mpg"}\NormalTok{, }\StringTok{"hp"}\NormalTok{)] }\CommentTok{# Steht nur eine Angabe in den eckigen Klammern, interpretiert R dies als Spaltenangabe}
\NormalTok{cars_short <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg, mtcars}\OperatorTok{$}\NormalTok{hp)}
\end{Highlighting}
\end{Shaded}

\hypertarget{kapitel-3-funktionen}{%
\section*{Kapitel 3: Funktionen}\label{kapitel-3-funktionen}}
\addcontentsline{toc}{section}{Kapitel 3: Funktionen}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue3-1}}:

Um die gewünschte Sequenz zu erzeugen, benötigen wir die Argumente \texttt{from} (Startwert), \texttt{to} (Endwert) und \texttt{by} (Zunahmewert).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{100}\NormalTok{, }\DataTypeTok{by =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   0   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90  95 100
\end{verbatim}

Da es sich, wie wir der Funktionsdokumentation entnehmen können, dabei um die ersten drei Funktionsargumente handelt, können wir diese auch unbenannt übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   0   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90  95 100
\end{verbatim}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue3-2}}:

Unsere Funktion benötigt lediglich ein Argument, die Temperatur in Grad Fahrenheit (als numerischen Wert), und soll diese in Grad Celsius mit der Formel \(°C = (°F − 32) × 5/9\) umwandeln:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fahrenheit_to_celsius <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(fahrenheit) \{}
\NormalTok{  celsius <-}\StringTok{ }\NormalTok{(fahrenheit }\OperatorTok{-}\StringTok{ }\DecValTok{32}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{5}\OperatorTok{/}\DecValTok{9}
  \KeywordTok{return}\NormalTok{(celsius)}
\NormalTok{\}}

\CommentTok{# Unsere neue Funktion kann sogar mehrere Temperaturwerte auf einmal umrechnen}
\KeywordTok{fahrenheit_to_celsius}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -17.77778  10.00000  26.66667  37.77778
\end{verbatim}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue3-3}}:

Für das erste zusätzliche Feature, der Anzahl der fehlenden Werte, müssen wir \texttt{descriptives\_vector} lediglich ein Element hinzufügen (das wir z. B. \texttt{Missing} nennen), in dem eben diese Anzahl festgehalten wird. Mit der Funktion \texttt{is.na()} prüfen wir jeden Wert eines Vektors darauf, ob es sich um einen fehlenden Wert \texttt{NA} handelt, mit der Summenfunktion \texttt{sum()} können wir diese addieren. Wir ändern \texttt{descriptives\_vector} daher wie folgt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{Missing =} \KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x)), }\CommentTok{# Hier zählen wir die fehlenden Werte}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm), }
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm)}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

Für das zweite zusätzliche Feature, Rundung auf eine gewünsche Anzahl an Nachkommastelle, benötigen wir die \texttt{round()}-Funktion, mit dem wir \texttt{descriptives\_vector} abschließend runden, und ein zusätzliches Argument, mit dem die gewünschte Anzahl an Nachkommastellen übergeben werden kann. Da dieses Argument bei der \texttt{round()}-Funktion \texttt{digits} heißt, nennen wir es aus Konsistenzgründen auch in unserer Funktion so. Um standardmäßig auf zwei Nachkommastellen zu runden, geben wir dem Argument den Default-Wert \texttt{2}. Der vollständige Funktionscode sieht also wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{descriptives <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{digits =} \DecValTok{2}\NormalTok{) \{ }\CommentTok{# Zusätzliches Argument digits mit Default-Wert 2}
  
  \CommentTok{# Vektor mit Variablenbeschreibung erstellen}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \DataTypeTok{n =} \KeywordTok{length}\NormalTok{(x),}
    \DataTypeTok{Missing =} \KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x)), }\CommentTok{# Hier zählen wir die fehlenden Werte}
    \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Minimum =} \KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm), }
    \DataTypeTok{Maximum =} \KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm),}
    \DataTypeTok{Median =} \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ na.rm)}
\NormalTok{  )}
  
  \CommentTok{# Vektor runden}
\NormalTok{  descriptives_vector <-}\StringTok{ }\KeywordTok{round}\NormalTok{(descriptives_vector, }\DataTypeTok{digits =}\NormalTok{ digits)}
  
  \KeywordTok{return}\NormalTok{(descriptives_vector)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wir haben nun eine flexibel einsetzbare Funktion, um schnell relevante Kennwerte einer numerischen Variablen zu erhalten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(iris}\OperatorTok{$}\NormalTok{Sepal.Length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       n Missing       M      SD Minimum Maximum  Median 
##  150.00    0.00    5.84    0.83    4.30    7.90    5.80
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{descriptives}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl, }\DataTypeTok{digits =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       n Missing       M      SD Minimum Maximum  Median 
##    32.0     0.0     6.2     1.8     4.0     8.0     6.0
\end{verbatim}

\hypertarget{kapitel-4-kontrollstrukturen}{%
\section*{Kapitel 4: Kontrollstrukturen}\label{kapitel-4-kontrollstrukturen}}
\addcontentsline{toc}{section}{Kapitel 4: Kontrollstrukturen}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue4-1}}:

Erneut gibt es verschiedene Möglichkeiten, den Entscheidungsbaum abzubilden. Wenn wir uns pro \texttt{if\ ()} bzw. \texttt{else\ ()} oder \texttt{else\ if\ ()} auf das Prüfen einer Bedingung beschränken wollen, benötigen wir einen verschachtelten Baum, also eine Bedinung in einer Bedingung:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (news_channel }\OperatorTok{!=}\StringTok{ "Internet"}\NormalTok{) \{             }\CommentTok{# Prüfen, ob news_channel NICHT "Internet" ist...}
\NormalTok{  news_category <-}\StringTok{ "Offline"}                  \CommentTok{# dann news_category "Offline" zuweisen}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{                                      }\CommentTok{# Falls das nicht der Fall ist, also news_channel "Internet" ist..}
  \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{==}\StringTok{ "Twitter"}\NormalTok{) \{            }\CommentTok{# dann prüfen wir ob news_category "Twitter" ist}
\NormalTok{    news_category <-}\StringTok{ "SNS"}                    \CommentTok{# falls das so ist, weisen wir news_category "SNS" zu}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{==}\StringTok{ "Facebook"}\NormalTok{) \{    }\CommentTok{# analog verfahren wir mit Facebook}
\NormalTok{    news_category <-}\StringTok{ "SNS"}                    \CommentTok{#}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{==}\StringTok{ "Instagram"}\NormalTok{) \{   }\CommentTok{# analog mit Instagram}
\NormalTok{    news_category <-}\StringTok{ "SNS"}                    \CommentTok{#}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{                                    }\CommentTok{# falls das alles nicht zutrifft}
\NormalTok{    news_category <-}\StringTok{ "Online: Sonstige"}       \CommentTok{# weisen wir "Online: Sonstige" zu}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Das erzeugt allerdings einen ziemlich langen Entscheidungsbaum und einige Redundanzen, da wir für \texttt{"Twitter"}, \texttt{"Facebook"} und \texttt{"Instagram"} jeweils dieselbe Aktion, \texttt{news\_category\ \textless{}-\ "SNS"} ausführen. Wir können diese Bedingungen also auch verknüpfen:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (news_channel }\OperatorTok{!=}\StringTok{ "Internet"}\NormalTok{) \{             }\CommentTok{# Prüfen, ob news_channel NICHT "Internet" ist...}
\NormalTok{  news_category <-}\StringTok{ "Offline"}                  \CommentTok{# dann news_category "Offline" zuweisen}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{                                      }\CommentTok{# Falls das nicht der Fall ist, also news_channel "Internet" ist..}
  \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{==}\StringTok{ "Twitter"} \OperatorTok{|}\StringTok{ }\NormalTok{news_website }\OperatorTok{==}\StringTok{ "Facebook"} \OperatorTok{|}\StringTok{ }\NormalTok{news_website }\OperatorTok{==}\StringTok{ "Instagram"}\NormalTok{) \{}
\NormalTok{    news_category <-}\StringTok{ "SNS"}                    \CommentTok{# Alle Bedingungen mit ODER verbunden, dann SNS zuweisen}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{                                    }\CommentTok{# falls das nicht zutrifft}
\NormalTok{    news_category <-}\StringTok{ "Online: Sonstige"}       \CommentTok{# weisen wir "Online: Sonstige" zu}
\NormalTok{  \}                                           }\CommentTok{# und haben uns einige Zeilen gespart}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Tatsächlich können wir auch die Verschachtelung aufheben, da nach \texttt{if\ (news\_channel\ !=\ "Internet")} folgt, dass bei allen anschließenden \texttt{else\ if()}-Bedingungen \texttt{news\_channel\ ==\ "Internet"} ist:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (news_channel }\OperatorTok{!=}\StringTok{ "Internet"}\NormalTok{) \{             }
\NormalTok{  news_category <-}\StringTok{ "Offline"}                  
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{==}\StringTok{ "Twitter"} \OperatorTok{|}\StringTok{ }\NormalTok{news_website }\OperatorTok{==}\StringTok{ "Facebook"} \OperatorTok{|}\StringTok{ }\NormalTok{news_website }\OperatorTok{==}\StringTok{ "Instagram"}\NormalTok{) \{}
\NormalTok{  news_category <-}\StringTok{ "SNS"} 
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{                                    }
\NormalTok{  news_category <-}\StringTok{ "Online: Sonstige"} 
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Und noch kürzer wir der Entscheidungsbaum, wenn wir den \texttt{\%in\%}-Operator verwenden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SNS <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Twitter"}\NormalTok{, }\StringTok{"Facebook"}\NormalTok{, }\StringTok{"Instagram"}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (news_channel }\OperatorTok{!=}\StringTok{ "Internet"}\NormalTok{) \{             }
\NormalTok{  news_category <-}\StringTok{ "Offline"}                  
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (news_website }\OperatorTok{%in%}\StringTok{ }\NormalTok{SNS) \{}
\NormalTok{  news_category <-}\StringTok{ "SNS"} 
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{                                    }
\NormalTok{  news_category <-}\StringTok{ "Online: Sonstige"} 
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Lösung zur Übungsaufgabe \ref{exr:ue4-2}}:

Beim ersten Platzhalter müssen wir einen \texttt{for}-Loop, wie in Kapitel \ref{forloops} beschrieben, einfügen und uns für einen Namen für das Iterator-Objekt entscheiden. Da wir über den Vektor \texttt{variables} loopen, bietet sich der Singular \texttt{variable} an (aber natürlich funktioniert auch jeder andere Objektname). Diesen müssen wir dann bei den folgenden Platzhaltern ergänzen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numeric_summary <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data) \{}
  
  \CommentTok{# Alle Variablennamen in Vektor speichern}
\NormalTok{  variables <-}\StringTok{ }\KeywordTok{names}\NormalTok{(data)}
  
  \CommentTok{# Leere Liste für Ausgabe vorbereiten}
\NormalTok{  summary_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  
  \CommentTok{# Über alle Variablen iterieren}
  \ControlFlowTok{for}\NormalTok{ (variable }\ControlFlowTok{in}\NormalTok{ variables) \{ }\CommentTok{# Wir loopen über variables}
\NormalTok{    variable_vector <-}\StringTok{ }\NormalTok{data[[variable]] }\CommentTok{# Und arbeiten nun immer mit dem Iterator-Objekt variable}
    
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.numeric}\NormalTok{(variable_vector)) \{ }\CommentTok{# Prüfen ob die Variable numerisch ist}
      
      \CommentTok{# Mittelwert und Standardabweichung dieser Variablen der summary_list hinzufügen}
\NormalTok{      summary_list[[variable]] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
        \DataTypeTok{M =} \KeywordTok{mean}\NormalTok{(variable_vector),   }
        \DataTypeTok{SD =} \KeywordTok{sd}\NormalTok{(variable_vector)}
\NormalTok{      )}
\NormalTok{    \}}
    
\NormalTok{  \}}
  
  \CommentTok{# Summary List ausgeben}
  \KeywordTok{return}\NormalTok{(summary_list)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Diese Funktion erzeugt uns nun auf einen Schlag eine Kurzzusammenfassung anhand von Mittelwert und Standardabweichung \emph{aller} numerischen Variablen in einem Datensatz:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{numeric_summary}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $Sepal.Length
##         M        SD 
## 5.8433333 0.8280661 
## 
## $Sepal.Width
##         M        SD 
## 3.0573333 0.4358663 
## 
## $Petal.Length
##        M       SD 
## 3.758000 1.765298 
## 
## $Petal.Width
##         M        SD 
## 1.1993333 0.7622377
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{numeric_summary}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $mpg
##         M        SD 
## 20.090625  6.026948 
## 
## $cyl
##        M       SD 
## 6.187500 1.785922 
## 
## $disp
##        M       SD 
## 230.7219 123.9387 
## 
## $hp
##         M        SD 
## 146.68750  68.56287 
## 
## $drat
##         M        SD 
## 3.5965625 0.5346787 
## 
## $wt
##         M        SD 
## 3.2172500 0.9784574 
## 
## $qsec
##         M        SD 
## 17.848750  1.786943 
## 
## $vs
##         M        SD 
## 0.4375000 0.5040161 
## 
## $am
##         M        SD 
## 0.4062500 0.4989909 
## 
## $gear
##         M        SD 
## 3.6875000 0.7378041 
## 
## $carb
##      M     SD 
## 2.8125 1.6152
\end{verbatim}

\end{document}
